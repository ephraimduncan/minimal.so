{"type":"file-history-snapshot","messageId":"06123b67-0019-4aec-aa67-ba0dfdf62319","snapshot":{"messageId":"06123b67-0019-4aec-aa67-ba0dfdf62319","trackedFileBackups":{},"timestamp":"2026-02-10T17:48:34.297Z"},"isSnapshotUpdate":false}
{"parentUuid":"e26ea9e1-8836-4adc-8a28-551b113c32f0","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"a1c50c67-513c-4b0c-bb9b-a69eb3f986d7","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"type":"text","text":"[Request interrupted by user for tool use]"}]},"uuid":"691b53ed-1074-4f22-a73e-914bc531063f","timestamp":"2026-02-10T17:48:34.268Z"}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":"Implement the following plan:\n\n# Merge `main` into `feat/export`\n\n## Context\n\n`feat/export` adds bookmark export (CSV/JSON) via 5 commits. Meanwhile `main` diverged with ~35 commits adding public profiles, avatar uploads, nuqs URL state, visibility toggles, RSS feeds, admin dashboard, etc. 5 files conflict. Goal: keep everything from both branches.\n\n## Strategy\n\nMerge `main` into `feat/export`. For each conflict, use **main's architecture as the base** and graft feat/export's export features into it. Two new files (`components/export-dialog.tsx`, `lib/export.ts`) come in cleanly with no conflicts.\n\n## File-by-file resolution\n\n### 1. `.claude/settings.local.json`\n- **Take main's version** (superset of feat/export's additions — both added `Bash(git commit:*)`, main also added hooks, deny rules, more permissions)\n\n### 2. `components/dashboard-content.tsx`\nMain rewrote this heavily (nuqs, orpc query keys, dynamic imports, profile/visibility features). Graft export into main's version:\n- Add `ExportDialog` and `handleQuickExport` imports\n- Add `exportDialogOpen` state\n- Add `allBookmarksQuery` (fetch all bookmarks when dialog opens) — adapt to use `orpc` query key pattern\n- Add `allBookmarks` memo\n- Add `handleQuickExportAction` callback\n- Add `handleOpenExportDialog` callback\n- Pass `onExport` to `<Header>` and `<MultiSelectToolbar>`\n- Render `<ExportDialog>` at bottom\n\n### 3. `components/header.tsx`\nMain added visibility, profile, readOnly, dynamic SettingsDialog import. Graft:\n- Add `onExport?: () => void` to `HeaderProps`\n- Destructure `onExport`\n- Pass `onExport` to `<SettingsDialog>`\n\n### 4. `components/multi-select-toolbar.tsx`\nMain added `hasUsername`, `onMakePublic`, `onMakePrivate`. Graft:\n- Add export-related imports (`DropdownMenu*`, `IconFileExport`, `IconFileTypeCsv`, `IconJson`)\n- Add `onExport: (format: \"csv\" | \"json\") => void` prop\n- Add export dropdown between \"Copy URLs\" and visibility buttons\n- Keep `motion-reduce` classes from feat/export\n\n### 5. `components/settings-dialog.tsx`\nMain completely redesigned to tabbed layout with avatar upload and ProfileTab. Graft:\n- Add `onExport?: () => void` to `SettingsDialogProps`\n- Destructure `onExport`\n- Add \"Data\" `<Field>` with Export button in the General tab (after Chrome Extension field, before `<DialogFooter>`)\n\n## Steps\n\n1. `git merge main` (will stop with conflicts)\n2. For `.claude/settings.local.json` — accept main's version (`git checkout main -- .claude/settings.local.json`)\n3. For each component file — start from main's version, then add export features\n4. `git add` resolved files and commit\n\n## Verification\n\n- `bunx tsc --noEmit` — type check\n- `bunx next build` — full build\n- Manual: open dashboard, verify export button in settings, export dropdown in multi-select toolbar\n\n\nIf you need specific details from before exiting plan mode (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/duncan/.REDACTED.jsonl\n\nIf this plan can be broken down into multiple independent tasks, consider using the TeamCreate tool to create a team and parallelize the work."},"uuid":"06123b67-0019-4aec-aa67-ba0dfdf62319","timestamp":"2026-02-10T17:48:34.261Z","planContent":"# Merge `main` into `feat/export`\n\n## Context\n\n`feat/export` adds bookmark export (CSV/JSON) via 5 commits. Meanwhile `main` diverged with ~35 commits adding public profiles, avatar uploads, nuqs URL state, visibility toggles, RSS feeds, admin dashboard, etc. 5 files conflict. Goal: keep everything from both branches.\n\n## Strategy\n\nMerge `main` into `feat/export`. For each conflict, use **main's architecture as the base** and graft feat/export's export features into it. Two new files (`components/export-dialog.tsx`, `lib/export.ts`) come in cleanly with no conflicts.\n\n## File-by-file resolution\n\n### 1. `.claude/settings.local.json`\n- **Take main's version** (superset of feat/export's additions — both added `Bash(git commit:*)`, main also added hooks, deny rules, more permissions)\n\n### 2. `components/dashboard-content.tsx`\nMain rewrote this heavily (nuqs, orpc query keys, dynamic imports, profile/visibility features). Graft export into main's version:\n- Add `ExportDialog` and `handleQuickExport` imports\n- Add `exportDialogOpen` state\n- Add `allBookmarksQuery` (fetch all bookmarks when dialog opens) — adapt to use `orpc` query key pattern\n- Add `allBookmarks` memo\n- Add `handleQuickExportAction` callback\n- Add `handleOpenExportDialog` callback\n- Pass `onExport` to `<Header>` and `<MultiSelectToolbar>`\n- Render `<ExportDialog>` at bottom\n\n### 3. `components/header.tsx`\nMain added visibility, profile, readOnly, dynamic SettingsDialog import. Graft:\n- Add `onExport?: () => void` to `HeaderProps`\n- Destructure `onExport`\n- Pass `onExport` to `<SettingsDialog>`\n\n### 4. `components/multi-select-toolbar.tsx`\nMain added `hasUsername`, `onMakePublic`, `onMakePrivate`. Graft:\n- Add export-related imports (`DropdownMenu*`, `IconFileExport`, `IconFileTypeCsv`, `IconJson`)\n- Add `onExport: (format: \"csv\" | \"json\") => void` prop\n- Add export dropdown between \"Copy URLs\" and visibility buttons\n- Keep `motion-reduce` classes from feat/export\n\n### 5. `components/settings-dialog.tsx`\nMain completely redesigned to tabbed layout with avatar upload and ProfileTab. Graft:\n- Add `onExport?: () => void` to `SettingsDialogProps`\n- Destructure `onExport`\n- Add \"Data\" `<Field>` with Export button in the General tab (after Chrome Extension field, before `<DialogFooter>`)\n\n## Steps\n\n1. `git merge main` (will stop with conflicts)\n2. For `.claude/settings.local.json` — accept main's version (`git checkout main -- .claude/settings.local.json`)\n3. For each component file — start from main's version, then add export features\n4. `git add` resolved files and commit\n\n## Verification\n\n- `bunx tsc --noEmit` — type check\n- `bunx next build` — full build\n- Manual: open dashboard, verify export button in settings, export dropdown in multi-select toolbar\n"}
{"parentUuid":"06123b67-0019-4aec-aa67-ba0dfdf62319","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01M1KJwrWkAz16x78ykYVN1b","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n`★ Insight ─────────────────────────────────────`\nThis is a merge conflict resolution task where `feat/export` (5 commits adding CSV/JSON export) needs to incorporate ~35 commits from `main` that added major features (public profiles, avatars, nuqs URL state, etc.). The strategy is to merge `main` in, use main's architecture as the base for conflicting files, then graft the export features on top. This preserves both branches' work cleanly.\n`─────────────────────────────────────────────────`\n\nLet me start by running the merge and then resolving conflicts. First, let me see the current state and kick off the merge."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1530,"cache_read_input_tokens":45019,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1530},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzotyFTi9Do8mvZ6CJJv","type":"assistant","uuid":"7d55a9e1-1887-4b92-bee1-333b5b9ff0a1","timestamp":"2026-02-10T17:48:41.063Z"}
{"parentUuid":"7d55a9e1-1887-4b92-bee1-333b5b9ff0a1","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01M1KJwrWkAz16x78ykYVN1b","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0141VkyRKih3DKszJz8aVaz1","name":"Bash","input":{"command":"git status --short","description":"Check current git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1530,"cache_read_input_tokens":45019,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1530},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzotyFTi9Do8mvZ6CJJv","type":"assistant","uuid":"d44ab136-0e12-4486-b4d0-d02c0eab5841","timestamp":"2026-02-10T17:48:41.763Z"}
{"parentUuid":"d44ab136-0e12-4486-b4d0-d02c0eab5841","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0141VkyRKih3DKszJz8aVaz1","type":"tool_result","content":"?? .entire/","is_error":false}]},"uuid":"71c18fbb-af5c-4cb6-b276-0e0ad397a736","timestamp":"2026-02-10T17:48:41.978Z","toolUseResult":{"stdout":"?? .entire/","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"d44ab136-0e12-4486-b4d0-d02c0eab5841"}
{"parentUuid":"71c18fbb-af5c-4cb6-b276-0e0ad397a736","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EpreyZJymvZtT7PmfNipEQ","type":"message","role":"assistant","content":[{"type":"text","text":"Good, clean working directory (just `.entire/` untracked which is fine). Let me start the merge."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3288,"cache_read_input_tokens":46549,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3288},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzouY1hEqz4CiFNRrDsx","type":"assistant","uuid":"aaca83ed-afb0-44c5-ab99-42f2e1bfcc7a","timestamp":"2026-02-10T17:48:45.706Z"}
{"parentUuid":"aaca83ed-afb0-44c5-ab99-42f2e1bfcc7a","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EpreyZJymvZtT7PmfNipEQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015C5hhok3iLueEdRrJ2rm55","name":"Bash","input":{"command":"git merge main 2>&1","description":"Merge main into feat/export"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3288,"cache_read_input_tokens":46549,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3288},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzouY1hEqz4CiFNRrDsx","type":"assistant","uuid":"6d5d209c-8a25-4878-90c3-abfa89d980e6","timestamp":"2026-02-10T17:48:46.458Z"}
{"parentUuid":"6d5d209c-8a25-4878-90c3-abfa89d980e6","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"Exit code 1\nAuto-merging .claude/settings.local.json\nCONFLICT (content): Merge conflict in .claude/settings.local.json\nAuto-merging components/dashboard-content.tsx\nCONFLICT (content): Merge conflict in components/dashboard-content.tsx\nAuto-merging components/header.tsx\nCONFLICT (content): Merge conflict in components/header.tsx\nAuto-merging components/multi-select-toolbar.tsx\nCONFLICT (content): Merge conflict in components/multi-select-toolbar.tsx\nAuto-merging components/settings-dialog.tsx\nCONFLICT (content): Merge conflict in components/settings-dialog.tsx\nAutomatic merge failed; fix conflicts and then commit the result.","is_error":true,"tool_use_id":"toolu_015C5hhok3iLueEdRrJ2rm55"}]},"uuid":"e86479dc-a9e7-443a-9bc7-a679b40847da","timestamp":"2026-02-10T17:48:49.264Z","toolUseResult":"Error: Exit code 1\nAuto-merging .claude/settings.local.json\nCONFLICT (content): Merge conflict in .claude/settings.local.json\nAuto-merging components/dashboard-content.tsx\nCONFLICT (content): Merge conflict in components/dashboard-content.tsx\nAuto-merging components/header.tsx\nCONFLICT (content): Merge conflict in components/header.tsx\nAuto-merging components/multi-select-toolbar.tsx\nCONFLICT (content): Merge conflict in components/multi-select-toolbar.tsx\nAuto-merging components/settings-dialog.tsx\nCONFLICT (content): Merge conflict in components/settings-dialog.tsx\nAutomatic merge failed; fix conflicts and then commit the result.","sourceToolAssistantUUID":"6d5d209c-8a25-4878-90c3-abfa89d980e6"}
{"parentUuid":"e86479dc-a9e7-443a-9bc7-a679b40847da","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_017BnUArFc8gCwQ5RaH9ZrQn","type":"message","role":"assistant","content":[{"type":"text","text":"Exactly the 5 conflicts we expected. Let me resolve them. First, let me take main's version for the settings file, then read all 4 conflicting component files (both the current conflicted state and what we need from each branch)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":321,"cache_read_input_tokens":49837,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":321},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzov3YhgdAp7tCueD4Hx","type":"assistant","uuid":"c24bd43e-e073-453c-928a-d85104a44e3b","timestamp":"2026-02-10T17:48:53.680Z"}
{"parentUuid":"c24bd43e-e073-453c-928a-d85104a44e3b","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_017BnUArFc8gCwQ5RaH9ZrQn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V3qzao2EZV2VX2pe1CXQwn","name":"Bash","input":{"command":"git checkout main -- .claude/settings.local.json","description":"Take main's version of settings"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":321,"cache_read_input_tokens":49837,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":321},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzov3YhgdAp7tCueD4Hx","type":"assistant","uuid":"de1c32e8-01ef-4925-8b1b-c58f35787eb9","timestamp":"2026-02-10T17:48:54.367Z"}
{"parentUuid":"de1c32e8-01ef-4925-8b1b-c58f35787eb9","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_017BnUArFc8gCwQ5RaH9ZrQn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GZ8G7Pj4y8XZ4zsWttYjRC","name":"Bash","input":{"command":"git show feat/export:components/dashboard-content.tsx","description":"Get feat/export's version of dashboard-content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":321,"cache_read_input_tokens":49837,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":321},"output_tokens":2,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzov3YhgdAp7tCueD4Hx","type":"assistant","uuid":"94768f6f-06ab-444c-b622-0d424bbec863","timestamp":"2026-02-10T17:48:55.111Z"}
{"parentUuid":"94768f6f-06ab-444c-b622-0d424bbec863","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_017BnUArFc8gCwQ5RaH9ZrQn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0115MnwsZStWVSYN9vbqK7UW","name":"Bash","input":{"command":"git show main:components/dashboard-content.tsx","description":"Get main's version of dashboard-content"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":321,"cache_read_input_tokens":49837,"output_tokens":281,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":321,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXzov3YhgdAp7tCueD4Hx","type":"assistant","uuid":"7e504011-b519-4e9c-b5c3-9d584e904649","timestamp":"2026-02-10T17:48:55.722Z"}
{"parentUuid":"de1c32e8-01ef-4925-8b1b-c58f35787eb9","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01V3qzao2EZV2VX2pe1CXQwn","type":"tool_result","content":"","is_error":false}]},"uuid":"100c2d69-fee0-45fe-86d3-6bf2ae08af32","timestamp":"2026-02-10T17:48:58.398Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"de1c32e8-01ef-4925-8b1b-c58f35787eb9"}
{"parentUuid":"7e504011-b519-4e9c-b5c3-9d584e904649","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0115MnwsZStWVSYN9vbqK7UW","type":"tool_result","content":"<persisted-output>\nOutput too large (37.6KB). Full output saved to: /Users/duncan/.REDACTED.txt\n\nPreview (first 2KB):\n\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n...\n</persisted-output>","is_error":false}]},"uuid":"7b312034-a64d-4dc4-812f-27e76dbbb106","timestamp":"2026-02-10T17:48:58.564Z","toolUseResult":{"stdout":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"7e504011-b519-4e9c-b5c3-9d584e904649"}
{"parentUuid":"94768f6f-06ab-444c-b622-0d424bbec863","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GZ8G7Pj4y8XZ4zsWttYjRC","type":"tool_result","content":"<persisted-output>\nOutput too large (29.7KB). Full output saved to: /Users/duncan/.REDACTED.txt\n\nPreview (first 2KB):\n\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\nimport { MultiSelectToolbar } from \"@/components/multi-select-toolbar\";\nimport { BulkMoveDialog } from \"@/components/bulk-move-dialog\";\nimport { BulkDeleteDialog } from \"@/components/bulk-delete-dialog\";\nimport { ExportDialog, handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl } from \"@/lib/utils\";\nimport { client } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n}\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [selectedGroupId, setSelectedGroupId] = useState<string | null>(null);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n...\n</persisted-output>","is_error":false}]},"uuid":"9ffca6e4-2bd8-4eb5-9c70-0da13ab1d37d","timestamp":"2026-02-10T17:48:58.565Z","toolUseResult":{"stdout":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\nimport { MultiSelectToolbar } from \"@/components/multi-select-toolbar\";\nimport { BulkMoveDialog } from \"@/components/bulk-move-dialog\";\nimport { BulkDeleteDialog } from \"@/components/bulk-delete-dialog\";\nimport { ExportDialog, handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl } from \"@/lib/utils\";\nimport { client } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n}\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [selectedGroupId, setSelectedGroupId] = useState<string | null>(null);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    queryKey: [\"groups\"],\n    queryFn: () => client.group.list(),\n    initialData: initialGroups,\n    staleTime: 60 * 1000,\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  useFocusRefetch(groups);\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    queryKey: [\"bookmarks\", currentGroupId],\n    queryFn: () =>\n      client.bookmark.list({ groupId: currentGroupId ?? undefined }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    enabled: !!currentGroupId,\n    staleTime: 60 * 1000,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data]\n  );\n\n  const allBookmarksQuery = useQuery({\n    queryKey: [\"bookmarks\", \"all\"],\n    queryFn: () => client.bookmark.list({}),\n    enabled: exportDialogOpen,\n    staleTime: 60 * 1000,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data]\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    mutationFn: (data: {\n      title: string;\n      url?: string;\n      type: BookmarkType;\n      color?: string;\n      groupId: string;\n    }) => client.bookmark.create(data),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: [\"bookmarks\", newBookmark.groupId],\n      });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        newBookmark.groupId,\n      ]);\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type,\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        [\"bookmarks\", newBookmark.groupId],\n        (old) => [optimisticBookmark, ...(old || [])]\n      );\n\n      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g\n        )\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.groupId],\n          context.previousBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: [\"bookmarks\", variables.groupId],\n      });\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n\n      await queryClient.cancelQueries({ queryKey: [\"bookmarks\"] });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >([\"bookmarks\", _sourceGroupId]);\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >([\"bookmarks\", targetGroupId]);\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            [\"bookmarks\", _sourceGroupId],\n            (old) => old?.filter((b) => b.id !== id) ?? []\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            [\"bookmarks\", targetGroupId],\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ]\n          );\n\n          queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            })\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        sourceGroupId,\n      ]);\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        [\"bookmarks\", sourceGroupId],\n        (old) => old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? []\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.sourceGroupId],\n          context.previousSourceBookmarks\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.targetGroupId],\n          context.previousTargetBookmarks\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.sourceGroupId],\n          context.previousBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.sourceGroupId],\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.targetGroupId],\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n      const previousSelectedGroupId = selectedGroupId;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setSelectedGroupId(optimisticGroup.id);\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousSelectedGroupId,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      if (context?.previousSelectedGroupId !== undefined) {\n        setSelectedGroupId(context.previousSelectedGroupId);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    mutationFn: (data: { id: string }) => client.group.delete(data),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n      const previousSelectedGroupId = selectedGroupId;\n\n      queryClient.setQueryData<GroupItem[]>(\n        [\"groups\"],\n        (old) => old?.filter((g) => g.id !== data.id) ?? []\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setSelectedGroupId(remainingGroups[0]?.id ?? null);\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousSelectedGroupId, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      if (context?.previousSelectedGroupId !== undefined) {\n        setSelectedGroupId(context.previousSelectedGroupId);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string }) => client.bookmark.refetch(data),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"bookmarks\"] });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: [\"bookmarks\", groupId] });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        groupId,\n      ]);\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        [\"bookmarks\", groupId],\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? []\n      );\n\n      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n              ...g,\n              bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - data.ids.length),\n            }\n            : g\n        )\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.groupId],\n          context.previousBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.groupId],\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: [\"bookmarks\"] });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        sourceGroupId,\n      ]);\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        targetGroupId,\n      ]);\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id)\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          [\"bookmarks\", sourceGroupId],\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? []\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          [\"bookmarks\", targetGroupId],\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ]\n        );\n\n        queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + ids.length };\n            }\n            return g;\n          })\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.sourceGroupId],\n          context.previousSourceBookmarks\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.targetGroupId],\n          context.previousTargetBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.sourceGroupId],\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.targetGroupId],\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId]\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode]\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [bulkDeleteMutation, selectedIds, currentGroupId, handleExitSelectionMode]);\n\n  const handleQuickExportAction = useCallback(\n    (format: \"csv\" | \"json\") => {\n      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n      handleExitSelectionMode();\n    },\n    [bookmarks, selectedIds, groups, handleExitSelectionMode]\n  );\n\n  const handleOpenExportDialog = useCallback(() => {\n    setExportDialogOpen(true);\n  }, []);\n\n  // Refs to store latest values for stable keyboard handler\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      setSelectedGroupId(id);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [handleExitSelectionMode]\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation]\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate(\n        { name, color },\n        {\n          onSuccess: (newGroup) => {\n            setSelectedGroupId(newGroup.id);\n          },\n        }\n      );\n    },\n    [createGroupMutation, groups]\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation]\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId]\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId]\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({ id });\n    },\n    [refetchBookmarkMutation]\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      // Allow all keyboard events when focus is on the search input\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      // Allow standard text editing shortcuts when focus is on any input/textarea\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        onExport={handleOpenExportDialog}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onExport={handleQuickExportAction}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n        <ExportDialog\n          open={exportDialogOpen}\n          onOpenChange={setExportDialogOpen}\n          mode=\"settings\"\n          bookmarks={allBookmarks}\n          groups={groups}\n        />\n      </main>\n    </div>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"94768f6f-06ab-444c-b622-0d424bbec863"}
{"parentUuid":"9ffca6e4-2bd8-4eb5-9c70-0da13ab1d37d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the full files from both branches:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"cfb0c3f5-5d1e-4130-b8e0-5c6b8fd52869","timestamp":"2026-02-10T17:49:02.026Z"}
{"parentUuid":"cfb0c3f5-5d1e-4130-b8e0-5c6b8fd52869","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VWD1cmsvZshbajm7VCWUvA","name":"Read","input":{"file_path":"/Users/duncan/.REDACTED.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"d54c61f3-64ef-4779-a3fe-5aab90170684","timestamp":"2026-02-10T17:49:02.977Z"}
{"parentUuid":"d54c61f3-64ef-4779-a3fe-5aab90170684","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bi1dQbKGdSnYRtshPtXNGU","name":"Read","input":{"file_path":"/Users/duncan/.REDACTED.txt"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"8a29451e-9087-4238-a19e-86f831b3983f","timestamp":"2026-02-10T17:49:03.836Z"}
{"parentUuid":"8a29451e-9087-4238-a19e-86f831b3983f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BmvNqbNLnTehjYEVqr42Vc","name":"Bash","input":{"command":"git show feat/export:components/header.tsx","description":"Get feat/export's header.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"a05b0e74-5be9-49a2-a7df-4f27f7d06a73","timestamp":"2026-02-10T17:49:04.591Z"}
{"parentUuid":"a05b0e74-5be9-49a2-a7df-4f27f7d06a73","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011iE2Hd8S54bXwhcXNhZnzh","name":"Bash","input":{"command":"git show main:components/header.tsx","description":"Get main's header.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"21cd9fdf-c550-42bf-8b44-4ab9c7fe49d4","timestamp":"2026-02-10T17:49:04.947Z"}
{"parentUuid":"21cd9fdf-c550-42bf-8b44-4ab9c7fe49d4","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012fZYUoP9UwFoKSv3sjmCxe","name":"Bash","input":{"command":"git show feat/export:components/multi-select-toolbar.tsx","description":"Get feat/export's multi-select-toolbar.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"222c7b5e-6722-44f5-8dcc-a095da87b1a3","timestamp":"2026-02-10T17:49:05.439Z"}
{"parentUuid":"222c7b5e-6722-44f5-8dcc-a095da87b1a3","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Lpmdy6hvQthUPrczLAdU16","name":"Bash","input":{"command":"git show main:components/multi-select-toolbar.tsx","description":"Get main's multi-select-toolbar.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"2905b987-c613-49e0-b4ae-10df6e2d5371","timestamp":"2026-02-10T17:49:05.996Z"}
{"parentUuid":"2905b987-c613-49e0-b4ae-10df6e2d5371","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NgqpXBC84cfsbD9kPd7Jim","name":"Bash","input":{"command":"git show feat/export:components/settings-dialog.tsx","description":"Get feat/export's settings-dialog.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"80ba34d1-07c3-4d3a-833b-904a6bbc4322","timestamp":"2026-02-10T17:49:06.515Z"}
{"parentUuid":"80ba34d1-07c3-4d3a-833b-904a6bbc4322","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01EQgwGz2aBzBG9oMNmg8oAZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AVbiqVueHA8vnJyaw9tMcf","name":"Bash","input":{"command":"git show main:components/settings-dialog.tsx","description":"Get main's settings-dialog.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":767,"cache_creation_input_tokens":1046,"cache_read_input_tokens":50158,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1046},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzovmfkjcFyV6gbSHT6U","type":"assistant","uuid":"32209db4-6e05-4023-9be2-0cf47dadb0ea","timestamp":"2026-02-10T17:49:06.959Z"}
{"parentUuid":"a05b0e74-5be9-49a2-a7df-4f27f7d06a73","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BmvNqbNLnTehjYEVqr42Vc","type":"tool_result","content":"\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  IconSelector,\n  IconPlus,\n  IconCheck,\n  IconTrash,\n  IconSettings,\n  IconLogout,\n} from \"@tabler/icons-react\";\nimport { signOut } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport { SettingsDialog } from \"@/components/settings-dialog\";\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  userName: string;\n  userEmail: string;\n  onExport?: () => void;\n}\n\nexport function Header({\n  groups,\n  selectedGroup,\n  onSelectGroup,\n  onCreateGroup,\n  onDeleteGroup,\n  userName,\n  userEmail,\n  onExport,\n}: HeaderProps) {\n  const router = useRouter();\n  const [newGroupName, setNewGroupName] = useState(\"\");\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [signOutOpen, setSignOutOpen] = useState(false);\n  const [holdingGroupId, setHoldingGroupId] = useState<string | null>(null);\n  const [holdProgress, setHoldProgress] = useState(0);\n  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const holdStartRef = useRef<number>(0);\n\n  const handleSignOut = async () => {\n    await signOut();\n    router.push(\"/login\");\n  };\n\n  const handleCreateGroup = () => {\n    if (newGroupName.trim()) {\n      onCreateGroup(newGroupName.trim());\n      setNewGroupName(\"\");\n      setDialogOpen(false);\n    }\n  };\n\n  const cancelHold = useCallback(() => {\n    if (holdTimerRef.current) {\n      clearTimeout(holdTimerRef.current);\n    }\n    setHoldingGroupId(null);\n    setHoldProgress(0);\n  }, []);\n\n  const startHold = useCallback(\n    (groupId: string) => {\n      if (groups.length <= 1) return;\n      setHoldingGroupId(groupId);\n      holdStartRef.current = Date.now();\n\n      const updateProgress = () => {\n        const elapsed = Date.now() - holdStartRef.current;\n        const progress = Math.min((elapsed / 2000) * 100, 100);\n        setHoldProgress(progress);\n\n        if (progress >= 100) {\n          onDeleteGroup?.(groupId);\n          cancelHold();\n        } else {\n          holdTimerRef.current = setTimeout(updateProgress, 16);\n        }\n      };\n\n      holdTimerRef.current = setTimeout(updateProgress, 16);\n    },\n    [groups.length, onDeleteGroup, cancelHold],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (holdTimerRef.current) {\n        clearTimeout(holdTimerRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <header className=\"flex items-center justify-between px-6 py-3\">\n      <div className=\"flex items-center gap-2\">\n        <BmrksLogo />\n        <span className=\"text-muted-foreground\">/</span>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            className=\"rounded-xl\"\n            render={<Button variant=\"ghost\" className=\"gap-2 px-2\" />}\n          >\n            <span\n              className=\"h-2.5 w-2.5 rounded-full\"\n              style={{ backgroundColor: selectedGroup.color }}\n            />\n            <span>{selectedGroup.name}</span>\n            <IconSelector className=\"h-4 w-4 text-muted-foreground\" />\n          </DropdownMenuTrigger>\n          <DropdownMenuContent\n            align=\"start\"\n            className=\"w-48 space-y-1 rounded-xl\"\n          >\n            {groups.map((group) => (\n              <DropdownMenuItem\n                key={group.id}\n                onClick={() => onSelectGroup(group.id)}\n                className={cn(\n                  \"flex items-center justify-between rounded-lg\",\n                  group.id === selectedGroup.id && \"bg-accent\",\n                )}\n              >\n                <div className=\"flex items-center gap-2\">\n                  <span\n                    className=\"h-2.5 w-2.5 rounded-full\"\n                    style={{ backgroundColor: group.color }}\n                  />\n                  <span>{group.name}</span>\n                </div>\n                {group.id === selectedGroup.id ? (\n                  <IconCheck className=\"h-4 w-4\" />\n                ) : (\n                  <span className=\"text-xs text-muted-foreground\">\n                    {group.bookmarkCount ?? 0}\n                  </span>\n                )}\n              </DropdownMenuItem>\n            ))}\n            <DropdownMenuItem\n              onClick={() => setDialogOpen(true)}\n              className=\"rounded-lg w-full\"\n            >\n              <IconPlus className=\"h-4 w-4 mr-0\" />\n              Create Group\n            </DropdownMenuItem>\n            {groups.length > 1 && (\n              <DropdownMenuItem\n                onSelect={(e) => e.preventDefault()}\n                onMouseDown={() => startHold(selectedGroup.id)}\n                onMouseUp={cancelHold}\n                onMouseLeave={cancelHold}\n                onTouchStart={() => startHold(selectedGroup.id)}\n                onTouchEnd={cancelHold}\n                className=\"relative overflow-hidden text-destructive focus:text-destructive rounded-lg\"\n              >\n                {holdingGroupId === selectedGroup.id && (\n                  <div\n                    className=\"absolute inset-0 bg-destructive/20 origin-left\"\n                    style={{ transform: `scaleX(${holdProgress / 100})` }}\n                  />\n                )}\n                <span className=\"relative z-10 flex items-center gap-2\">\n                  <IconTrash className=\"h-4 w-4 text-destructive\" />\n                  {holdingGroupId === selectedGroup.id\n                    ? \"Hold to delete...\"\n                    : \"Delete Group\"}\n                </span>\n              </DropdownMenuItem>\n            )}\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n          <DialogContent className=\"sm:max-w-sm\">\n            <Form\n              className=\"contents\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleCreateGroup();\n              }}\n            >\n              <DialogHeader>\n                <DialogTitle>Create Group</DialogTitle>\n                <DialogDescription>\n                  Create a new group to organize your bookmarks.\n                </DialogDescription>\n              </DialogHeader>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  placeholder=\"Enter group name\"\n                  value={newGroupName}\n                  onChange={(e) => setNewGroupName(e.target.value)}\n                  autoFocus\n                />\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button type=\"submit\" disabled={!newGroupName.trim()}>\n                  Create\n                </Button>\n              </DialogFooter>\n            </Form>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      <DropdownMenu>\n        <DropdownMenuTrigger\n          className=\"rounded-xl\"\n          render={\n            <Button\n              variant=\"ghost\"\n              className=\"w-44 justify-between gap-2 px-2\"\n            />\n          }\n        >\n          <UserAvatar name={userName} />\n          <span className=\"truncate\">{userName}</span>\n          <IconSelector className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"end\" className=\"rounded-2xl\">\n          <DropdownMenuItem\n            className=\"rounded-lg\"\n            onClick={() => setSettingsOpen(true)}\n          >\n            <IconSettings className=\"h-4 w-4\" />\n            Settings\n          </DropdownMenuItem>\n          <DropdownMenuItem\n            className=\"rounded-lg\"\n            render={\n              <a href=\"/chrome\" target=\"_blank\" rel=\"noopener noreferrer\" />\n            }\n          >\n            <ChromeIcon />\n            Chrome Extension\n          </DropdownMenuItem>\n          <DropdownMenuItem\n            className=\"rounded-lg\"\n            onClick={() => setSignOutOpen(true)}\n          >\n            <IconLogout className=\"h-4 w-4\" />\n            Sign out\n          </DropdownMenuItem>\n        </DropdownMenuContent>\n      </DropdownMenu>\n      <AlertDialog open={signOutOpen} onOpenChange={setSignOutOpen}>\n        <AlertDialogContent>\n          <AlertDialogHeader>\n            <AlertDialogTitle className=\"font-semibold text-xl\">\n              Sign out?\n            </AlertDialogTitle>\n            <AlertDialogDescription>\n              You will need to sign in again to access your bookmarks.\n            </AlertDialogDescription>\n          </AlertDialogHeader>\n          <AlertDialogFooter>\n            <AlertDialogCancel variant=\"ghost\">Cancel</AlertDialogCancel>\n            <AlertDialogAction variant=\"destructive\" onClick={handleSignOut}>\n              Sign out\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </AlertDialogContent>\n      </AlertDialog>\n      <SettingsDialog\n        open={settingsOpen}\n        onOpenChange={setSettingsOpen}\n        user={{ name: userName, email: userEmail }}\n        onExport={onExport}\n      />\n    </header>\n  );\n}\n\nfunction BmrksLogo() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      aria-label=\"Logo\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12.432 17.949c.863 1.544 2.589 1.976 4.13 1.112c1.54 -.865 1.972 -2.594 1.048 -4.138c-.185 -.309 -.309 -.556 -.494 -.74c.247 .06 .555 .06 .925 .06c1.726 0 2.959 -1.234 2.959 -2.963c0 -1.73 -1.233 -2.965 -3.02 -2.965c-.37 0 -.617 0 -.925 .062c.185 -.185 .308 -.432 .493 -.74c.863 -1.545 .431 -3.274 -1.048 -4.138c-1.541 -.865 -3.205 -.433 -4.13 1.111c-.185 .309 -.308 .556 -.432 .803c-.123 -.247 -.246 -.494 -.431 -.803c-.802 -1.605 -2.528 -2.038 -4.007 -1.173c-1.541 .865 -1.973 2.594 -1.048 4.137c.185 .31 .308 .556 .493 .741c-.246 -.061 -.555 -.061 -.924 -.061c-1.788 0 -3.021 1.235 -3.021 2.964c0 1.729 1.233 2.964 3.02 2.964\" />\n      <path d=\"M4.073 21c4.286 -2.756 5.9 -5.254 7.927 -9\" />\n    </svg>\n  );\n}\n\nfunction UserAvatar({ name }: { name: string }) {\n  return (\n    <svg viewBox=\"0 0 32 32\" fill=\"none\" width=\"24\" height=\"24\">\n      <rect width=\"32\" height=\"32\" rx=\"16\" fill=\"#74B06F\" />\n      <text\n        x=\"50%\"\n        y=\"50%\"\n        dominantBaseline=\"central\"\n        textAnchor=\"middle\"\n        fill=\"white\"\n        fontSize=\"14\"\n        fontWeight=\"500\"\n      >\n        {name.charAt(0).toUpperCase()}\n      </text>\n    </svg>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","is_error":false}]},"uuid":"278aceb7-43fa-4b70-a512-248bf3780e84","timestamp":"2026-02-10T17:49:07.179Z","toolUseResult":{"stdout":"\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  IconSelector,\n  IconPlus,\n  IconCheck,\n  IconTrash,\n  IconSettings,\n  IconLogout,\n} from \"@tabler/icons-react\";\nimport { signOut } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport { SettingsDialog } from \"@/components/settings-dialog\";\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  userName: string;\n  userEmail: string;\n  onExport?: () => void;\n}\n\nexport function Header({\n  groups,\n  selectedGroup,\n  onSelectGroup,\n  onCreateGroup,\n  onDeleteGroup,\n  userName,\n  userEmail,\n  onExport,\n}: HeaderProps) {\n  const router = useRouter();\n  const [newGroupName, setNewGroupName] = useState(\"\");\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [signOutOpen, setSignOutOpen] = useState(false);\n  const [holdingGroupId, setHoldingGroupId] = useState<string | null>(null);\n  const [holdProgress, setHoldProgress] = useState(0);\n  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const holdStartRef = useRef<number>(0);\n\n  const handleSignOut = async () => {\n    await signOut();\n    router.push(\"/login\");\n  };\n\n  const handleCreateGroup = () => {\n    if (newGroupName.trim()) {\n      onCreateGroup(newGroupName.trim());\n      setNewGroupName(\"\");\n      setDialogOpen(false);\n    }\n  };\n\n  const cancelHold = useCallback(() => {\n    if (holdTimerRef.current) {\n      clearTimeout(holdTimerRef.current);\n    }\n    setHoldingGroupId(null);\n    setHoldProgress(0);\n  }, []);\n\n  const startHold = useCallback(\n    (groupId: string) => {\n      if (groups.length <= 1) return;\n      setHoldingGroupId(groupId);\n      holdStartRef.current = Date.now();\n\n      const updateProgress = () => {\n        const elapsed = Date.now() - holdStartRef.current;\n        const progress = Math.min((elapsed / 2000) * 100, 100);\n        setHoldProgress(progress);\n\n        if (progress >= 100) {\n          onDeleteGroup?.(groupId);\n          cancelHold();\n        } else {\n          holdTimerRef.current = setTimeout(updateProgress, 16);\n        }\n      };\n\n      holdTimerRef.current = setTimeout(updateProgress, 16);\n    },\n    [groups.length, onDeleteGroup, cancelHold],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (holdTimerRef.current) {\n        clearTimeout(holdTimerRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <header className=\"flex items-center justify-between px-6 py-3\">\n      <div className=\"flex items-center gap-2\">\n        <BmrksLogo />\n        <span className=\"text-muted-foreground\">/</span>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            className=\"rounded-xl\"\n            render={<Button variant=\"ghost\" className=\"gap-2 px-2\" />}\n          >\n            <span\n              className=\"h-2.5 w-2.5 rounded-full\"\n              style={{ backgroundColor: selectedGroup.color }}\n            />\n            <span>{selectedGroup.name}</span>\n            <IconSelector className=\"h-4 w-4 text-muted-foreground\" />\n          </DropdownMenuTrigger>\n          <DropdownMenuContent\n            align=\"start\"\n            className=\"w-48 space-y-1 rounded-xl\"\n          >\n            {groups.map((group) => (\n              <DropdownMenuItem\n                key={group.id}\n                onClick={() => onSelectGroup(group.id)}\n                className={cn(\n                  \"flex items-center justify-between rounded-lg\",\n                  group.id === selectedGroup.id && \"bg-accent\",\n                )}\n              >\n                <div className=\"flex items-center gap-2\">\n                  <span\n                    className=\"h-2.5 w-2.5 rounded-full\"\n                    style={{ backgroundColor: group.color }}\n                  />\n                  <span>{group.name}</span>\n                </div>\n                {group.id === selectedGroup.id ? (\n                  <IconCheck className=\"h-4 w-4\" />\n                ) : (\n                  <span className=\"text-xs text-muted-foreground\">\n                    {group.bookmarkCount ?? 0}\n                  </span>\n                )}\n              </DropdownMenuItem>\n            ))}\n            <DropdownMenuItem\n              onClick={() => setDialogOpen(true)}\n              className=\"rounded-lg w-full\"\n            >\n              <IconPlus className=\"h-4 w-4 mr-0\" />\n              Create Group\n            </DropdownMenuItem>\n            {groups.length > 1 && (\n              <DropdownMenuItem\n                onSelect={(e) => e.preventDefault()}\n                onMouseDown={() => startHold(selectedGroup.id)}\n                onMouseUp={cancelHold}\n                onMouseLeave={cancelHold}\n                onTouchStart={() => startHold(selectedGroup.id)}\n                onTouchEnd={cancelHold}\n                className=\"relative overflow-hidden text-destructive focus:text-destructive rounded-lg\"\n              >\n                {holdingGroupId === selectedGroup.id && (\n                  <div\n                    className=\"absolute inset-0 bg-destructive/20 origin-left\"\n                    style={{ transform: `scaleX(${holdProgress / 100})` }}\n                  />\n                )}\n                <span className=\"relative z-10 flex items-center gap-2\">\n                  <IconTrash className=\"h-4 w-4 text-destructive\" />\n                  {holdingGroupId === selectedGroup.id\n                    ? \"Hold to delete...\"\n                    : \"Delete Group\"}\n                </span>\n              </DropdownMenuItem>\n            )}\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n          <DialogContent className=\"sm:max-w-sm\">\n            <Form\n              className=\"contents\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleCreateGroup();\n              }}\n            >\n              <DialogHeader>\n                <DialogTitle>Create Group</DialogTitle>\n                <DialogDescription>\n                  Create a new group to organize your bookmarks.\n                </DialogDescription>\n              </DialogHeader>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  placeholder=\"Enter group name\"\n                  value={newGroupName}\n                  onChange={(e) => setNewGroupName(e.target.value)}\n                  autoFocus\n                />\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button type=\"submit\" disabled={!newGroupName.trim()}>\n                  Create\n                </Button>\n              </DialogFooter>\n            </Form>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      <DropdownMenu>\n        <DropdownMenuTrigger\n          className=\"rounded-xl\"\n          render={\n            <Button\n              variant=\"ghost\"\n              className=\"w-44 justify-between gap-2 px-2\"\n            />\n          }\n        >\n          <UserAvatar name={userName} />\n          <span className=\"truncate\">{userName}</span>\n          <IconSelector className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n        </DropdownMenuTrigger>\n        <DropdownMenuContent align=\"end\" className=\"rounded-2xl\">\n          <DropdownMenuItem\n            className=\"rounded-lg\"\n            onClick={() => setSettingsOpen(true)}\n          >\n            <IconSettings className=\"h-4 w-4\" />\n            Settings\n          </DropdownMenuItem>\n          <DropdownMenuItem\n            className=\"rounded-lg\"\n            render={\n              <a href=\"/chrome\" target=\"_blank\" rel=\"noopener noreferrer\" />\n            }\n          >\n            <ChromeIcon />\n            Chrome Extension\n          </DropdownMenuItem>\n          <DropdownMenuItem\n            className=\"rounded-lg\"\n            onClick={() => setSignOutOpen(true)}\n          >\n            <IconLogout className=\"h-4 w-4\" />\n            Sign out\n          </DropdownMenuItem>\n        </DropdownMenuContent>\n      </DropdownMenu>\n      <AlertDialog open={signOutOpen} onOpenChange={setSignOutOpen}>\n        <AlertDialogContent>\n          <AlertDialogHeader>\n            <AlertDialogTitle className=\"font-semibold text-xl\">\n              Sign out?\n            </AlertDialogTitle>\n            <AlertDialogDescription>\n              You will need to sign in again to access your bookmarks.\n            </AlertDialogDescription>\n          </AlertDialogHeader>\n          <AlertDialogFooter>\n            <AlertDialogCancel variant=\"ghost\">Cancel</AlertDialogCancel>\n            <AlertDialogAction variant=\"destructive\" onClick={handleSignOut}>\n              Sign out\n            </AlertDialogAction>\n          </AlertDialogFooter>\n        </AlertDialogContent>\n      </AlertDialog>\n      <SettingsDialog\n        open={settingsOpen}\n        onOpenChange={setSettingsOpen}\n        user={{ name: userName, email: userEmail }}\n        onExport={onExport}\n      />\n    </header>\n  );\n}\n\nfunction BmrksLogo() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"24\"\n      height=\"24\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      aria-label=\"Logo\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12.432 17.949c.863 1.544 2.589 1.976 4.13 1.112c1.54 -.865 1.972 -2.594 1.048 -4.138c-.185 -.309 -.309 -.556 -.494 -.74c.247 .06 .555 .06 .925 .06c1.726 0 2.959 -1.234 2.959 -2.963c0 -1.73 -1.233 -2.965 -3.02 -2.965c-.37 0 -.617 0 -.925 .062c.185 -.185 .308 -.432 .493 -.74c.863 -1.545 .431 -3.274 -1.048 -4.138c-1.541 -.865 -3.205 -.433 -4.13 1.111c-.185 .309 -.308 .556 -.432 .803c-.123 -.247 -.246 -.494 -.431 -.803c-.802 -1.605 -2.528 -2.038 -4.007 -1.173c-1.541 .865 -1.973 2.594 -1.048 4.137c.185 .31 .308 .556 .493 .741c-.246 -.061 -.555 -.061 -.924 -.061c-1.788 0 -3.021 1.235 -3.021 2.964c0 1.729 1.233 2.964 3.02 2.964\" />\n      <path d=\"M4.073 21c4.286 -2.756 5.9 -5.254 7.927 -9\" />\n    </svg>\n  );\n}\n\nfunction UserAvatar({ name }: { name: string }) {\n  return (\n    <svg viewBox=\"0 0 32 32\" fill=\"none\" width=\"24\" height=\"24\">\n      <rect width=\"32\" height=\"32\" rx=\"16\" fill=\"#74B06F\" />\n      <text\n        x=\"50%\"\n        y=\"50%\"\n        dominantBaseline=\"central\"\n        textAnchor=\"middle\"\n        fill=\"white\"\n        fontSize=\"14\"\n        fontWeight=\"500\"\n      >\n        {name.charAt(0).toUpperCase()}\n      </text>\n    </svg>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"a05b0e74-5be9-49a2-a7df-4f27f7d06a73"}
{"parentUuid":"21cd9fdf-c550-42bf-8b44-4ab9c7fe49d4","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011iE2Hd8S54bXwhcXNhZnzh","type":"tool_result","content":"\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport dynamic from \"next/dynamic\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  IconSelector,\n  IconPlus,\n  IconCheck,\n  IconTrash,\n  IconSettings,\n  IconLogout,\n  IconWorld,\n  IconWorldOff,\n  IconUser,\n  IconLoader2,\n} from \"@tabler/icons-react\";\nimport { signOut } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\n\nconst SettingsDialog = dynamic(\n  () => import(\"@/components/settings-dialog\").then((m) => m.SettingsDialog),\n  { ssr: false },\n);\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  onToggleGroupVisibility?: (id: string, isPublic: boolean) => void;\n  isTogglingGroupVisibility?: boolean;\n  userName: string;\n  userEmail: string;\n  userImage?: string | null;\n  username?: string | null;\n  profile?: ProfileData;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}\n\nexport function Header({\n  groups,\n  selectedGroup,\n  onSelectGroup,\n  onCreateGroup,\n  onDeleteGroup,\n  onToggleGroupVisibility,\n  isTogglingGroupVisibility,\n  userName,\n  userEmail,\n  userImage,\n  username,\n  profile,\n  readOnly = false,\n  showUserMenu = true,\n  logoSize = 24,\n}: HeaderProps) {\n  const router = useRouter();\n  const [newGroupName, setNewGroupName] = useState(\"\");\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [signOutOpen, setSignOutOpen] = useState(false);\n  const [visibilityDialogOpen, setVisibilityDialogOpen] = useState(false);\n  const [pendingVisibilityGroupId, setPendingVisibilityGroupId] = useState<\n    string | null\n  >(null);\n  const [pendingVisibilityTarget, setPendingVisibilityTarget] = useState<\n    boolean | null\n  >(null);\n  const [holdingGroupId, setHoldingGroupId] = useState<string | null>(null);\n  const [holdProgress, setHoldProgress] = useState(0);\n  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const holdStartRef = useRef<number>(0);\n  const initiatedToggleRef = useRef(false);\n\n  useEffect(() => {\n    if (!isTogglingGroupVisibility && initiatedToggleRef.current) {\n      initiatedToggleRef.current = false;\n      const timer = setTimeout(() => {\n        setVisibilityDialogOpen(false);\n        setPendingVisibilityGroupId(null);\n        setPendingVisibilityTarget(null);\n      }, 0);\n      return () => clearTimeout(timer);\n    }\n  }, [isTogglingGroupVisibility]);\n\n  const handleSignOut = async () => {\n    setSignOutOpen(false);\n    await signOut();\n    router.push(\"/login\");\n  };\n\n  const handleCreateGroup = () => {\n    if (newGroupName.trim()) {\n      onCreateGroup(newGroupName.trim());\n      setNewGroupName(\"\");\n      setDialogOpen(false);\n    }\n  };\n\n  const cancelHold = useCallback(() => {\n    if (holdTimerRef.current) {\n      clearTimeout(holdTimerRef.current);\n    }\n    setHoldingGroupId(null);\n    setHoldProgress(0);\n  }, []);\n\n  const startHold = useCallback(\n    (groupId: string) => {\n      if (readOnly) return;\n      if (groups.length <= 1) return;\n      setHoldingGroupId(groupId);\n      holdStartRef.current = Date.now();\n\n      const updateProgress = () => {\n        const elapsed = Date.now() - holdStartRef.current;\n        const progress = Math.min((elapsed / 2000) * 100, 100);\n        setHoldProgress(progress);\n\n        if (progress >= 100) {\n          onDeleteGroup?.(groupId);\n          cancelHold();\n        } else {\n          holdTimerRef.current = setTimeout(updateProgress, 16);\n        }\n      };\n\n      holdTimerRef.current = setTimeout(updateProgress, 16);\n    },\n    [groups.length, onDeleteGroup, cancelHold, readOnly],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (holdTimerRef.current) {\n        clearTimeout(holdTimerRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <header\n      className={cn(\n        \"flex items-center justify-between\",\n        readOnly ? \"px-4 py-2\" : \"px-6 py-3\",\n      )}\n    >\n      <div className=\"flex items-center gap-2\">\n        <BmrksLogo size={logoSize} />\n        <span className=\"text-muted-foreground\">/</span>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            className=\"rounded-xl\"\n            render={<Button variant=\"ghost\" className=\"gap-2 px-2\" />}\n          >\n            <span\n              className=\"h-2.5 w-2.5 rounded-full\"\n              style={{ backgroundColor: selectedGroup.color }}\n            />\n            <span>{selectedGroup.name}</span>\n            <IconSelector className=\"h-4 w-4 text-muted-foreground\" />\n          </DropdownMenuTrigger>\n          <DropdownMenuContent\n            align=\"start\"\n            className=\"w-48 space-y-1 rounded-xl\"\n          >\n            {groups.map((group) => (\n              <DropdownMenuItem\n                key={group.id}\n                onClick={() => onSelectGroup(group.id)}\n                className={cn(\n                  \"flex items-start justify-between rounded-lg px-2 py-1.5\",\n                  group.id === selectedGroup.id && \"bg-accent\",\n                )}\n              >\n                <div className=\"flex items-start gap-2\">\n                  <span\n                    className=\"mt-[5px] h-2.5 w-2.5 shrink-0 rounded-full\"\n                    style={{ backgroundColor: group.color }}\n                  />\n                  <span>{group.name}</span>\n                  {group.isPublic && (\n                    <IconWorld className=\"mt-1 h-3 w-3 shrink-0 text-muted-foreground\" />\n                  )}\n                </div>\n                {group.id === selectedGroup.id ? (\n                  <IconCheck className=\"mt-0.5 h-4 w-4 shrink-0\" />\n                ) : (\n                  <span className=\"mt-0.5 shrink-0 text-xs text-muted-foreground\">\n                    {group.bookmarkCount ?? 0}\n                  </span>\n                )}\n              </DropdownMenuItem>\n            ))}\n            <DropdownMenuItem\n              onClick={() => {\n                if (!readOnly) setDialogOpen(true);\n              }}\n              disabled={readOnly}\n              className=\"rounded-lg w-full px-2 py-1.5\"\n            >\n              <IconPlus className=\"h-4 w-4 mr-0\" />\n              Create Group\n            </DropdownMenuItem>\n            {!readOnly && onToggleGroupVisibility && (\n              <DropdownMenuItem\n                onClick={() => {\n                  setPendingVisibilityGroupId(selectedGroup.id);\n                  setPendingVisibilityTarget(!selectedGroup.isPublic);\n                  setVisibilityDialogOpen(true);\n                }}\n                className=\"rounded-lg px-2 py-1.5\"\n              >\n                {selectedGroup.isPublic ? (\n                  <>\n                    <IconWorldOff className=\"h-4 w-4\" />\n                    Make Private\n                  </>\n                ) : (\n                  <>\n                    <IconWorld className=\"h-4 w-4\" />\n                    Make Public\n                  </>\n                )}\n              </DropdownMenuItem>\n            )}\n            {!readOnly && groups.length > 1 && (\n              <DropdownMenuItem\n                onSelect={(e) => e.preventDefault()}\n                onMouseDown={() => startHold(selectedGroup.id)}\n                onMouseUp={cancelHold}\n                onMouseLeave={cancelHold}\n                onTouchStart={() => startHold(selectedGroup.id)}\n                onTouchEnd={cancelHold}\n                className=\"relative overflow-hidden text-destructive focus:text-destructive rounded-lg px-2 py-1.5\"\n              >\n                {holdingGroupId === selectedGroup.id && (\n                  <div\n                    className=\"absolute inset-0 bg-destructive/20 origin-left\"\n                    style={{ transform: `scaleX(${holdProgress / 100})` }}\n                  />\n                )}\n                <span className=\"relative z-10 flex items-center gap-2\">\n                  <IconTrash className=\"h-4 w-4 text-destructive\" />\n                  {holdingGroupId === selectedGroup.id\n                    ? \"Hold to delete...\"\n                    : \"Delete Group\"}\n                </span>\n              </DropdownMenuItem>\n            )}\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n          <DialogContent className=\"sm:max-w-sm\" showCloseButton={false}>\n            <Form\n              className=\"contents\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleCreateGroup();\n              }}\n            >\n              <DialogHeader>\n                <DialogTitle>Create Group</DialogTitle>\n                <DialogDescription>\n                  Create a new group to organize your bookmarks.\n                </DialogDescription>\n              </DialogHeader>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  placeholder=\"Enter group name\"\n                  value={newGroupName}\n                  onChange={(e) => setNewGroupName(e.target.value)}\n                  autoFocus\n                />\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button type=\"submit\" disabled={!newGroupName.trim()}>\n                  Create\n                </Button>\n              </DialogFooter>\n            </Form>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      {showUserMenu ? (\n        <>\n          <DropdownMenu>\n            <DropdownMenuTrigger\n              className=\"rounded-xl\"\n              render={\n                <Button\n                  variant=\"ghost\"\n                  className=\"w-44 justify-start gap-2 px-2 border-0\"\n                />\n              }\n            >\n              <UserAvatar name={userName} image={userImage} />\n              <span className=\"truncate\">{userName}</span>\n              <IconSelector className=\"ml-auto h-4 w-4 shrink-0 text-muted-foreground\" />\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\" className=\"rounded-2xl\">\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSettingsOpen(true)}\n                disabled={readOnly}\n              >\n                <IconSettings className=\"h-4 w-4\" />\n                Settings\n              </DropdownMenuItem>\n              {username && (\n                <DropdownMenuItem\n                  className=\"rounded-lg\"\n                  render={\n                    <a\n                      href={`/u/${username}`}\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                    />\n                  }\n                >\n                  <IconUser className=\"h-4 w-4\" />\n                  Public Profile\n                </DropdownMenuItem>\n              )}\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                render={\n                  <a href=\"/chrome\" target=\"_blank\" rel=\"noopener noreferrer\" />\n                }\n                disabled={readOnly}\n              >\n                <ChromeIcon />\n                Chrome Extension\n              </DropdownMenuItem>\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSignOutOpen(true)}\n                disabled={readOnly}\n              >\n                <IconLogout className=\"h-4 w-4\" />\n                Sign out\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n          <AlertDialog open={signOutOpen} onOpenChange={setSignOutOpen}>\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  Sign out?\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  You will need to sign in again to access your bookmarks.\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <AlertDialogCancel variant=\"ghost\">Cancel</AlertDialogCancel>\n                <AlertDialogAction\n                  variant=\"destructive\"\n                  onClick={handleSignOut}\n                >\n                  Sign out\n                </AlertDialogAction>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <AlertDialog\n            open={visibilityDialogOpen}\n            onOpenChange={(open) => {\n              if (isTogglingGroupVisibility) return;\n              setVisibilityDialogOpen(open);\n              if (!open) {\n                setPendingVisibilityGroupId(null);\n                setPendingVisibilityTarget(null);\n              }\n            }}\n          >\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  {pendingVisibilityTarget ? \"Make group public?\" : \"Make group private?\"}\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  {pendingVisibilityTarget\n                    ? \"All bookmarks in this group will become publicly visible on your profile.\"\n                    : \"All bookmarks in this group will no longer be publicly visible on your profile.\"}\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <Button\n                  variant=\"ghost\"\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    setVisibilityDialogOpen(false);\n                    setPendingVisibilityGroupId(null);\n                    setPendingVisibilityTarget(null);\n                  }}\n                >\n                  Cancel\n                </Button>\n                <Button\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    if (\n                      pendingVisibilityGroupId &&\n                      pendingVisibilityTarget !== null\n                    ) {\n                      onToggleGroupVisibility?.(\n                        pendingVisibilityGroupId,\n                        pendingVisibilityTarget,\n                      );\n                      initiatedToggleRef.current = true;\n                    }\n                  }}\n                >\n                  {isTogglingGroupVisibility && (\n                    <IconLoader2 className=\"h-4 w-4 animate-spin\" />\n                  )}\n                  {pendingVisibilityTarget ? \"Make Public\" : \"Make Private\"}\n                </Button>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <SettingsDialog\n            open={settingsOpen}\n            onOpenChange={setSettingsOpen}\n            user={{\n              name: userName,\n              email: userEmail,\n              image: userImage ?? null,\n            }}\n            profile={profile}\n          />\n        </>\n      ) : null}\n    </header>\n  );\n}\n\nfunction BmrksLogo({ size = 24 }: { size?: number }) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      aria-label=\"Logo\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12.432 17.949c.863 1.544 2.589 1.976 4.13 1.112c1.54 -.865 1.972 -2.594 1.048 -4.138c-.185 -.309 -.309 -.556 -.494 -.74c.247 .06 .555 .06 .925 .06c1.726 0 2.959 -1.234 2.959 -2.963c0 -1.73 -1.233 -2.965 -3.02 -2.965c-.37 0 -.617 0 -.925 .062c.185 -.185 .308 -.432 .493 -.74c.863 -1.545 .431 -3.274 -1.048 -4.138c-1.541 -.865 -3.205 -.433 -4.13 1.111c-.185 .309 -.308 .556 -.432 .803c-.123 -.247 -.246 -.494 -.431 -.803c-.802 -1.605 -2.528 -2.038 -4.007 -1.173c-1.541 .865 -1.973 2.594 -1.048 4.137c.185 .31 .308 .556 .493 .741c-.246 -.061 -.555 -.061 -.924 -.061c-1.788 0 -3.021 1.235 -3.021 2.964c0 1.729 1.233 2.964 3.02 2.964\" />\n      <path d=\"M4.073 21c4.286 -2.756 5.9 -5.254 7.927 -9\" />\n    </svg>\n  );\n}\n\nfunction UserAvatar({ name, image }: { name: string; image?: string | null }) {\n  if (image) {\n    return (\n      // eslint-disable-next-line @next/next/no-img-element\n      <img\n        src={image}\n        alt={name}\n        className=\"size-4.5 shrink-0 rounded-full object-cover\"\n      />\n    );\n  }\n\n  return (\n    <svg viewBox=\"0 0 32 32\" fill=\"none\" width=\"18\" height=\"18\">\n      <rect width=\"32\" height=\"32\" rx=\"16\" fill=\"#74B06F\" />\n      <text\n        x=\"50%\"\n        y=\"50%\"\n        dominantBaseline=\"central\"\n        textAnchor=\"middle\"\n        fill=\"white\"\n        fontSize=\"14\"\n        fontWeight=\"500\"\n      >\n        {name.charAt(0).toUpperCase()}\n      </text>\n    </svg>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","is_error":false}]},"uuid":"d10d2878-2554-4df8-b945-ca37f4f7ed39","timestamp":"2026-02-10T17:49:07.188Z","toolUseResult":{"stdout":"\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport dynamic from \"next/dynamic\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  IconSelector,\n  IconPlus,\n  IconCheck,\n  IconTrash,\n  IconSettings,\n  IconLogout,\n  IconWorld,\n  IconWorldOff,\n  IconUser,\n  IconLoader2,\n} from \"@tabler/icons-react\";\nimport { signOut } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\n\nconst SettingsDialog = dynamic(\n  () => import(\"@/components/settings-dialog\").then((m) => m.SettingsDialog),\n  { ssr: false },\n);\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  onToggleGroupVisibility?: (id: string, isPublic: boolean) => void;\n  isTogglingGroupVisibility?: boolean;\n  userName: string;\n  userEmail: string;\n  userImage?: string | null;\n  username?: string | null;\n  profile?: ProfileData;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}\n\nexport function Header({\n  groups,\n  selectedGroup,\n  onSelectGroup,\n  onCreateGroup,\n  onDeleteGroup,\n  onToggleGroupVisibility,\n  isTogglingGroupVisibility,\n  userName,\n  userEmail,\n  userImage,\n  username,\n  profile,\n  readOnly = false,\n  showUserMenu = true,\n  logoSize = 24,\n}: HeaderProps) {\n  const router = useRouter();\n  const [newGroupName, setNewGroupName] = useState(\"\");\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [signOutOpen, setSignOutOpen] = useState(false);\n  const [visibilityDialogOpen, setVisibilityDialogOpen] = useState(false);\n  const [pendingVisibilityGroupId, setPendingVisibilityGroupId] = useState<\n    string | null\n  >(null);\n  const [pendingVisibilityTarget, setPendingVisibilityTarget] = useState<\n    boolean | null\n  >(null);\n  const [holdingGroupId, setHoldingGroupId] = useState<string | null>(null);\n  const [holdProgress, setHoldProgress] = useState(0);\n  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const holdStartRef = useRef<number>(0);\n  const initiatedToggleRef = useRef(false);\n\n  useEffect(() => {\n    if (!isTogglingGroupVisibility && initiatedToggleRef.current) {\n      initiatedToggleRef.current = false;\n      const timer = setTimeout(() => {\n        setVisibilityDialogOpen(false);\n        setPendingVisibilityGroupId(null);\n        setPendingVisibilityTarget(null);\n      }, 0);\n      return () => clearTimeout(timer);\n    }\n  }, [isTogglingGroupVisibility]);\n\n  const handleSignOut = async () => {\n    setSignOutOpen(false);\n    await signOut();\n    router.push(\"/login\");\n  };\n\n  const handleCreateGroup = () => {\n    if (newGroupName.trim()) {\n      onCreateGroup(newGroupName.trim());\n      setNewGroupName(\"\");\n      setDialogOpen(false);\n    }\n  };\n\n  const cancelHold = useCallback(() => {\n    if (holdTimerRef.current) {\n      clearTimeout(holdTimerRef.current);\n    }\n    setHoldingGroupId(null);\n    setHoldProgress(0);\n  }, []);\n\n  const startHold = useCallback(\n    (groupId: string) => {\n      if (readOnly) return;\n      if (groups.length <= 1) return;\n      setHoldingGroupId(groupId);\n      holdStartRef.current = Date.now();\n\n      const updateProgress = () => {\n        const elapsed = Date.now() - holdStartRef.current;\n        const progress = Math.min((elapsed / 2000) * 100, 100);\n        setHoldProgress(progress);\n\n        if (progress >= 100) {\n          onDeleteGroup?.(groupId);\n          cancelHold();\n        } else {\n          holdTimerRef.current = setTimeout(updateProgress, 16);\n        }\n      };\n\n      holdTimerRef.current = setTimeout(updateProgress, 16);\n    },\n    [groups.length, onDeleteGroup, cancelHold, readOnly],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (holdTimerRef.current) {\n        clearTimeout(holdTimerRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <header\n      className={cn(\n        \"flex items-center justify-between\",\n        readOnly ? \"px-4 py-2\" : \"px-6 py-3\",\n      )}\n    >\n      <div className=\"flex items-center gap-2\">\n        <BmrksLogo size={logoSize} />\n        <span className=\"text-muted-foreground\">/</span>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            className=\"rounded-xl\"\n            render={<Button variant=\"ghost\" className=\"gap-2 px-2\" />}\n          >\n            <span\n              className=\"h-2.5 w-2.5 rounded-full\"\n              style={{ backgroundColor: selectedGroup.color }}\n            />\n            <span>{selectedGroup.name}</span>\n            <IconSelector className=\"h-4 w-4 text-muted-foreground\" />\n          </DropdownMenuTrigger>\n          <DropdownMenuContent\n            align=\"start\"\n            className=\"w-48 space-y-1 rounded-xl\"\n          >\n            {groups.map((group) => (\n              <DropdownMenuItem\n                key={group.id}\n                onClick={() => onSelectGroup(group.id)}\n                className={cn(\n                  \"flex items-start justify-between rounded-lg px-2 py-1.5\",\n                  group.id === selectedGroup.id && \"bg-accent\",\n                )}\n              >\n                <div className=\"flex items-start gap-2\">\n                  <span\n                    className=\"mt-[5px] h-2.5 w-2.5 shrink-0 rounded-full\"\n                    style={{ backgroundColor: group.color }}\n                  />\n                  <span>{group.name}</span>\n                  {group.isPublic && (\n                    <IconWorld className=\"mt-1 h-3 w-3 shrink-0 text-muted-foreground\" />\n                  )}\n                </div>\n                {group.id === selectedGroup.id ? (\n                  <IconCheck className=\"mt-0.5 h-4 w-4 shrink-0\" />\n                ) : (\n                  <span className=\"mt-0.5 shrink-0 text-xs text-muted-foreground\">\n                    {group.bookmarkCount ?? 0}\n                  </span>\n                )}\n              </DropdownMenuItem>\n            ))}\n            <DropdownMenuItem\n              onClick={() => {\n                if (!readOnly) setDialogOpen(true);\n              }}\n              disabled={readOnly}\n              className=\"rounded-lg w-full px-2 py-1.5\"\n            >\n              <IconPlus className=\"h-4 w-4 mr-0\" />\n              Create Group\n            </DropdownMenuItem>\n            {!readOnly && onToggleGroupVisibility && (\n              <DropdownMenuItem\n                onClick={() => {\n                  setPendingVisibilityGroupId(selectedGroup.id);\n                  setPendingVisibilityTarget(!selectedGroup.isPublic);\n                  setVisibilityDialogOpen(true);\n                }}\n                className=\"rounded-lg px-2 py-1.5\"\n              >\n                {selectedGroup.isPublic ? (\n                  <>\n                    <IconWorldOff className=\"h-4 w-4\" />\n                    Make Private\n                  </>\n                ) : (\n                  <>\n                    <IconWorld className=\"h-4 w-4\" />\n                    Make Public\n                  </>\n                )}\n              </DropdownMenuItem>\n            )}\n            {!readOnly && groups.length > 1 && (\n              <DropdownMenuItem\n                onSelect={(e) => e.preventDefault()}\n                onMouseDown={() => startHold(selectedGroup.id)}\n                onMouseUp={cancelHold}\n                onMouseLeave={cancelHold}\n                onTouchStart={() => startHold(selectedGroup.id)}\n                onTouchEnd={cancelHold}\n                className=\"relative overflow-hidden text-destructive focus:text-destructive rounded-lg px-2 py-1.5\"\n              >\n                {holdingGroupId === selectedGroup.id && (\n                  <div\n                    className=\"absolute inset-0 bg-destructive/20 origin-left\"\n                    style={{ transform: `scaleX(${holdProgress / 100})` }}\n                  />\n                )}\n                <span className=\"relative z-10 flex items-center gap-2\">\n                  <IconTrash className=\"h-4 w-4 text-destructive\" />\n                  {holdingGroupId === selectedGroup.id\n                    ? \"Hold to delete...\"\n                    : \"Delete Group\"}\n                </span>\n              </DropdownMenuItem>\n            )}\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n          <DialogContent className=\"sm:max-w-sm\" showCloseButton={false}>\n            <Form\n              className=\"contents\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleCreateGroup();\n              }}\n            >\n              <DialogHeader>\n                <DialogTitle>Create Group</DialogTitle>\n                <DialogDescription>\n                  Create a new group to organize your bookmarks.\n                </DialogDescription>\n              </DialogHeader>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  placeholder=\"Enter group name\"\n                  value={newGroupName}\n                  onChange={(e) => setNewGroupName(e.target.value)}\n                  autoFocus\n                />\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button type=\"submit\" disabled={!newGroupName.trim()}>\n                  Create\n                </Button>\n              </DialogFooter>\n            </Form>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      {showUserMenu ? (\n        <>\n          <DropdownMenu>\n            <DropdownMenuTrigger\n              className=\"rounded-xl\"\n              render={\n                <Button\n                  variant=\"ghost\"\n                  className=\"w-44 justify-start gap-2 px-2 border-0\"\n                />\n              }\n            >\n              <UserAvatar name={userName} image={userImage} />\n              <span className=\"truncate\">{userName}</span>\n              <IconSelector className=\"ml-auto h-4 w-4 shrink-0 text-muted-foreground\" />\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\" className=\"rounded-2xl\">\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSettingsOpen(true)}\n                disabled={readOnly}\n              >\n                <IconSettings className=\"h-4 w-4\" />\n                Settings\n              </DropdownMenuItem>\n              {username && (\n                <DropdownMenuItem\n                  className=\"rounded-lg\"\n                  render={\n                    <a\n                      href={`/u/${username}`}\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                    />\n                  }\n                >\n                  <IconUser className=\"h-4 w-4\" />\n                  Public Profile\n                </DropdownMenuItem>\n              )}\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                render={\n                  <a href=\"/chrome\" target=\"_blank\" rel=\"noopener noreferrer\" />\n                }\n                disabled={readOnly}\n              >\n                <ChromeIcon />\n                Chrome Extension\n              </DropdownMenuItem>\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSignOutOpen(true)}\n                disabled={readOnly}\n              >\n                <IconLogout className=\"h-4 w-4\" />\n                Sign out\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n          <AlertDialog open={signOutOpen} onOpenChange={setSignOutOpen}>\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  Sign out?\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  You will need to sign in again to access your bookmarks.\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <AlertDialogCancel variant=\"ghost\">Cancel</AlertDialogCancel>\n                <AlertDialogAction\n                  variant=\"destructive\"\n                  onClick={handleSignOut}\n                >\n                  Sign out\n                </AlertDialogAction>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <AlertDialog\n            open={visibilityDialogOpen}\n            onOpenChange={(open) => {\n              if (isTogglingGroupVisibility) return;\n              setVisibilityDialogOpen(open);\n              if (!open) {\n                setPendingVisibilityGroupId(null);\n                setPendingVisibilityTarget(null);\n              }\n            }}\n          >\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  {pendingVisibilityTarget ? \"Make group public?\" : \"Make group private?\"}\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  {pendingVisibilityTarget\n                    ? \"All bookmarks in this group will become publicly visible on your profile.\"\n                    : \"All bookmarks in this group will no longer be publicly visible on your profile.\"}\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <Button\n                  variant=\"ghost\"\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    setVisibilityDialogOpen(false);\n                    setPendingVisibilityGroupId(null);\n                    setPendingVisibilityTarget(null);\n                  }}\n                >\n                  Cancel\n                </Button>\n                <Button\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    if (\n                      pendingVisibilityGroupId &&\n                      pendingVisibilityTarget !== null\n                    ) {\n                      onToggleGroupVisibility?.(\n                        pendingVisibilityGroupId,\n                        pendingVisibilityTarget,\n                      );\n                      initiatedToggleRef.current = true;\n                    }\n                  }}\n                >\n                  {isTogglingGroupVisibility && (\n                    <IconLoader2 className=\"h-4 w-4 animate-spin\" />\n                  )}\n                  {pendingVisibilityTarget ? \"Make Public\" : \"Make Private\"}\n                </Button>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <SettingsDialog\n            open={settingsOpen}\n            onOpenChange={setSettingsOpen}\n            user={{\n              name: userName,\n              email: userEmail,\n              image: userImage ?? null,\n            }}\n            profile={profile}\n          />\n        </>\n      ) : null}\n    </header>\n  );\n}\n\nfunction BmrksLogo({ size = 24 }: { size?: number }) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      aria-label=\"Logo\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12.432 17.949c.863 1.544 2.589 1.976 4.13 1.112c1.54 -.865 1.972 -2.594 1.048 -4.138c-.185 -.309 -.309 -.556 -.494 -.74c.247 .06 .555 .06 .925 .06c1.726 0 2.959 -1.234 2.959 -2.963c0 -1.73 -1.233 -2.965 -3.02 -2.965c-.37 0 -.617 0 -.925 .062c.185 -.185 .308 -.432 .493 -.74c.863 -1.545 .431 -3.274 -1.048 -4.138c-1.541 -.865 -3.205 -.433 -4.13 1.111c-.185 .309 -.308 .556 -.432 .803c-.123 -.247 -.246 -.494 -.431 -.803c-.802 -1.605 -2.528 -2.038 -4.007 -1.173c-1.541 .865 -1.973 2.594 -1.048 4.137c.185 .31 .308 .556 .493 .741c-.246 -.061 -.555 -.061 -.924 -.061c-1.788 0 -3.021 1.235 -3.021 2.964c0 1.729 1.233 2.964 3.02 2.964\" />\n      <path d=\"M4.073 21c4.286 -2.756 5.9 -5.254 7.927 -9\" />\n    </svg>\n  );\n}\n\nfunction UserAvatar({ name, image }: { name: string; image?: string | null }) {\n  if (image) {\n    return (\n      // eslint-disable-next-line @next/next/no-img-element\n      <img\n        src={image}\n        alt={name}\n        className=\"size-4.5 shrink-0 rounded-full object-cover\"\n      />\n    );\n  }\n\n  return (\n    <svg viewBox=\"0 0 32 32\" fill=\"none\" width=\"18\" height=\"18\">\n      <rect width=\"32\" height=\"32\" rx=\"16\" fill=\"#74B06F\" />\n      <text\n        x=\"50%\"\n        y=\"50%\"\n        dominantBaseline=\"central\"\n        textAnchor=\"middle\"\n        fill=\"white\"\n        fontSize=\"14\"\n        fontWeight=\"500\"\n      >\n        {name.charAt(0).toUpperCase()}\n      </text>\n    </svg>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"21cd9fdf-c550-42bf-8b44-4ab9c7fe49d4"}
{"parentUuid":"80ba34d1-07c3-4d3a-833b-904a6bbc4322","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NgqpXBC84cfsbD9kPd7Jim","type":"tool_result","content":"\"use client\";\n\nimport { useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { authClient } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\n\ninterface SettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  user: {\n    name: string;\n    email: string;\n  };\n  onExport?: () => void;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  onExport,\n}: SettingsDialogProps) {\n  const router = useRouter();\n  const [name, setName] = useState(user.name);\n  const [isSaving, setIsSaving] = useState(false);\n\n  const handleSaveName = async () => {\n    if (name.trim() === user.name) {\n      onOpenChange(false);\n      return;\n    }\n\n    setIsSaving(true);\n    const { error } = await authClient.updateUser({ name: name.trim() });\n    setIsSaving(false);\n\n    if (error) {\n      toast.error(\"Failed to update name\");\n      return;\n    }\n\n    toast.success(\"Name updated\");\n    onOpenChange(false);\n    router.refresh();\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-sm\">\n        <Form\n          className=\"contents\"\n          onSubmit={(e) => {\n            e.preventDefault();\n            handleSaveName();\n          }}\n        >\n          <DialogHeader>\n            <DialogTitle>Settings</DialogTitle>\n            <DialogDescription>\n              Manage your account settings.\n            </DialogDescription>\n          </DialogHeader>\n          <Field>\n            <FieldLabel>Name</FieldLabel>\n            <Input\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              placeholder=\"Your name\"\n              type=\"text\"\n            />\n          </Field>\n          <Field>\n            <FieldLabel>Email</FieldLabel>\n            <Input\n              value={user.email}\n              disabled\n              type=\"email\"\n              className=\"text-muted-foreground\"\n            />\n          </Field>\n          <Field>\n            <FieldLabel>Chrome Extension</FieldLabel>\n            <a\n              href=\"/chrome\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n            >\n              <ChromeIcon />\n              <span>Get the Chrome Extension</span>\n            </a>\n          </Field>\n          <Field>\n            <FieldLabel>Data</FieldLabel>\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={onExport}\n              className=\"w-fit\"\n            >\n              Export\n            </Button>\n          </Field>\n          <DialogFooter>\n            <DialogClose render={<Button variant=\"ghost\" />}>\n              Cancel\n            </DialogClose>\n            <Button type=\"submit\" disabled={isSaving || !name.trim()}>\n              {isSaving ? \"Saving...\" : \"Save\"}\n            </Button>\n          </DialogFooter>\n        </Form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"20\"\n      height=\"20\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","is_error":false}]},"uuid":"9c060efc-2a45-48c0-83ea-30e7eefeafac","timestamp":"2026-02-10T17:49:07.188Z","toolUseResult":{"stdout":"\"use client\";\n\nimport { useState } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { authClient } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\n\ninterface SettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  user: {\n    name: string;\n    email: string;\n  };\n  onExport?: () => void;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  onExport,\n}: SettingsDialogProps) {\n  const router = useRouter();\n  const [name, setName] = useState(user.name);\n  const [isSaving, setIsSaving] = useState(false);\n\n  const handleSaveName = async () => {\n    if (name.trim() === user.name) {\n      onOpenChange(false);\n      return;\n    }\n\n    setIsSaving(true);\n    const { error } = await authClient.updateUser({ name: name.trim() });\n    setIsSaving(false);\n\n    if (error) {\n      toast.error(\"Failed to update name\");\n      return;\n    }\n\n    toast.success(\"Name updated\");\n    onOpenChange(false);\n    router.refresh();\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-sm\">\n        <Form\n          className=\"contents\"\n          onSubmit={(e) => {\n            e.preventDefault();\n            handleSaveName();\n          }}\n        >\n          <DialogHeader>\n            <DialogTitle>Settings</DialogTitle>\n            <DialogDescription>\n              Manage your account settings.\n            </DialogDescription>\n          </DialogHeader>\n          <Field>\n            <FieldLabel>Name</FieldLabel>\n            <Input\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              placeholder=\"Your name\"\n              type=\"text\"\n            />\n          </Field>\n          <Field>\n            <FieldLabel>Email</FieldLabel>\n            <Input\n              value={user.email}\n              disabled\n              type=\"email\"\n              className=\"text-muted-foreground\"\n            />\n          </Field>\n          <Field>\n            <FieldLabel>Chrome Extension</FieldLabel>\n            <a\n              href=\"/chrome\"\n              target=\"_blank\"\n              rel=\"noopener noreferrer\"\n              className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n            >\n              <ChromeIcon />\n              <span>Get the Chrome Extension</span>\n            </a>\n          </Field>\n          <Field>\n            <FieldLabel>Data</FieldLabel>\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={onExport}\n              className=\"w-fit\"\n            >\n              Export\n            </Button>\n          </Field>\n          <DialogFooter>\n            <DialogClose render={<Button variant=\"ghost\" />}>\n              Cancel\n            </DialogClose>\n            <Button type=\"submit\" disabled={isSaving || !name.trim()}>\n              {isSaving ? \"Saving...\" : \"Save\"}\n            </Button>\n          </DialogFooter>\n        </Form>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"20\"\n      height=\"20\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"80ba34d1-07c3-4d3a-833b-904a6bbc4322"}
{"parentUuid":"2905b987-c613-49e0-b4ae-10df6e2d5371","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Lpmdy6hvQthUPrczLAdU16","type":"tool_result","content":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}","is_error":false}]},"uuid":"5eefa938-7bbf-4842-aa36-c935acb2dc81","timestamp":"2026-02-10T17:49:07.189Z","toolUseResult":{"stdout":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"2905b987-c613-49e0-b4ae-10df6e2d5371"}
{"parentUuid":"222c7b5e-6722-44f5-8dcc-a095da87b1a3","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012fZYUoP9UwFoKSv3sjmCxe","type":"tool_result","content":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onExport: (format: \"csv\" | \"json\") => void;\n  onDelete: () => void;\n  onClose: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onExport,\n  onDelete,\n  onClose,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50 motion-reduce:transition-none motion-reduce:animate-none\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            render={\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n              />\n            }\n          >\n            <IconFileExport className=\"h-4 w-4\" />\n            Export\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"center\" className=\"w-40\">\n            <DropdownMenuItem onClick={() => onExport(\"csv\")} className=\"whitespace-nowrap\">\n              <IconFileTypeCsv className=\"h-4 w-4\" />\n              Export as CSV\n            </DropdownMenuItem>\n            <DropdownMenuItem onClick={() => onExport(\"json\")} className=\"whitespace-nowrap\">\n              <IconJson className=\"h-4 w-4\" />\n              Export as JSON\n            </DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}","is_error":false}]},"uuid":"6c6ebf68-ee15-4849-ba9a-380102041abf","timestamp":"2026-02-10T17:49:07.189Z","toolUseResult":{"stdout":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onExport: (format: \"csv\" | \"json\") => void;\n  onDelete: () => void;\n  onClose: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onExport,\n  onDelete,\n  onClose,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50 motion-reduce:transition-none motion-reduce:animate-none\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            render={\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n              />\n            }\n          >\n            <IconFileExport className=\"h-4 w-4\" />\n            Export\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"center\" className=\"w-40\">\n            <DropdownMenuItem onClick={() => onExport(\"csv\")} className=\"whitespace-nowrap\">\n              <IconFileTypeCsv className=\"h-4 w-4\" />\n              Export as CSV\n            </DropdownMenuItem>\n            <DropdownMenuItem onClick={() => onExport(\"json\")} className=\"whitespace-nowrap\">\n              <IconJson className=\"h-4 w-4\" />\n              Export as JSON\n            </DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"222c7b5e-6722-44f5-8dcc-a095da87b1a3"}
{"parentUuid":"32209db4-6e05-4023-9be2-0cf47dadb0ea","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AVbiqVueHA8vnJyaw9tMcf","type":"tool_result","content":"\"use client\";\n\nimport {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  type ChangeEvent,\n} from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { authClient } from \"@/lib/auth-client\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { Avatar, AvatarImage, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n  IconCheck,\n  IconX,\n  IconLoader2,\n  IconCopy,\n  IconExternalLink,\n} from \"@tabler/icons-react\";\nimport { ImagePlusIcon } from \"lucide-react\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { usernameSchema, updateProfileSchema } from \"@/lib/schema\";\n\nconst ACCEPTED_AVATAR_TYPES = new Set([\n  \"image/png\",\n  \"image/jpeg\",\n  \"image/webp\",\n  \"image/gif\",\n]);\n\nconst MAX_AVATAR_FILE_SIZE_BYTES = 2 * 1024 * 1024;\n\ninterface SettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  user: {\n    name: string;\n    email: string;\n    image: string | null;\n  };\n  profile?: ProfileData;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n}: SettingsDialogProps) {\n  const router = useRouter();\n  const [name, setName] = useState(user.name);\n  const [avatarUrl, setAvatarUrl] = useState<string | null>(user.image);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const initial = name.trim().charAt(0).toUpperCase() || \"?\";\n\n  useEffect(() => {\n    if (!open) return;\n    setName(user.name);\n    setAvatarUrl(user.image);\n  }, [open, user.name, user.image]);\n\n  const handleAvatarUpload = async (file: File) => {\n    if (!ACCEPTED_AVATAR_TYPES.has(file.type)) {\n      toast.error(\"Only PNG, JPEG, WebP, and GIF files are supported\");\n      return;\n    }\n\n    if (file.size > MAX_AVATAR_FILE_SIZE_BYTES) {\n      toast.error(\"Avatar must be 2MB or smaller\");\n      return;\n    }\n\n    setIsUploading(true);\n    try {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n\n      const response = await fetch(\"/api/avatar\", {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) throw await responseError(response, \"Failed to upload avatar\");\n\n      const data = (await response.json()) as { url?: string };\n      if (!data.url) throw new Error(\"Invalid upload response\");\n\n      setAvatarUrl(data.url);\n      toast.success(\"Avatar updated\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to upload avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleAvatarChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    await handleAvatarUpload(file);\n    event.target.value = \"\";\n  };\n\n  const handleAvatarRemove = async () => {\n    setIsUploading(true);\n    try {\n      const response = await fetch(\"/api/avatar\", { method: \"DELETE\" });\n\n      if (!response.ok) throw await responseError(response, \"Failed to remove avatar\");\n\n      setAvatarUrl(null);\n      toast.success(\"Avatar removed\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to remove avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleSaveName = async () => {\n    if (name.trim() === user.name) {\n      onOpenChange(false);\n      return;\n    }\n\n    setIsSaving(true);\n    const { error } = await authClient.updateUser({ name: name.trim() });\n    setIsSaving(false);\n\n    if (error) {\n      toast.error(\"Failed to update name\");\n      return;\n    }\n\n    toast.success(\"Name updated\");\n    onOpenChange(false);\n    router.refresh();\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md\" showCloseButton={false}>\n        <DialogHeader>\n          <DialogTitle>Settings</DialogTitle>\n          <DialogDescription>Manage your account settings.</DialogDescription>\n        </DialogHeader>\n        <Tabs defaultValue=\"general\">\n          <TabsList>\n            <TabsTrigger value=\"general\">General</TabsTrigger>\n            <TabsTrigger value=\"profile\">Public Profile</TabsTrigger>\n          </TabsList>\n          <TabsContent value=\"general\">\n            <Form\n              className=\"space-y-4 pt-2\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleSaveName();\n              }}\n            >\n              <Field>\n                <FieldLabel>Profile Picture</FieldLabel>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"group relative\">\n                    <Avatar\n                      size=\"lg\"\n                      className=\"overflow-hidden *:data-[slot=avatar-image]:transition-[filter] *:data-[slot=avatar-fallback]:transition-[filter] sm:group-hover:*:data-[slot=avatar-image]:blur-sm sm:group-hover:*:data-[slot=avatar-fallback]:blur-sm\"\n                    >\n                      <AvatarImage\n                        src={avatarUrl ?? undefined}\n                        alt={name || user.name}\n                      />\n                      <AvatarFallback>{initial}</AvatarFallback>\n                    </Avatar>\n                    <button\n                      type=\"button\"\n                      disabled={isUploading}\n                      className=\"absolute inset-0 flex items-center justify-center rounded-full bg-black/45 hover:bg-black/55 text-white opacity-100 transition-opacity sm:opacity-0 sm:group-hover:opacity-100 disabled:opacity-100 cursor-pointer outline-none\"\n                      onClick={\n                        avatarUrl\n                          ? handleAvatarRemove\n                          : () => fileInputRef.current?.click()\n                      }\n                    >\n                      <AvatarOverlayIcon\n                        isUploading={isUploading}\n                        hasAvatar={!!avatarUrl}\n                      />\n                    </button>\n                  </div>\n                  <p className=\"text-xs text-muted-foreground\">\n                    Upload a photo\n                  </p>\n                  <input\n                    ref={fileInputRef}\n                    type=\"file\"\n                    className=\"hidden\"\n                    accept=\"image/png,image/jpeg,image/webp,image/gif\"\n                    onChange={handleAvatarChange}\n                  />\n                </div>\n              </Field>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  value={name}\n                  onChange={(e) => setName(e.target.value)}\n                  placeholder=\"duncan\"\n                  type=\"text\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Email</FieldLabel>\n                <Input\n                  value={user.email}\n                  disabled\n                  type=\"email\"\n                  className=\"text-muted-foreground\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Chrome Extension</FieldLabel>\n                <a\n                  href=\"/chrome\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n                >\n                  <ChromeIcon />\n                  <span>Get the Chrome Extension</span>\n                </a>\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >\n                  {isSaving ? \"Saving...\" : \"Save\"}\n                </Button>\n              </DialogFooter>\n            </Form>\n          </TabsContent>\n          <TabsContent value=\"profile\">\n            {profile && <ProfileTab profile={profile} onOpenChange={onOpenChange} />}\n          </TabsContent>\n        </Tabs>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\ninterface ProfileTabProps {\n  profile: ProfileData;\n  onOpenChange: (open: boolean) => void;\n}\n\nfunction ProfileTab({ profile, onOpenChange }: ProfileTabProps) {\n  const router = useRouter();\n\n  const [username, setUsername] = useState(profile.username ?? \"\");\n  const [bio, setBio] = useState(profile.bio ?? \"\");\n  const [github, setGithub] = useState(profile.github ?? \"\");\n  const [twitter, setTwitter] = useState(profile.twitter ?? \"\");\n  const [website, setWebsite] = useState(\n    profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\",\n  );\n  const [isProfilePublic, setIsProfilePublic] = useState(\n    profile.isProfilePublic,\n  );\n  const [dirtyFields, setDirtyFields] = useState<Set<string>>(new Set());\n  const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({});\n\n  const markDirty = (field: string) => {\n    setDirtyFields((prev) => new Set(prev).add(field));\n    setFieldErrors((prev) => {\n      const next = { ...prev };\n      delete next[field];\n      return next;\n    });\n  };\n\n  const debouncedUsername = useDebounce(username, 400);\n  const usernameParseResult = usernameSchema.safeParse(debouncedUsername);\n  const isUsernameValid =\n    debouncedUsername.length > 0 && usernameParseResult.success;\n\n  const availabilityQuery = useQuery({\n    ...orpc.profile.checkUsername.queryOptions({\n      input: { username: debouncedUsername },\n    }),\n    enabled: isUsernameValid,\n    staleTime: 10_000,\n  });\n\n  const usernameStatus = getStatus(\n    username,\n    debouncedUsername,\n    usernameParseResult,\n    availabilityQuery,\n  );\n\n  const updateMutation = useMutation({\n    mutationFn: (data: Parameters<typeof client.profile.update>[0]) =>\n      client.profile.update(data),\n    onSuccess: () => {\n      toast.success(\"Profile updated\");\n      onOpenChange(false);\n      router.refresh();\n    },\n    onError: (err) => {\n      toast.error(err.message || \"Failed to update profile\");\n    },\n  });\n\n  const handleSubmit = () => {\n    if (username && usernameStatus !== \"available\") return;\n\n    const originalWebsite = profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\";\n    const hasChanges =\n      username !== (profile.username ?? \"\") ||\n      bio !== (profile.bio ?? \"\") ||\n      github !== (profile.github ?? \"\") ||\n      twitter !== (profile.twitter ?? \"\") ||\n      website !== originalWebsite ||\n      isProfilePublic !== profile.isProfilePublic;\n\n    if (!hasChanges) {\n      onOpenChange(false);\n      return;\n    }\n\n    const payload = {\n      username: username || null,\n      bio: bio || null,\n      github: github || null,\n      twitter: twitter || null,\n      website: website || null,\n      isProfilePublic,\n    };\n\n    const result = updateProfileSchema.safeParse(payload);\n\n    if (!result.success) {\n      const errors: Record<string, string> = {};\n      for (const issue of result.error.issues) {\n        const field = issue.path[0]?.toString();\n        if (field && !errors[field]) {\n          errors[field] = issue.message;\n        }\n      }\n      setFieldErrors(errors);\n      return;\n    }\n\n    setFieldErrors({});\n    updateMutation.mutate(result.data);\n  };\n\n  const handleCopyLink = useCallback(() => {\n    if (username) {\n      navigator.clipboard.writeText(`${window.location.origin}/u/${username}`);\n      toast.success(\"Link copied\");\n    }\n  }, [username]);\n\n  return (\n    <Form\n      className=\"space-y-4 pt-2\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        handleSubmit();\n      }}\n    >\n      <Field>\n        <div className=\"flex items-center justify-between\">\n          <FieldLabel>Public Profile</FieldLabel>\n          <Switch\n            checked={isProfilePublic}\n            onCheckedChange={setIsProfilePublic}\n            size=\"sm\"\n          />\n        </div>\n      </Field>\n      <Field>\n        <FieldLabel>Username</FieldLabel>\n        <div className=\"relative\">\n          <Input\n            value={username}\n            onChange={(e) => {\n              markDirty(\"username\");\n              const newValue = e.target.value\n                .toLowerCase()\n                .replace(/[^a-z0-9-]/g, \"\");\n              if (newValue && !username && !isProfilePublic) {\n                setIsProfilePublic(true);\n              }\n              setUsername(newValue);\n            }}\n            placeholder=\"duncan\"\n            type=\"text\"\n            className=\"pr-8\"\n          />\n          <div className=\"absolute right-2 top-1/2 -translate-y-1/2\">\n            <UsernameStatusIcon status={usernameStatus} />\n          </div>\n        </div>\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"invalid\" && (\n            <p className=\"text-xs text-destructive mt-1\">\n              {usernameParseResult.error?.issues[0]?.message}\n            </p>\n          )}\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"taken\" && (\n            <p className=\"text-xs text-destructive mt-1\">Username is taken</p>\n          )}\n      </Field>\n      <Field>\n        <FieldLabel>Bio</FieldLabel>\n        <Textarea\n          value={bio}\n          onChange={(e) => {\n            markDirty(\"bio\");\n            setBio(e.target.value);\n          }}\n          placeholder=\"Building cool things on the web\"\n          rows={2}\n          maxLength={160}\n          className=\"resize-none\"\n        />\n        {fieldErrors.bio && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.bio}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>GitHub</FieldLabel>\n        <Input\n          value={github}\n          onChange={(e) => {\n            markDirty(\"github\");\n            setGithub(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.github && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.github}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>X (Twitter)</FieldLabel>\n        <Input\n          value={twitter}\n          onChange={(e) => {\n            markDirty(\"twitter\");\n            setTwitter(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.twitter && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.twitter}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>Website</FieldLabel>\n        <div className=\"flex\">\n          <span className=\"inline-flex items-center rounded-l-md border border-r-0 border-input bg-muted px-2 text-sm text-muted-foreground\">\n            https://\n          </span>\n          <Input\n            value={website}\n            onChange={(e) => {\n              markDirty(\"website\");\n              setWebsite(e.target.value.replace(/^https?:\\/\\//, \"\"));\n            }}\n            placeholder=\"ephraimduncan.com\"\n            type=\"text\"\n            className=\"rounded-l-none px-2\"\n          />\n        </div>\n        {fieldErrors.website && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.website}</p>\n        )}\n      </Field>\n      {username && usernameStatus === \"available\" && (\n        <div className=\"flex items-center gap-2\">\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={handleCopyLink}\n          >\n            <IconCopy className=\"h-3.5 w-3.5\" />\n            Copy Profile Link\n          </Button>\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={() => window.open(`/u/${username}`, \"_blank\")}\n          >\n            <IconExternalLink className=\"h-3.5 w-3.5\" />\n            Preview Profile\n          </Button>\n        </div>\n      )}\n      <DialogFooter>\n        <DialogClose render={<Button variant=\"ghost\" />}>Cancel</DialogClose>\n        <Button\n          type=\"submit\"\n          disabled={\n            updateMutation.isPending ||\n            (!!username && usernameStatus !== \"available\")\n          }\n        >\n          {updateMutation.isPending ? \"Saving...\" : \"Save\"}\n        </Button>\n      </DialogFooter>\n    </Form>\n  );\n}\n\nasync function responseError(\n  response: Response,\n  fallback: string,\n): Promise<Error> {\n  const data = (await response.json().catch(() => null)) as {\n    message?: string;\n  } | null;\n  return new Error(data?.message ?? fallback);\n}\n\nfunction AvatarOverlayIcon({\n  isUploading,\n  hasAvatar,\n}: {\n  isUploading: boolean;\n  hasAvatar: boolean;\n}) {\n  if (isUploading) return <IconLoader2 className=\"size-4 animate-spin\" />;\n  if (hasAvatar) return <IconX className=\"size-4\" />;\n  return <ImagePlusIcon className=\"size-4\" />;\n}\n\ntype UsernameStatus = \"idle\" | \"checking\" | \"available\" | \"taken\" | \"invalid\";\n\nfunction getStatus(\n  username: string,\n  debouncedUsername: string,\n  parseResult: ReturnType<typeof usernameSchema.safeParse>,\n  availabilityQuery: { isPending: boolean; data?: unknown },\n): UsernameStatus {\n  if (!username) return \"idle\";\n  if (!parseResult.success) return \"invalid\";\n  if (username !== debouncedUsername) return \"checking\";\n  if (availabilityQuery.isPending) return \"checking\";\n  const data = availabilityQuery.data as { available?: boolean } | undefined;\n  if (data?.available) return \"available\";\n  return \"taken\";\n}\n\nfunction UsernameStatusIcon({ status }: { status: UsernameStatus }) {\n  switch (status) {\n    case \"checking\":\n      return (\n        <IconLoader2 className=\"h-4 w-4 animate-spin text-muted-foreground\" />\n      );\n    case \"available\":\n      return <IconCheck className=\"h-4 w-4 text-green-600\" />;\n    case \"taken\":\n      return <IconX className=\"h-4 w-4 text-destructive\" />;\n    default:\n      return null;\n  }\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"20\"\n      height=\"20\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","is_error":false}]},"uuid":"70c57ddf-fb22-4a7a-8b3e-8426d192901c","timestamp":"2026-02-10T17:49:07.203Z","toolUseResult":{"stdout":"\"use client\";\n\nimport {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  type ChangeEvent,\n} from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { authClient } from \"@/lib/auth-client\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { Avatar, AvatarImage, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n  IconCheck,\n  IconX,\n  IconLoader2,\n  IconCopy,\n  IconExternalLink,\n} from \"@tabler/icons-react\";\nimport { ImagePlusIcon } from \"lucide-react\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { usernameSchema, updateProfileSchema } from \"@/lib/schema\";\n\nconst ACCEPTED_AVATAR_TYPES = new Set([\n  \"image/png\",\n  \"image/jpeg\",\n  \"image/webp\",\n  \"image/gif\",\n]);\n\nconst MAX_AVATAR_FILE_SIZE_BYTES = 2 * 1024 * 1024;\n\ninterface SettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  user: {\n    name: string;\n    email: string;\n    image: string | null;\n  };\n  profile?: ProfileData;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n}: SettingsDialogProps) {\n  const router = useRouter();\n  const [name, setName] = useState(user.name);\n  const [avatarUrl, setAvatarUrl] = useState<string | null>(user.image);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const initial = name.trim().charAt(0).toUpperCase() || \"?\";\n\n  useEffect(() => {\n    if (!open) return;\n    setName(user.name);\n    setAvatarUrl(user.image);\n  }, [open, user.name, user.image]);\n\n  const handleAvatarUpload = async (file: File) => {\n    if (!ACCEPTED_AVATAR_TYPES.has(file.type)) {\n      toast.error(\"Only PNG, JPEG, WebP, and GIF files are supported\");\n      return;\n    }\n\n    if (file.size > MAX_AVATAR_FILE_SIZE_BYTES) {\n      toast.error(\"Avatar must be 2MB or smaller\");\n      return;\n    }\n\n    setIsUploading(true);\n    try {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n\n      const response = await fetch(\"/api/avatar\", {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) throw await responseError(response, \"Failed to upload avatar\");\n\n      const data = (await response.json()) as { url?: string };\n      if (!data.url) throw new Error(\"Invalid upload response\");\n\n      setAvatarUrl(data.url);\n      toast.success(\"Avatar updated\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to upload avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleAvatarChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    await handleAvatarUpload(file);\n    event.target.value = \"\";\n  };\n\n  const handleAvatarRemove = async () => {\n    setIsUploading(true);\n    try {\n      const response = await fetch(\"/api/avatar\", { method: \"DELETE\" });\n\n      if (!response.ok) throw await responseError(response, \"Failed to remove avatar\");\n\n      setAvatarUrl(null);\n      toast.success(\"Avatar removed\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to remove avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleSaveName = async () => {\n    if (name.trim() === user.name) {\n      onOpenChange(false);\n      return;\n    }\n\n    setIsSaving(true);\n    const { error } = await authClient.updateUser({ name: name.trim() });\n    setIsSaving(false);\n\n    if (error) {\n      toast.error(\"Failed to update name\");\n      return;\n    }\n\n    toast.success(\"Name updated\");\n    onOpenChange(false);\n    router.refresh();\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md\" showCloseButton={false}>\n        <DialogHeader>\n          <DialogTitle>Settings</DialogTitle>\n          <DialogDescription>Manage your account settings.</DialogDescription>\n        </DialogHeader>\n        <Tabs defaultValue=\"general\">\n          <TabsList>\n            <TabsTrigger value=\"general\">General</TabsTrigger>\n            <TabsTrigger value=\"profile\">Public Profile</TabsTrigger>\n          </TabsList>\n          <TabsContent value=\"general\">\n            <Form\n              className=\"space-y-4 pt-2\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleSaveName();\n              }}\n            >\n              <Field>\n                <FieldLabel>Profile Picture</FieldLabel>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"group relative\">\n                    <Avatar\n                      size=\"lg\"\n                      className=\"overflow-hidden *:data-[slot=avatar-image]:transition-[filter] *:data-[slot=avatar-fallback]:transition-[filter] sm:group-hover:*:data-[slot=avatar-image]:blur-sm sm:group-hover:*:data-[slot=avatar-fallback]:blur-sm\"\n                    >\n                      <AvatarImage\n                        src={avatarUrl ?? undefined}\n                        alt={name || user.name}\n                      />\n                      <AvatarFallback>{initial}</AvatarFallback>\n                    </Avatar>\n                    <button\n                      type=\"button\"\n                      disabled={isUploading}\n                      className=\"absolute inset-0 flex items-center justify-center rounded-full bg-black/45 hover:bg-black/55 text-white opacity-100 transition-opacity sm:opacity-0 sm:group-hover:opacity-100 disabled:opacity-100 cursor-pointer outline-none\"\n                      onClick={\n                        avatarUrl\n                          ? handleAvatarRemove\n                          : () => fileInputRef.current?.click()\n                      }\n                    >\n                      <AvatarOverlayIcon\n                        isUploading={isUploading}\n                        hasAvatar={!!avatarUrl}\n                      />\n                    </button>\n                  </div>\n                  <p className=\"text-xs text-muted-foreground\">\n                    Upload a photo\n                  </p>\n                  <input\n                    ref={fileInputRef}\n                    type=\"file\"\n                    className=\"hidden\"\n                    accept=\"image/png,image/jpeg,image/webp,image/gif\"\n                    onChange={handleAvatarChange}\n                  />\n                </div>\n              </Field>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  value={name}\n                  onChange={(e) => setName(e.target.value)}\n                  placeholder=\"duncan\"\n                  type=\"text\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Email</FieldLabel>\n                <Input\n                  value={user.email}\n                  disabled\n                  type=\"email\"\n                  className=\"text-muted-foreground\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Chrome Extension</FieldLabel>\n                <a\n                  href=\"/chrome\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n                >\n                  <ChromeIcon />\n                  <span>Get the Chrome Extension</span>\n                </a>\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >\n                  {isSaving ? \"Saving...\" : \"Save\"}\n                </Button>\n              </DialogFooter>\n            </Form>\n          </TabsContent>\n          <TabsContent value=\"profile\">\n            {profile && <ProfileTab profile={profile} onOpenChange={onOpenChange} />}\n          </TabsContent>\n        </Tabs>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\ninterface ProfileTabProps {\n  profile: ProfileData;\n  onOpenChange: (open: boolean) => void;\n}\n\nfunction ProfileTab({ profile, onOpenChange }: ProfileTabProps) {\n  const router = useRouter();\n\n  const [username, setUsername] = useState(profile.username ?? \"\");\n  const [bio, setBio] = useState(profile.bio ?? \"\");\n  const [github, setGithub] = useState(profile.github ?? \"\");\n  const [twitter, setTwitter] = useState(profile.twitter ?? \"\");\n  const [website, setWebsite] = useState(\n    profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\",\n  );\n  const [isProfilePublic, setIsProfilePublic] = useState(\n    profile.isProfilePublic,\n  );\n  const [dirtyFields, setDirtyFields] = useState<Set<string>>(new Set());\n  const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({});\n\n  const markDirty = (field: string) => {\n    setDirtyFields((prev) => new Set(prev).add(field));\n    setFieldErrors((prev) => {\n      const next = { ...prev };\n      delete next[field];\n      return next;\n    });\n  };\n\n  const debouncedUsername = useDebounce(username, 400);\n  const usernameParseResult = usernameSchema.safeParse(debouncedUsername);\n  const isUsernameValid =\n    debouncedUsername.length > 0 && usernameParseResult.success;\n\n  const availabilityQuery = useQuery({\n    ...orpc.profile.checkUsername.queryOptions({\n      input: { username: debouncedUsername },\n    }),\n    enabled: isUsernameValid,\n    staleTime: 10_000,\n  });\n\n  const usernameStatus = getStatus(\n    username,\n    debouncedUsername,\n    usernameParseResult,\n    availabilityQuery,\n  );\n\n  const updateMutation = useMutation({\n    mutationFn: (data: Parameters<typeof client.profile.update>[0]) =>\n      client.profile.update(data),\n    onSuccess: () => {\n      toast.success(\"Profile updated\");\n      onOpenChange(false);\n      router.refresh();\n    },\n    onError: (err) => {\n      toast.error(err.message || \"Failed to update profile\");\n    },\n  });\n\n  const handleSubmit = () => {\n    if (username && usernameStatus !== \"available\") return;\n\n    const originalWebsite = profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\";\n    const hasChanges =\n      username !== (profile.username ?? \"\") ||\n      bio !== (profile.bio ?? \"\") ||\n      github !== (profile.github ?? \"\") ||\n      twitter !== (profile.twitter ?? \"\") ||\n      website !== originalWebsite ||\n      isProfilePublic !== profile.isProfilePublic;\n\n    if (!hasChanges) {\n      onOpenChange(false);\n      return;\n    }\n\n    const payload = {\n      username: username || null,\n      bio: bio || null,\n      github: github || null,\n      twitter: twitter || null,\n      website: website || null,\n      isProfilePublic,\n    };\n\n    const result = updateProfileSchema.safeParse(payload);\n\n    if (!result.success) {\n      const errors: Record<string, string> = {};\n      for (const issue of result.error.issues) {\n        const field = issue.path[0]?.toString();\n        if (field && !errors[field]) {\n          errors[field] = issue.message;\n        }\n      }\n      setFieldErrors(errors);\n      return;\n    }\n\n    setFieldErrors({});\n    updateMutation.mutate(result.data);\n  };\n\n  const handleCopyLink = useCallback(() => {\n    if (username) {\n      navigator.clipboard.writeText(`${window.location.origin}/u/${username}`);\n      toast.success(\"Link copied\");\n    }\n  }, [username]);\n\n  return (\n    <Form\n      className=\"space-y-4 pt-2\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        handleSubmit();\n      }}\n    >\n      <Field>\n        <div className=\"flex items-center justify-between\">\n          <FieldLabel>Public Profile</FieldLabel>\n          <Switch\n            checked={isProfilePublic}\n            onCheckedChange={setIsProfilePublic}\n            size=\"sm\"\n          />\n        </div>\n      </Field>\n      <Field>\n        <FieldLabel>Username</FieldLabel>\n        <div className=\"relative\">\n          <Input\n            value={username}\n            onChange={(e) => {\n              markDirty(\"username\");\n              const newValue = e.target.value\n                .toLowerCase()\n                .replace(/[^a-z0-9-]/g, \"\");\n              if (newValue && !username && !isProfilePublic) {\n                setIsProfilePublic(true);\n              }\n              setUsername(newValue);\n            }}\n            placeholder=\"duncan\"\n            type=\"text\"\n            className=\"pr-8\"\n          />\n          <div className=\"absolute right-2 top-1/2 -translate-y-1/2\">\n            <UsernameStatusIcon status={usernameStatus} />\n          </div>\n        </div>\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"invalid\" && (\n            <p className=\"text-xs text-destructive mt-1\">\n              {usernameParseResult.error?.issues[0]?.message}\n            </p>\n          )}\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"taken\" && (\n            <p className=\"text-xs text-destructive mt-1\">Username is taken</p>\n          )}\n      </Field>\n      <Field>\n        <FieldLabel>Bio</FieldLabel>\n        <Textarea\n          value={bio}\n          onChange={(e) => {\n            markDirty(\"bio\");\n            setBio(e.target.value);\n          }}\n          placeholder=\"Building cool things on the web\"\n          rows={2}\n          maxLength={160}\n          className=\"resize-none\"\n        />\n        {fieldErrors.bio && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.bio}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>GitHub</FieldLabel>\n        <Input\n          value={github}\n          onChange={(e) => {\n            markDirty(\"github\");\n            setGithub(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.github && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.github}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>X (Twitter)</FieldLabel>\n        <Input\n          value={twitter}\n          onChange={(e) => {\n            markDirty(\"twitter\");\n            setTwitter(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.twitter && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.twitter}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>Website</FieldLabel>\n        <div className=\"flex\">\n          <span className=\"inline-flex items-center rounded-l-md border border-r-0 border-input bg-muted px-2 text-sm text-muted-foreground\">\n            https://\n          </span>\n          <Input\n            value={website}\n            onChange={(e) => {\n              markDirty(\"website\");\n              setWebsite(e.target.value.replace(/^https?:\\/\\//, \"\"));\n            }}\n            placeholder=\"ephraimduncan.com\"\n            type=\"text\"\n            className=\"rounded-l-none px-2\"\n          />\n        </div>\n        {fieldErrors.website && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.website}</p>\n        )}\n      </Field>\n      {username && usernameStatus === \"available\" && (\n        <div className=\"flex items-center gap-2\">\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={handleCopyLink}\n          >\n            <IconCopy className=\"h-3.5 w-3.5\" />\n            Copy Profile Link\n          </Button>\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={() => window.open(`/u/${username}`, \"_blank\")}\n          >\n            <IconExternalLink className=\"h-3.5 w-3.5\" />\n            Preview Profile\n          </Button>\n        </div>\n      )}\n      <DialogFooter>\n        <DialogClose render={<Button variant=\"ghost\" />}>Cancel</DialogClose>\n        <Button\n          type=\"submit\"\n          disabled={\n            updateMutation.isPending ||\n            (!!username && usernameStatus !== \"available\")\n          }\n        >\n          {updateMutation.isPending ? \"Saving...\" : \"Save\"}\n        </Button>\n      </DialogFooter>\n    </Form>\n  );\n}\n\nasync function responseError(\n  response: Response,\n  fallback: string,\n): Promise<Error> {\n  const data = (await response.json().catch(() => null)) as {\n    message?: string;\n  } | null;\n  return new Error(data?.message ?? fallback);\n}\n\nfunction AvatarOverlayIcon({\n  isUploading,\n  hasAvatar,\n}: {\n  isUploading: boolean;\n  hasAvatar: boolean;\n}) {\n  if (isUploading) return <IconLoader2 className=\"size-4 animate-spin\" />;\n  if (hasAvatar) return <IconX className=\"size-4\" />;\n  return <ImagePlusIcon className=\"size-4\" />;\n}\n\ntype UsernameStatus = \"idle\" | \"checking\" | \"available\" | \"taken\" | \"invalid\";\n\nfunction getStatus(\n  username: string,\n  debouncedUsername: string,\n  parseResult: ReturnType<typeof usernameSchema.safeParse>,\n  availabilityQuery: { isPending: boolean; data?: unknown },\n): UsernameStatus {\n  if (!username) return \"idle\";\n  if (!parseResult.success) return \"invalid\";\n  if (username !== debouncedUsername) return \"checking\";\n  if (availabilityQuery.isPending) return \"checking\";\n  const data = availabilityQuery.data as { available?: boolean } | undefined;\n  if (data?.available) return \"available\";\n  return \"taken\";\n}\n\nfunction UsernameStatusIcon({ status }: { status: UsernameStatus }) {\n  switch (status) {\n    case \"checking\":\n      return (\n        <IconLoader2 className=\"h-4 w-4 animate-spin text-muted-foreground\" />\n      );\n    case \"available\":\n      return <IconCheck className=\"h-4 w-4 text-green-600\" />;\n    case \"taken\":\n      return <IconX className=\"h-4 w-4 text-destructive\" />;\n    default:\n      return null;\n  }\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"20\"\n      height=\"20\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"32209db4-6e05-4023-9be2-0cf47dadb0ea"}
{"parentUuid":"8a29451e-9087-4238-a19e-86f831b3983f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bi1dQbKGdSnYRtshPtXNGU","type":"tool_result","content":"     1→\"use client\";\n     2→\n     3→import { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\n     4→import { useQueryState } from \"nuqs\";\n     5→import { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\n     6→import { toast } from \"sonner\";\n     7→import dynamic from \"next/dynamic\";\n     8→import { Header } from \"@/components/header\";\n     9→import { BookmarkInput } from \"@/components/bookmark-input\";\n    10→import { BookmarkList } from \"@/components/bookmark-list\";\n    11→import { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n    12→\n    13→const MultiSelectToolbar = dynamic(\n    14→  () =>\n    15→    import(\"@/components/multi-select-toolbar\").then(\n    16→      (m) => m.MultiSelectToolbar,\n    17→    ),\n    18→  { ssr: false },\n    19→);\n    20→const BulkMoveDialog = dynamic(\n    21→  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n    22→  { ssr: false },\n    23→);\n    24→const BulkDeleteDialog = dynamic(\n    25→  () =>\n    26→    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n    27→  { ssr: false },\n    28→);\n    29→import { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\n    30→import { client, orpc } from \"@/lib/orpc\";\n    31→import { useDebounce } from \"@/hooks/use-debounce\";\n    32→import { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\n    33→import { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\n    34→import type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\n    35→import type { Session } from \"@/lib/auth\";\n    36→\n    37→export interface ProfileData {\n    38→  image: string | null;\n    39→  username: string | null;\n    40→  bio: string | null;\n    41→  github: string | null;\n    42→  twitter: string | null;\n    43→  website: string | null;\n    44→  isProfilePublic: boolean;\n    45→}\n    46→\n    47→interface DashboardContentProps {\n    48→  session: NonNullable<Session>;\n    49→  initialGroups: GroupItem[];\n    50→  initialBookmarks: BookmarkItem[];\n    51→  profile: ProfileData;\n    52→}\n    53→\n    54→const groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\n    55→const bookmarkListKey = (groupId?: string | null) =>\n    56→  orpc.bookmark.list.queryKey({\n    57→    input: { groupId: groupId ?? undefined },\n    58→  }) as readonly unknown[];\n    59→\n    60→export function DashboardContent({\n    61→  session,\n    62→  initialGroups,\n    63→  initialBookmarks,\n    64→  profile,\n    65→}: DashboardContentProps) {\n    66→  const queryClient = useQueryClient();\n    67→\n    68→  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n    69→  const [searchQuery, setSearchQuery] = useState(\"\");\n    70→  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n    71→  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n    72→  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n    73→  const inputRef = useRef<HTMLInputElement>(null);\n    74→  const [renamingId, setRenamingId] = useState<string | null>(null);\n    75→  const [selectionMode, setSelectionMode] = useState(false);\n    76→  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n    77→  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n    78→  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n    79→\n    80→  const groupsQuery = useQuery({\n    81→    ...orpc.group.list.queryOptions(),\n    82→    initialData: initialGroups,\n    83→    initialDataUpdatedAt: Date.now(),\n    84→  });\n    85→\n    86→  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n    87→\n    88→  const hasUsername = profile.username !== null;\n    89→  const publicGroupIds = useMemo(\n    90→    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    91→    [groups],\n    92→  );\n    93→\n    94→  useFocusRefetch(groups);\n    95→\n    96→  const groupIdBySlug = useMemo(\n    97→    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    98→    [groups],\n    99→  );\n   100→  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n   101→\n   102→  const selectedGroupId = groupSlug\n   103→    ? (groupIdBySlug.get(groupSlug) ?? null)\n   104→    : null;\n   105→\n   106→  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n   107→\n   108→  const bookmarksQuery = useQuery({\n   109→    ...orpc.bookmark.list.queryOptions({\n   110→      input: { groupId: currentGroupId ?? undefined },\n   111→    }),\n   112→    initialData:\n   113→      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n   114→    initialDataUpdatedAt: Date.now(),\n   115→    enabled: !!currentGroupId,\n   116→  });\n   117→\n   118→  const bookmarks = useMemo(\n   119→    () => bookmarksQuery.data ?? [],\n   120→    [bookmarksQuery.data],\n   121→  );\n   122→\n   123→  useEffect(() => {\n   124→    setSelectedIndex(-1);\n   125→    setHoveredIndex(-1);\n   126→  }, [bookmarks, currentGroupId]);\n   127→\n   128→  const createBookmarkMutation = useMutation({\n   129→    ...orpc.bookmark.create.mutationOptions(),\n   130→    onMutate: async (newBookmark) => {\n   131→      await queryClient.cancelQueries({\n   132→        queryKey: orpc.bookmark.list.queryKey({\n   133→          input: { groupId: newBookmark.groupId },\n   134→        }),\n   135→      });\n   136→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   137→\n   138→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   139→        bookmarkListKey(newBookmark.groupId),\n   140→      );\n   141→      const previousGroups =\n   142→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   143→\n   144→      const optimisticBookmark: BookmarkItem = {\n   145→        id: `temp-${Date.now()}`,\n   146→        title: newBookmark.title,\n   147→        url: newBookmark.url || null,\n   148→        favicon: null,\n   149→        type: newBookmark.type ?? \"link\",\n   150→        color: newBookmark.color || null,\n   151→        groupId: newBookmark.groupId,\n   152→        createdAt: new Date().toISOString(),\n   153→      };\n   154→\n   155→      queryClient.setQueryData<BookmarkItem[]>(\n   156→        bookmarkListKey(newBookmark.groupId),\n   157→        (old) => [optimisticBookmark, ...(old || [])],\n   158→      );\n   159→\n   160→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   161→        old?.map((g) =>\n   162→          g.id === newBookmark.groupId\n   163→            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n   164→            : g,\n   165→        ),\n   166→      );\n   167→\n   168→      return {\n   169→        previousBookmarks,\n   170→        previousGroups,\n   171→        groupId: newBookmark.groupId,\n   172→      };\n   173→    },\n   174→    onError: (_err, _newBookmark, context) => {\n   175→      if (context?.previousBookmarks) {\n   176→        queryClient.setQueryData<BookmarkItem[]>(\n   177→          bookmarkListKey(context.groupId),\n   178→          context.previousBookmarks,\n   179→        );\n   180→      }\n   181→      if (context?.previousGroups) {\n   182→        queryClient.setQueryData<GroupItem[]>(\n   183→          groupListKey(),\n   184→          context.previousGroups,\n   185→        );\n   186→      }\n   187→      toast.error(\"Failed to create bookmark\");\n   188→    },\n   189→    onSettled: (_data, _error, variables) => {\n   190→      queryClient.invalidateQueries({\n   191→        queryKey: orpc.bookmark.list.key({\n   192→          input: { groupId: variables.groupId },\n   193→        }),\n   194→      });\n   195→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   196→    },\n   197→  });\n   198→\n   199→  const updateBookmarkMutation = useMutation({\n   200→    mutationFn: async (data: {\n   201→      id: string;\n   202→      title?: string;\n   203→      url?: string;\n   204→      type?: BookmarkType;\n   205→      color?: string;\n   206→      groupId?: string;\n   207→      _sourceGroupId?: string;\n   208→    }) => {\n   209→      if (data.id.startsWith(\"temp-\")) {\n   210→        return { id: data.id, title: data.title ?? \"\" } as Pick<\n   211→          BookmarkItem,\n   212→          \"id\" | \"title\"\n   213→        >;\n   214→      }\n   215→      const { _sourceGroupId, ...updateData } = data;\n   216→      return client.bookmark.update(updateData);\n   217→    },\n   218→    onMutate: async (data) => {\n   219→      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n   220→      const isMove =\n   221→        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n   222→      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n   223→\n   224→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   225→      await queryClient.cancelQueries({\n   226→        queryKey: orpc.bookmark.list.queryKey({\n   227→          input: { groupId: sourceGroupId ?? undefined },\n   228→        }),\n   229→      });\n   230→      if (isMove) {\n   231→        await queryClient.cancelQueries({\n   232→          queryKey: orpc.bookmark.list.queryKey({\n   233→            input: { groupId: targetGroupId },\n   234→          }),\n   235→        });\n   236→      }\n   237→\n   238→      const previousGroups =\n   239→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   240→\n   241→      if (isMove) {\n   242→        const previousSourceBookmarks = queryClient.getQueryData<\n   243→          BookmarkItem[]\n   244→        >(bookmarkListKey(_sourceGroupId));\n   245→        const previousTargetBookmarks = queryClient.getQueryData<\n   246→          BookmarkItem[]\n   247→        >(bookmarkListKey(targetGroupId));\n   248→\n   249→        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n   250→\n   251→        if (movedBookmark) {\n   252→          queryClient.setQueryData<BookmarkItem[]>(\n   253→            bookmarkListKey(_sourceGroupId),\n   254→            (old) => old?.filter((b) => b.id !== id) ?? [],\n   255→          );\n   256→\n   257→          queryClient.setQueryData<BookmarkItem[]>(\n   258→            bookmarkListKey(targetGroupId),\n   259→            (old) => [\n   260→              { ...movedBookmark, groupId: targetGroupId },\n   261→              ...(old ?? []),\n   262→            ],\n   263→          );\n   264→\n   265→          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   266→            old?.map((g) => {\n   267→              if (g.id === _sourceGroupId) {\n   268→                return {\n   269→                  ...g,\n   270→                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n   271→                };\n   272→              }\n   273→              if (g.id === targetGroupId) {\n   274→                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n   275→              }\n   276→              return g;\n   277→            }),\n   278→          );\n   279→        }\n   280→\n   281→        return {\n   282→          previousSourceBookmarks,\n   283→          previousTargetBookmarks,\n   284→          previousGroups,\n   285→          sourceGroupId: _sourceGroupId,\n   286→          targetGroupId,\n   287→        };\n   288→      }\n   289→\n   290→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   291→        bookmarkListKey(sourceGroupId),\n   292→      );\n   293→\n   294→      queryClient.setQueryData<BookmarkItem[]>(\n   295→        bookmarkListKey(sourceGroupId),\n   296→        (old) =>\n   297→          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n   298→      );\n   299→\n   300→      return { previousBookmarks, sourceGroupId, previousGroups };\n   301→    },\n   302→    onError: (_err, data, context) => {\n   303→      if (\n   304→        context?.previousSourceBookmarks !== undefined &&\n   305→        context?.sourceGroupId\n   306→      ) {\n   307→        queryClient.setQueryData<BookmarkItem[]>(\n   308→          bookmarkListKey(context.sourceGroupId),\n   309→          context.previousSourceBookmarks,\n   310→        );\n   311→      }\n   312→      if (\n   313→        context?.previousTargetBookmarks !== undefined &&\n   314→        context?.targetGroupId\n   315→      ) {\n   316→        queryClient.setQueryData<BookmarkItem[]>(\n   317→          bookmarkListKey(context.targetGroupId),\n   318→          context.previousTargetBookmarks,\n   319→        );\n   320→      }\n   321→      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n   322→        queryClient.setQueryData<BookmarkItem[]>(\n   323→          bookmarkListKey(context.sourceGroupId),\n   324→          context.previousBookmarks,\n   325→        );\n   326→      }\n   327→      if (context?.previousGroups) {\n   328→        queryClient.setQueryData<GroupItem[]>(\n   329→          groupListKey(),\n   330→          context.previousGroups,\n   331→        );\n   332→      }\n   333→      toast.error(\"Failed to update bookmark\");\n   334→    },\n   335→    onSettled: (_data, _error, data, context) => {\n   336→      if (context?.sourceGroupId) {\n   337→        queryClient.invalidateQueries({\n   338→          queryKey: orpc.bookmark.list.key({\n   339→            input: { groupId: context.sourceGroupId },\n   340→          }),\n   341→        });\n   342→      }\n   343→      if (context?.targetGroupId) {\n   344→        queryClient.invalidateQueries({\n   345→          queryKey: orpc.bookmark.list.key({\n   346→            input: { groupId: context.targetGroupId },\n   347→          }),\n   348→        });\n   349→      }\n   350→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   351→    },\n   352→  });\n   353→\n   354→  const createGroupMutation = useMutation({\n   355→    mutationFn: (data: {\n   356→      name: string;\n   357→      color: string;\n   358→      _optimisticId?: string;\n   359→    }) => {\n   360→      const { _optimisticId, ...createData } = data;\n   361→      return client.group.create(createData);\n   362→    },\n   363→    onMutate: async (newGroup) => {\n   364→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   365→\n   366→      const previousGroups =\n   367→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   368→      const previousGroupSlug = groupSlug;\n   369→\n   370→      const optimisticGroup: GroupItem = {\n   371→        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n   372→        name: newGroup.name,\n   373→        color: newGroup.color,\n   374→        bookmarkCount: 0,\n   375→      };\n   376→\n   377→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n   378→        ...(old ?? []),\n   379→        optimisticGroup,\n   380→      ]);\n   381→\n   382→      setGroupSlug(slugify(newGroup.name));\n   383→      setSelectedIndex(-1);\n   384→\n   385→      return {\n   386→        previousGroups,\n   387→        previousGroupSlug,\n   388→        optimisticId: optimisticGroup.id,\n   389→      };\n   390→    },\n   391→    onError: (_err, _newGroup, context) => {\n   392→      if (context?.previousGroups) {\n   393→        queryClient.setQueryData<GroupItem[]>(\n   394→          groupListKey(),\n   395→          context.previousGroups,\n   396→        );\n   397→      }\n   398→      if (context?.previousGroupSlug !== undefined) {\n   399→        setGroupSlug(context.previousGroupSlug);\n   400→      }\n   401→      toast.error(\"Failed to create group\");\n   402→    },\n   403→    onSettled: () => {\n   404→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   405→    },\n   406→  });\n   407→\n   408→  const deleteGroupMutation = useMutation({\n   409→    ...orpc.group.delete.mutationOptions(),\n   410→    onMutate: async (data) => {\n   411→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   412→\n   413→      const previousGroups =\n   414→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   415→      const previousGroupSlug = groupSlug;\n   416→\n   417→      queryClient.setQueryData<GroupItem[]>(\n   418→        groupListKey(),\n   419→        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n   420→      );\n   421→\n   422→      if (currentGroupId === data.id) {\n   423→        const remainingGroups =\n   424→          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n   425→        setGroupSlug(\n   426→          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n   427→        );\n   428→        setSelectedIndex(-1);\n   429→      }\n   430→\n   431→      return { previousGroups, previousGroupSlug, deletedId: data.id };\n   432→    },\n   433→    onError: (_err, _data, context) => {\n   434→      if (context?.previousGroups) {\n   435→        queryClient.setQueryData<GroupItem[]>(\n   436→          groupListKey(),\n   437→          context.previousGroups,\n   438→        );\n   439→      }\n   440→      if (context?.previousGroupSlug !== undefined) {\n   441→        setGroupSlug(context.previousGroupSlug);\n   442→      }\n   443→      toast.error(\"Failed to delete group\");\n   444→    },\n   445→    onSettled: () => {\n   446→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   447→    },\n   448→  });\n   449→\n   450→  const refetchBookmarkMutation = useMutation({\n   451→    mutationFn: (data: { id: string; groupId?: string }) =>\n   452→      client.bookmark.refetch({ id: data.id }),\n   453→    onSuccess: (_data, variables) => {\n   454→      queryClient.invalidateQueries({\n   455→        queryKey: orpc.bookmark.list.key({\n   456→          input: { groupId: variables.groupId },\n   457→        }),\n   458→      });\n   459→      toast.success(\"Metadata refreshed\");\n   460→    },\n   461→    onError: () => {\n   462→      toast.error(\"Failed to refresh metadata\");\n   463→    },\n   464→  });\n   465→\n   466→  const bulkDeleteMutation = useMutation({\n   467→    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n   468→      const { _groupId, ...deleteData } = data;\n   469→      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n   470→      if (realIds.length === 0) {\n   471→        return { success: true };\n   472→      }\n   473→      return client.bookmark.bulkDelete({ ids: realIds });\n   474→    },\n   475→    onMutate: async (data) => {\n   476→      const groupId = data._groupId ?? currentGroupId;\n   477→\n   478→      await queryClient.cancelQueries({\n   479→        queryKey: orpc.bookmark.list.queryKey({\n   480→          input: { groupId: groupId ?? undefined },\n   481→        }),\n   482→      });\n   483→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   484→\n   485→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   486→        bookmarkListKey(groupId),\n   487→      );\n   488→      const previousGroups =\n   489→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   490→\n   491→      queryClient.setQueryData<BookmarkItem[]>(\n   492→        bookmarkListKey(groupId),\n   493→        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n   494→      );\n   495→\n   496→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   497→        old?.map((g) =>\n   498→          g.id === groupId\n   499→            ? {\n   500→                ...g,\n   501→                bookmarkCount: Math.max(\n   502→                  0,\n   503→                  (g.bookmarkCount ?? 0) - data.ids.length,\n   504→                ),\n   505→              }\n   506→            : g,\n   507→        ),\n   508→      );\n   509→\n   510→      return { previousBookmarks, previousGroups, groupId };\n   511→    },\n   512→    onError: (_err, _data, context) => {\n   513→      if (context?.previousBookmarks) {\n   514→        queryClient.setQueryData<BookmarkItem[]>(\n   515→          bookmarkListKey(context.groupId),\n   516→          context.previousBookmarks,\n   517→        );\n   518→      }\n   519→      if (context?.previousGroups) {\n   520→        queryClient.setQueryData<GroupItem[]>(\n   521→          groupListKey(),\n   522→          context.previousGroups,\n   523→        );\n   524→      }\n   525→      toast.error(\"Failed to delete bookmarks\");\n   526→    },\n   527→    onSettled: (_data, _error, _variables, context) => {\n   528→      if (context?.groupId) {\n   529→        queryClient.invalidateQueries({\n   530→          queryKey: orpc.bookmark.list.key({\n   531→            input: { groupId: context.groupId },\n   532→          }),\n   533→        });\n   534→      }\n   535→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   536→    },\n   537→  });\n   538→\n   539→  const bulkMoveMutation = useMutation({\n   540→    mutationFn: (data: {\n   541→      ids: string[];\n   542→      targetGroupId: string;\n   543→      _sourceGroupId?: string;\n   544→    }) => {\n   545→      const { _sourceGroupId, ...moveData } = data;\n   546→      return client.bookmark.bulkMove(moveData);\n   547→    },\n   548→    onMutate: async (data) => {\n   549→      const { ids, targetGroupId, _sourceGroupId } = data;\n   550→      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n   551→\n   552→      await queryClient.cancelQueries({\n   553→        queryKey: orpc.bookmark.list.queryKey({\n   554→          input: { groupId: sourceGroupId ?? undefined },\n   555→        }),\n   556→      });\n   557→      await queryClient.cancelQueries({\n   558→        queryKey: orpc.bookmark.list.queryKey({\n   559→          input: { groupId: targetGroupId },\n   560→        }),\n   561→      });\n   562→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   563→\n   564→      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   565→        bookmarkListKey(sourceGroupId),\n   566→      );\n   567→      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   568→        bookmarkListKey(targetGroupId),\n   569→      );\n   570→      const previousGroups =\n   571→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   572→\n   573→      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n   574→        ids.includes(b.id),\n   575→      );\n   576→\n   577→      if (movedBookmarks) {\n   578→        queryClient.setQueryData<BookmarkItem[]>(\n   579→          bookmarkListKey(sourceGroupId),\n   580→          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n   581→        );\n   582→\n   583→        queryClient.setQueryData<BookmarkItem[]>(\n   584→          bookmarkListKey(targetGroupId),\n   585→          (old) => [\n   586→            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n   587→            ...(old ?? []),\n   588→          ],\n   589→        );\n   590→\n   591→        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   592→          old?.map((g) => {\n   593→            if (g.id === sourceGroupId) {\n   594→              return {\n   595→                ...g,\n   596→                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n   597→              };\n   598→            }\n   599→            if (g.id === targetGroupId) {\n   600→              return {\n   601→                ...g,\n   602→                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n   603→              };\n   604→            }\n   605→            return g;\n   606→          }),\n   607→        );\n   608→      }\n   609→\n   610→      return {\n   611→        previousSourceBookmarks,\n   612→        previousTargetBookmarks,\n   613→        previousGroups,\n   614→        sourceGroupId,\n   615→        targetGroupId,\n   616→      };\n   617→    },\n   618→    onError: (_err, _data, context) => {\n   619→      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n   620→        queryClient.setQueryData<BookmarkItem[]>(\n   621→          bookmarkListKey(context.sourceGroupId),\n   622→          context.previousSourceBookmarks,\n   623→        );\n   624→      }\n   625→      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n   626→        queryClient.setQueryData<BookmarkItem[]>(\n   627→          bookmarkListKey(context.targetGroupId),\n   628→          context.previousTargetBookmarks,\n   629→        );\n   630→      }\n   631→      if (context?.previousGroups) {\n   632→        queryClient.setQueryData<GroupItem[]>(\n   633→          groupListKey(),\n   634→          context.previousGroups,\n   635→        );\n   636→      }\n   637→      toast.error(\"Failed to move bookmarks\");\n   638→    },\n   639→    onSettled: (_data, _error, _variables, context) => {\n   640→      if (context?.sourceGroupId) {\n   641→        queryClient.invalidateQueries({\n   642→          queryKey: orpc.bookmark.list.key({\n   643→            input: { groupId: context.sourceGroupId },\n   644→          }),\n   645→        });\n   646→      }\n   647→      if (context?.targetGroupId) {\n   648→        queryClient.invalidateQueries({\n   649→          queryKey: orpc.bookmark.list.key({\n   650→            input: { groupId: context.targetGroupId },\n   651→          }),\n   652→        });\n   653→      }\n   654→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   655→    },\n   656→  });\n   657→\n   658→  const setVisibilityMutation = useMutation({\n   659→    ...orpc.bookmark.setVisibility.mutationOptions(),\n   660→    onMutate: async (data) => {\n   661→      const groupId = currentGroupId;\n   662→      await queryClient.cancelQueries({\n   663→        queryKey: orpc.bookmark.list.queryKey({\n   664→          input: { groupId: groupId ?? undefined },\n   665→        }),\n   666→      });\n   667→\n   668→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   669→        bookmarkListKey(groupId),\n   670→      );\n   671→\n   672→      queryClient.setQueryData<BookmarkItem[]>(\n   673→        bookmarkListKey(groupId),\n   674→        (old) =>\n   675→          old?.map((b) =>\n   676→            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n   677→          ) ?? [],\n   678→      );\n   679→\n   680→      return { previousBookmarks, groupId };\n   681→    },\n   682→    onError: (_err, _data, context) => {\n   683→      if (context?.previousBookmarks && context?.groupId) {\n   684→        queryClient.setQueryData<BookmarkItem[]>(\n   685→          bookmarkListKey(context.groupId),\n   686→          context.previousBookmarks,\n   687→        );\n   688→      }\n   689→      toast.error(\"Failed to update visibility\");\n   690→    },\n   691→    onSettled: (_data, _error, _variables, context) => {\n   692→      if (context?.groupId) {\n   693→        queryClient.invalidateQueries({\n   694→          queryKey: orpc.bookmark.list.key({\n   695→            input: { groupId: context.groupId },\n   696→          }),\n   697→        });\n   698→      }\n   699→    },\n   700→  });\n   701→\n   702→  const bulkSetVisibilityMutation = useMutation({\n   703→    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n   704→    onMutate: async (data) => {\n   705→      const groupId = currentGroupId;\n   706→      await queryClient.cancelQueries({\n   707→        queryKey: orpc.bookmark.list.queryKey({\n   708→          input: { groupId: groupId ?? undefined },\n   709→        }),\n   710→      });\n   711→\n   712→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   713→        bookmarkListKey(groupId),\n   714→      );\n   715→\n   716→      queryClient.setQueryData<BookmarkItem[]>(\n   717→        bookmarkListKey(groupId),\n   718→        (old) =>\n   719→          old?.map((b) =>\n   720→            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n   721→          ) ?? [],\n   722→      );\n   723→\n   724→      return { previousBookmarks, groupId };\n   725→    },\n   726→    onError: (_err, _data, context) => {\n   727→      if (context?.previousBookmarks && context?.groupId) {\n   728→        queryClient.setQueryData<BookmarkItem[]>(\n   729→          bookmarkListKey(context.groupId),\n   730→          context.previousBookmarks,\n   731→        );\n   732→      }\n   733→      toast.error(\"Failed to update visibility\");\n   734→    },\n   735→    onSettled: (_data, _error, _variables, context) => {\n   736→      if (context?.groupId) {\n   737→        queryClient.invalidateQueries({\n   738→          queryKey: orpc.bookmark.list.key({\n   739→            input: { groupId: context.groupId },\n   740→          }),\n   741→        });\n   742→      }\n   743→    },\n   744→  });\n   745→\n   746→  const setGroupVisibilityMutation = useMutation({\n   747→    ...orpc.group.setVisibility.mutationOptions(),\n   748→    onMutate: async (data) => {\n   749→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   750→\n   751→      const previousGroups =\n   752→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   753→\n   754→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   755→        old?.map((g) =>\n   756→          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n   757→        ),\n   758→      );\n   759→\n   760→      return { previousGroups };\n   761→    },\n   762→    onSuccess: (_data, variables) => {\n   763→      toast.success(\n   764→        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n   765→      );\n   766→    },\n   767→    onError: (_err, _data, context) => {\n   768→      if (context?.previousGroups) {\n   769→        queryClient.setQueryData<GroupItem[]>(\n   770→          groupListKey(),\n   771→          context.previousGroups,\n   772→        );\n   773→      }\n   774→      toast.error(\"Failed to update group visibility\");\n   775→    },\n   776→    onSettled: () => {\n   777→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   778→    },\n   779→  });\n   780→\n   781→  const selectedGroup =\n   782→    groups.find((g) => g.id === currentGroupId) || groups[0];\n   783→\n   784→  const handleStartRename = (id: string) => {\n   785→    setRenamingId(id);\n   786→  };\n   787→\n   788→  const handleFinishRename = () => {\n   789→    setRenamingId(null);\n   790→  };\n   791→\n   792→  const handleDeleteBookmark = useCallback(\n   793→    (id: string) => {\n   794→      bulkDeleteMutation.mutate({\n   795→        ids: [id],\n   796→        _groupId: currentGroupId ?? undefined,\n   797→      });\n   798→    },\n   799→    [bulkDeleteMutation, currentGroupId],\n   800→  );\n   801→\n   802→  const filteredBookmarks = useMemo(() => {\n   803→    return bookmarks.filter((b) => {\n   804→      if (!debouncedSearchQuery) return true;\n   805→      return (\n   806→        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n   807→        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n   808→      );\n   809→    });\n   810→  }, [bookmarks, debouncedSearchQuery]);\n   811→\n   812→  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n   813→    setSelectionMode(true);\n   814→    if (initialId) {\n   815→      setSelectedIds(new Set([initialId]));\n   816→    }\n   817→  }, []);\n   818→\n   819→  const handleExitSelectionMode = useCallback(() => {\n   820→    setSelectionMode(false);\n   821→    setSelectedIds(new Set());\n   822→  }, []);\n   823→\n   824→  const handleToggleSelection = useCallback((id: string) => {\n   825→    setSelectedIds((prev) => {\n   826→      const next = new Set(prev);\n   827→      if (next.has(id)) {\n   828→        next.delete(id);\n   829→      } else {\n   830→        next.add(id);\n   831→      }\n   832→      return next;\n   833→    });\n   834→  }, []);\n   835→\n   836→  const handleSelectAll = useCallback(() => {\n   837→    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n   838→  }, [filteredBookmarks]);\n   839→\n   840→  const handleCopyUrls = useCallback(() => {\n   841→    const urls = bookmarks\n   842→      .filter((b) => selectedIds.has(b.id) && b.url)\n   843→      .map((b) => b.url)\n   844→      .join(\"\\n\");\n   845→\n   846→    if (urls) {\n   847→      navigator.clipboard.writeText(urls);\n   848→      toast.success(`Copied ${selectedIds.size} URLs`);\n   849→    } else {\n   850→      toast.error(\"No URLs to copy\");\n   851→    }\n   852→  }, [bookmarks, selectedIds]);\n   853→\n   854→  const handleConfirmMove = useCallback(\n   855→    (targetGroupId: string) => {\n   856→      bulkMoveMutation.mutate({\n   857→        ids: Array.from(selectedIds),\n   858→        targetGroupId,\n   859→        _sourceGroupId: currentGroupId ?? undefined,\n   860→      });\n   861→      handleExitSelectionMode();\n   862→      toast.success(`Moved ${selectedIds.size} bookmarks`);\n   863→    },\n   864→    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n   865→  );\n   866→\n   867→  const handleConfirmDelete = useCallback(() => {\n   868→    bulkDeleteMutation.mutate({\n   869→      ids: Array.from(selectedIds),\n   870→      _groupId: currentGroupId ?? undefined,\n   871→    });\n   872→    handleExitSelectionMode();\n   873→    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n   874→  }, [\n   875→    bulkDeleteMutation,\n   876→    selectedIds,\n   877→    currentGroupId,\n   878→    handleExitSelectionMode,\n   879→  ]);\n   880→\n   881→  // Refs to store latest values for stable keyboard handler\n   882→  const groupsRef = useLatestRef(groups);\n   883→  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n   884→  const selectedIndexRef = useLatestRef(selectedIndex);\n   885→  const hoveredIndexRef = useLatestRef(hoveredIndex);\n   886→  const renamingIdRef = useLatestRef(renamingId);\n   887→  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n   888→  const handleStartRenameRef = useLatestRef(handleStartRename);\n   889→  const selectionModeRef = useLatestRef(selectionMode);\n   890→  const selectedIdsRef = useLatestRef(selectedIds);\n   891→\n   892→  const handleSearchChange = useCallback((value: string) => {\n   893→    setSearchQuery(value);\n   894→    setSelectedIndex(-1);\n   895→  }, []);\n   896→\n   897→  const handleSelectGroup = useCallback(\n   898→    (id: string) => {\n   899→      const group = groupsRef.current.find((g) => g.id === id);\n   900→      setGroupSlug(group ? slugify(group.name) : null);\n   901→      setSelectedIndex(-1);\n   902→      handleExitSelectionMode();\n   903→    },\n   904→    [setGroupSlug, handleExitSelectionMode],\n   905→  );\n   906→\n   907→  const handleAddBookmark = useCallback(\n   908→    (value: string) => {\n   909→      if (!currentGroupId) return;\n   910→\n   911→      const trimmedValue = value.trim();\n   912→      if (!trimmedValue) return;\n   913→\n   914→      const colorResult = parseColor(trimmedValue);\n   915→\n   916→      if (colorResult.isColor) {\n   917→        createBookmarkMutation.mutate({\n   918→          title: colorResult.original || trimmedValue,\n   919→          url: \"\",\n   920→          type: \"color\",\n   921→          color: colorResult.hex,\n   922→          groupId: currentGroupId,\n   923→        });\n   924→      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n   925→        const url = normalizeUrl(trimmedValue);\n   926→        createBookmarkMutation.mutate({\n   927→          title: new URL(url).hostname.replace(\"www.\", \"\"),\n   928→          url,\n   929→          type: \"link\",\n   930→          groupId: currentGroupId,\n   931→        });\n   932→      } else {\n   933→        createBookmarkMutation.mutate({\n   934→          title: trimmedValue,\n   935→          url: \"\",\n   936→          type: \"text\",\n   937→          groupId: currentGroupId,\n   938→        });\n   939→      }\n   940→\n   941→      setSearchQuery(\"\");\n   942→      setSelectedIndex(-1);\n   943→    },\n   944→    [currentGroupId, createBookmarkMutation],\n   945→  );\n   946→\n   947→  const handleCreateGroup = useCallback(\n   948→    (name: string) => {\n   949→      const palette = [\n   950→        \"#3E63DD\",\n   951→        \"#208368\",\n   952→        \"#FFDC00\",\n   953→        \"#CE2C31\",\n   954→        \"#53195D\",\n   955→        \"#0086F0FA\",\n   956→        \"#838383\",\n   957→        \"#74B06F\",\n   958→        \"#4A90D9\",\n   959→        \"#E6A23C\",\n   960→        \"#9B59B6\",\n   961→        \"#E74C3C\",\n   962→        \"#202020\",\n   963→      ];\n   964→      const usedColors = new Set(groups.map((g) => g.color));\n   965→      const availableColors = palette.filter((c) => !usedColors.has(c));\n   966→      const color =\n   967→        availableColors.length > 0\n   968→          ? availableColors[0]\n   969→          : palette[groups.length % palette.length];\n   970→\n   971→      createGroupMutation.mutate({ name, color });\n   972→    },\n   973→    [createGroupMutation, groups],\n   974→  );\n   975→\n   976→  const handleDeleteGroup = useCallback(\n   977→    (id: string) => {\n   978→      deleteGroupMutation.mutate({ id });\n   979→    },\n   980→    [deleteGroupMutation],\n   981→  );\n   982→\n   983→  const handleRenameBookmark = useCallback(\n   984→    (id: string, newTitle: string) => {\n   985→      updateBookmarkMutation.mutate({\n   986→        id,\n   987→        title: newTitle,\n   988→        _sourceGroupId: currentGroupId ?? undefined,\n   989→      });\n   990→    },\n   991→    [updateBookmarkMutation, currentGroupId],\n   992→  );\n   993→\n   994→  const handleMoveBookmark = useCallback(\n   995→    (id: string, targetGroupId: string) => {\n   996→      updateBookmarkMutation.mutate({\n   997→        id,\n   998→        groupId: targetGroupId,\n   999→        _sourceGroupId: currentGroupId ?? undefined,\n  1000→      });\n  1001→    },\n  1002→    [updateBookmarkMutation, currentGroupId],\n  1003→  );\n  1004→\n  1005→  const handleRefetchBookmark = useCallback(\n  1006→    (id: string) => {\n  1007→      refetchBookmarkMutation.mutate({\n  1008→        id,\n  1009→        groupId: currentGroupId ?? undefined,\n  1010→      });\n  1011→    },\n  1012→    [refetchBookmarkMutation, currentGroupId],\n  1013→  );\n  1014→\n  1015→  const handleToggleBookmarkVisibility = useCallback(\n  1016→    (id: string, currentIsPublic: boolean | null | undefined) => {\n  1017→      const isInPublicGroup = currentGroupId\n  1018→        ? publicGroupIds.has(currentGroupId)\n  1019→        : false;\n  1020→      const isEffectivelyPublic =\n  1021→        currentIsPublic === true ||\n  1022→        (isInPublicGroup && currentIsPublic !== false);\n  1023→\n  1024→      if (isEffectivelyPublic) {\n  1025→        setVisibilityMutation.mutate({\n  1026→          id,\n  1027→          isPublic: isInPublicGroup ? false : null,\n  1028→        });\n  1029→        toast.success(\"Bookmark hidden from public profile\");\n  1030→      } else {\n  1031→        setVisibilityMutation.mutate({ id, isPublic: true });\n  1032→        toast.success(\"Bookmark visible on public profile\");\n  1033→      }\n  1034→    },\n  1035→    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  1036→  );\n  1037→\n  1038→  const handleBulkMakePublic = useCallback(() => {\n  1039→    bulkSetVisibilityMutation.mutate({\n  1040→      ids: Array.from(selectedIds),\n  1041→      isPublic: true,\n  1042→    });\n  1043→    handleExitSelectionMode();\n  1044→    toast.success(`${selectedIds.size} bookmarks made public`);\n  1045→  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n  1046→\n  1047→  const handleBulkMakePrivate = useCallback(() => {\n  1048→    const isInPublicGroup = currentGroupId\n  1049→      ? publicGroupIds.has(currentGroupId)\n  1050→      : false;\n  1051→    bulkSetVisibilityMutation.mutate({\n  1052→      ids: Array.from(selectedIds),\n  1053→      isPublic: isInPublicGroup ? false : null,\n  1054→    });\n  1055→    handleExitSelectionMode();\n  1056→    toast.success(`${selectedIds.size} bookmarks made private`);\n  1057→  }, [\n  1058→    bulkSetVisibilityMutation,\n  1059→    selectedIds,\n  1060→    currentGroupId,\n  1061→    publicGroupIds,\n  1062→    handleExitSelectionMode,\n  1063→  ]);\n  1064→\n  1065→  const handleToggleGroupVisibility = useCallback(\n  1066→    (id: string, isPublic: boolean) => {\n  1067→      setGroupVisibilityMutation.mutate({ id, isPublic });\n  1068→    },\n  1069→    [setGroupVisibilityMutation],\n  1070→  );\n  1071→\n  1072→  useEffect(() => {\n  1073→    const handleKeyDown = (e: KeyboardEvent) => {\n  1074→      if (renamingIdRef.current) return;\n  1075→\n  1076→      if (document.activeElement === inputRef.current) {\n  1077→        return;\n  1078→      }\n  1079→\n  1080→      const isInputFocused =\n  1081→        document.activeElement instanceof HTMLInputElement ||\n  1082→        document.activeElement instanceof HTMLTextAreaElement;\n  1083→      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n  1084→        return;\n  1085→      }\n  1086→\n  1087→      const bookmarks = filteredBookmarksRef.current;\n  1088→      const inSelectionMode = selectionModeRef.current;\n  1089→\n  1090→      if (e.key === \"Escape\" && inSelectionMode) {\n  1091→        e.preventDefault();\n  1092→        handleExitSelectionMode();\n  1093→        return;\n  1094→      }\n  1095→\n  1096→      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n  1097→        e.preventDefault();\n  1098→        handleSelectAll();\n  1099→        return;\n  1100→      }\n  1101→\n  1102→      if (e.key === \"ArrowDown\") {\n  1103→        e.preventDefault();\n  1104→        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n  1105→        return;\n  1106→      }\n  1107→      if (e.key === \"ArrowUp\") {\n  1108→        e.preventDefault();\n  1109→        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n  1110→        return;\n  1111→      }\n  1112→\n  1113→      const activeIndex =\n  1114→        hoveredIndexRef.current >= 0\n  1115→          ? hoveredIndexRef.current\n  1116→          : selectedIndexRef.current;\n  1117→      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n  1118→      const activeBookmark = bookmarks[activeIndex];\n  1119→      if (!activeBookmark) return;\n  1120→\n  1121→      if (e.key === \" \" && inSelectionMode) {\n  1122→        e.preventDefault();\n  1123→        handleToggleSelection(activeBookmark.id);\n  1124→        return;\n  1125→      }\n  1126→\n  1127→      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n  1128→        e.preventDefault();\n  1129→        if (activeBookmark.url) {\n  1130→          window.open(activeBookmark.url, \"_blank\");\n  1131→        } else {\n  1132→          const textToCopy = activeBookmark.color || activeBookmark.title;\n  1133→          navigator.clipboard.writeText(textToCopy ?? \"\");\n  1134→        }\n  1135→      }\n  1136→\n  1137→      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n  1138→        e.preventDefault();\n  1139→        const textToCopy =\n  1140→          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n  1141→        navigator.clipboard.writeText(textToCopy ?? \"\");\n  1142→      }\n  1143→\n  1144→      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n  1145→        e.preventDefault();\n  1146→        handleStartRenameRef.current(activeBookmark.id);\n  1147→      }\n  1148→\n  1149→      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n  1150→        e.preventDefault();\n  1151→        handleDeleteBookmarkRef.current(activeBookmark.id);\n  1152→      }\n  1153→    };\n  1154→\n  1155→    window.addEventListener(\"keydown\", handleKeyDown);\n  1156→    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  1157→  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n  1158→\n  1159→  if (!selectedGroup) {\n  1160→    return null;\n  1161→  }\n  1162→\n  1163→  return (\n  1164→    <div className=\"min-h-dvh bg-background\">\n  1165→      <Header\n  1166→        groups={groups}\n  1167→        selectedGroup={selectedGroup}\n  1168→        onSelectGroup={handleSelectGroup}\n  1169→        onCreateGroup={handleCreateGroup}\n  1170→        onDeleteGroup={handleDeleteGroup}\n  1171→        onToggleGroupVisibility={\n  1172→          hasUsername ? handleToggleGroupVisibility : undefined\n  1173→        }\n  1174→        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n  1175→        userName={session.user.name}\n  1176→        userEmail={session.user.email}\n  1177→        userImage={profile.image}\n  1178→        username={profile.username}\n  1179→        profile={profile}\n  1180→      />\n  1181→      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n  1182→        <BookmarkInput\n  1183→          ref={inputRef}\n  1184→          value={searchQuery}\n  1185→          onChange={handleSearchChange}\n  1186→          onSubmit={handleAddBookmark}\n  1187→        />\n  1188→        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n  1189→          <BookmarkListSkeleton />\n  1190→        ) : (\n  1191→          <BookmarkList\n  1192→            bookmarks={filteredBookmarks}\n  1193→            groups={groups}\n  1194→            onDelete={handleDeleteBookmark}\n  1195→            onRename={handleRenameBookmark}\n  1196→            onMove={handleMoveBookmark}\n  1197→            onRefetch={handleRefetchBookmark}\n  1198→            currentGroupId={currentGroupId || \"\"}\n  1199→            selectedIndex={selectedIndex}\n  1200→            onSelect={setSelectedIndex}\n  1201→            renamingId={renamingId}\n  1202→            onStartRename={handleStartRename}\n  1203→            onFinishRename={handleFinishRename}\n  1204→            onHoverChange={setHoveredIndex}\n  1205→            hoveredIndex={hoveredIndex}\n  1206→            selectionMode={selectionMode}\n  1207→            selectedIds={selectedIds}\n  1208→            onToggleSelection={handleToggleSelection}\n  1209→            onEnterSelectionMode={handleEnterSelectionMode}\n  1210→            onBulkMove={handleConfirmMove}\n  1211→            onBulkDelete={handleConfirmDelete}\n  1212→            hasUsername={hasUsername}\n  1213→            publicGroupIds={publicGroupIds}\n  1214→            onToggleVisibility={handleToggleBookmarkVisibility}\n  1215→          />\n  1216→        )}\n  1217→        {selectionMode && selectedIds.size > 0 && (\n  1218→          <MultiSelectToolbar\n  1219→            selectedCount={selectedIds.size}\n  1220→            onSelectAll={handleSelectAll}\n  1221→            onMove={() => setMoveDialogOpen(true)}\n  1222→            onCopyUrls={handleCopyUrls}\n  1223→            onDelete={() => setDeleteDialogOpen(true)}\n  1224→            onClose={handleExitSelectionMode}\n  1225→            hasUsername={hasUsername}\n  1226→            onMakePublic={\n  1227→              currentGroupId && publicGroupIds.has(currentGroupId)\n  1228→                ? undefined\n  1229→                : handleBulkMakePublic\n  1230→            }\n  1231→            onMakePrivate={\n  1232→              currentGroupId && publicGroupIds.has(currentGroupId)\n  1233→                ? handleBulkMakePrivate\n  1234→                : undefined\n  1235→            }\n  1236→          />\n  1237→        )}\n  1238→        <BulkMoveDialog\n  1239→          open={moveDialogOpen}\n  1240→          onOpenChange={setMoveDialogOpen}\n  1241→          groups={groups}\n  1242→          currentGroupId={currentGroupId || \"\"}\n  1243→          selectedCount={selectedIds.size}\n  1244→          onConfirm={handleConfirmMove}\n  1245→        />\n  1246→        <BulkDeleteDialog\n  1247→          open={deleteDialogOpen}\n  1248→          onOpenChange={setDeleteDialogOpen}\n  1249→          count={selectedIds.size}\n  1250→          onConfirm={handleConfirmDelete}\n  1251→        />\n  1252→      </main>\n  1253→    </div>\n  1254→  );\n  1255→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"ba2402fe-a975-4029-a342-cad87fb62dee","timestamp":"2026-02-10T17:49:07.451Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/duncan/.REDACTED.txt","content":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}","numLines":1255,"startLine":1,"totalLines":1255}},"sourceToolAssistantUUID":"8a29451e-9087-4238-a19e-86f831b3983f"}
{"parentUuid":"ba2402fe-a975-4029-a342-cad87fb62dee","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Bi1dQbKGdSnYRtshPtXNGU","toolUseID":"toolu_01Bi1dQbKGdSnYRtshPtXNGU","timestamp":"2026-02-10T17:49:07.451Z","uuid":"813bab88-43d3-4fac-9daa-bb64900c881c"}
{"parentUuid":"d54c61f3-64ef-4779-a3fe-5aab90170684","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VWD1cmsvZshbajm7VCWUvA","type":"tool_result","content":"     1→\"use client\";\n     2→\n     3→import { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\n     4→import { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\n     5→import { toast } from \"sonner\";\n     6→import { Header } from \"@/components/header\";\n     7→import { BookmarkInput } from \"@/components/bookmark-input\";\n     8→import { BookmarkList } from \"@/components/bookmark-list\";\n     9→import { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n    10→import { MultiSelectToolbar } from \"@/components/multi-select-toolbar\";\n    11→import { BulkMoveDialog } from \"@/components/bulk-move-dialog\";\n    12→import { BulkDeleteDialog } from \"@/components/bulk-delete-dialog\";\n    13→import { ExportDialog, handleQuickExport } from \"@/components/export-dialog\";\n    14→import { parseColor, isUrl, normalizeUrl } from \"@/lib/utils\";\n    15→import { client } from \"@/lib/orpc\";\n    16→import { useDebounce } from \"@/hooks/use-debounce\";\n    17→import { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\n    18→import { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\n    19→import type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\n    20→import type { Session } from \"@/lib/auth\";\n    21→\n    22→interface DashboardContentProps {\n    23→  session: NonNullable<Session>;\n    24→  initialGroups: GroupItem[];\n    25→  initialBookmarks: BookmarkItem[];\n    26→}\n    27→\n    28→export function DashboardContent({\n    29→  session,\n    30→  initialGroups,\n    31→  initialBookmarks,\n    32→}: DashboardContentProps) {\n    33→  const queryClient = useQueryClient();\n    34→\n    35→  const [selectedGroupId, setSelectedGroupId] = useState<string | null>(null);\n    36→  const [searchQuery, setSearchQuery] = useState(\"\");\n    37→  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n    38→  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n    39→  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n    40→  const inputRef = useRef<HTMLInputElement>(null);\n    41→  const [renamingId, setRenamingId] = useState<string | null>(null);\n    42→  const [selectionMode, setSelectionMode] = useState(false);\n    43→  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n    44→  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n    45→  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n    46→  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n    47→\n    48→  const groupsQuery = useQuery({\n    49→    queryKey: [\"groups\"],\n    50→    queryFn: () => client.group.list(),\n    51→    initialData: initialGroups,\n    52→    staleTime: 60 * 1000,\n    53→  });\n    54→\n    55→  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n    56→\n    57→  useFocusRefetch(groups);\n    58→\n    59→  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n    60→\n    61→  const bookmarksQuery = useQuery({\n    62→    queryKey: [\"bookmarks\", currentGroupId],\n    63→    queryFn: () =>\n    64→      client.bookmark.list({ groupId: currentGroupId ?? undefined }),\n    65→    initialData:\n    66→      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    67→    enabled: !!currentGroupId,\n    68→    staleTime: 60 * 1000,\n    69→  });\n    70→\n    71→  const bookmarks = useMemo(\n    72→    () => bookmarksQuery.data ?? [],\n    73→    [bookmarksQuery.data]\n    74→  );\n    75→\n    76→  const allBookmarksQuery = useQuery({\n    77→    queryKey: [\"bookmarks\", \"all\"],\n    78→    queryFn: () => client.bookmark.list({}),\n    79→    enabled: exportDialogOpen,\n    80→    staleTime: 60 * 1000,\n    81→  });\n    82→\n    83→  const allBookmarks = useMemo(\n    84→    () => allBookmarksQuery.data ?? [],\n    85→    [allBookmarksQuery.data]\n    86→  );\n    87→\n    88→  useEffect(() => {\n    89→    setSelectedIndex(-1);\n    90→    setHoveredIndex(-1);\n    91→  }, [bookmarks, currentGroupId]);\n    92→\n    93→  const createBookmarkMutation = useMutation({\n    94→    mutationFn: (data: {\n    95→      title: string;\n    96→      url?: string;\n    97→      type: BookmarkType;\n    98→      color?: string;\n    99→      groupId: string;\n   100→    }) => client.bookmark.create(data),\n   101→    onMutate: async (newBookmark) => {\n   102→      await queryClient.cancelQueries({\n   103→        queryKey: [\"bookmarks\", newBookmark.groupId],\n   104→      });\n   105→      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n   106→\n   107→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n   108→        \"bookmarks\",\n   109→        newBookmark.groupId,\n   110→      ]);\n   111→      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n   112→\n   113→      const optimisticBookmark: BookmarkItem = {\n   114→        id: `temp-${Date.now()}`,\n   115→        title: newBookmark.title,\n   116→        url: newBookmark.url || null,\n   117→        favicon: null,\n   118→        type: newBookmark.type,\n   119→        color: newBookmark.color || null,\n   120→        groupId: newBookmark.groupId,\n   121→        createdAt: new Date().toISOString(),\n   122→      };\n   123→\n   124→      queryClient.setQueryData<BookmarkItem[]>(\n   125→        [\"bookmarks\", newBookmark.groupId],\n   126→        (old) => [optimisticBookmark, ...(old || [])]\n   127→      );\n   128→\n   129→      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n   130→        old?.map((g) =>\n   131→          g.id === newBookmark.groupId\n   132→            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n   133→            : g\n   134→        )\n   135→      );\n   136→\n   137→      return {\n   138→        previousBookmarks,\n   139→        previousGroups,\n   140→        groupId: newBookmark.groupId,\n   141→      };\n   142→    },\n   143→    onError: (_err, _newBookmark, context) => {\n   144→      if (context?.previousBookmarks) {\n   145→        queryClient.setQueryData(\n   146→          [\"bookmarks\", context.groupId],\n   147→          context.previousBookmarks\n   148→        );\n   149→      }\n   150→      if (context?.previousGroups) {\n   151→        queryClient.setQueryData([\"groups\"], context.previousGroups);\n   152→      }\n   153→      toast.error(\"Failed to create bookmark\");\n   154→    },\n   155→    onSettled: (_data, _error, variables) => {\n   156→      queryClient.invalidateQueries({\n   157→        queryKey: [\"bookmarks\", variables.groupId],\n   158→      });\n   159→      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n   160→    },\n   161→  });\n   162→\n   163→  const updateBookmarkMutation = useMutation({\n   164→    mutationFn: async (data: {\n   165→      id: string;\n   166→      title?: string;\n   167→      url?: string;\n   168→      type?: BookmarkType;\n   169→      color?: string;\n   170→      groupId?: string;\n   171→      _sourceGroupId?: string;\n   172→    }) => {\n   173→      if (data.id.startsWith(\"temp-\")) {\n   174→        return { id: data.id, title: data.title ?? \"\" } as Pick<\n   175→          BookmarkItem,\n   176→          \"id\" | \"title\"\n   177→        >;\n   178→      }\n   179→      const { _sourceGroupId, ...updateData } = data;\n   180→      return client.bookmark.update(updateData);\n   181→    },\n   182→    onMutate: async (data) => {\n   183→      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n   184→      const isMove =\n   185→        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n   186→\n   187→      await queryClient.cancelQueries({ queryKey: [\"bookmarks\"] });\n   188→      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n   189→\n   190→      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n   191→\n   192→      if (isMove) {\n   193→        const previousSourceBookmarks = queryClient.getQueryData<\n   194→          BookmarkItem[]\n   195→        >([\"bookmarks\", _sourceGroupId]);\n   196→        const previousTargetBookmarks = queryClient.getQueryData<\n   197→          BookmarkItem[]\n   198→        >([\"bookmarks\", targetGroupId]);\n   199→\n   200→        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n   201→\n   202→        if (movedBookmark) {\n   203→          queryClient.setQueryData<BookmarkItem[]>(\n   204→            [\"bookmarks\", _sourceGroupId],\n   205→            (old) => old?.filter((b) => b.id !== id) ?? []\n   206→          );\n   207→\n   208→          queryClient.setQueryData<BookmarkItem[]>(\n   209→            [\"bookmarks\", targetGroupId],\n   210→            (old) => [\n   211→              { ...movedBookmark, groupId: targetGroupId },\n   212→              ...(old ?? []),\n   213→            ]\n   214→          );\n   215→\n   216→          queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n   217→            old?.map((g) => {\n   218→              if (g.id === _sourceGroupId) {\n   219→                return {\n   220→                  ...g,\n   221→                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n   222→                };\n   223→              }\n   224→              if (g.id === targetGroupId) {\n   225→                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n   226→              }\n   227→              return g;\n   228→            })\n   229→          );\n   230→        }\n   231→\n   232→        return {\n   233→          previousSourceBookmarks,\n   234→          previousTargetBookmarks,\n   235→          previousGroups,\n   236→          sourceGroupId: _sourceGroupId,\n   237→          targetGroupId,\n   238→        };\n   239→      }\n   240→\n   241→      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n   242→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n   243→        \"bookmarks\",\n   244→        sourceGroupId,\n   245→      ]);\n   246→\n   247→      queryClient.setQueryData<BookmarkItem[]>(\n   248→        [\"bookmarks\", sourceGroupId],\n   249→        (old) => old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? []\n   250→      );\n   251→\n   252→      return { previousBookmarks, sourceGroupId, previousGroups };\n   253→    },\n   254→    onError: (_err, data, context) => {\n   255→      if (\n   256→        context?.previousSourceBookmarks !== undefined &&\n   257→        context?.sourceGroupId\n   258→      ) {\n   259→        queryClient.setQueryData(\n   260→          [\"bookmarks\", context.sourceGroupId],\n   261→          context.previousSourceBookmarks\n   262→        );\n   263→      }\n   264→      if (\n   265→        context?.previousTargetBookmarks !== undefined &&\n   266→        context?.targetGroupId\n   267→      ) {\n   268→        queryClient.setQueryData(\n   269→          [\"bookmarks\", context.targetGroupId],\n   270→          context.previousTargetBookmarks\n   271→        );\n   272→      }\n   273→      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n   274→        queryClient.setQueryData(\n   275→          [\"bookmarks\", context.sourceGroupId],\n   276→          context.previousBookmarks\n   277→        );\n   278→      }\n   279→      if (context?.previousGroups) {\n   280→        queryClient.setQueryData([\"groups\"], context.previousGroups);\n   281→      }\n   282→      toast.error(\"Failed to update bookmark\");\n   283→    },\n   284→    onSettled: (_data, _error, data, context) => {\n   285→      if (context?.sourceGroupId) {\n   286→        queryClient.invalidateQueries({\n   287→          queryKey: [\"bookmarks\", context.sourceGroupId],\n   288→        });\n   289→      }\n   290→      if (context?.targetGroupId) {\n   291→        queryClient.invalidateQueries({\n   292→          queryKey: [\"bookmarks\", context.targetGroupId],\n   293→        });\n   294→      }\n   295→      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n   296→    },\n   297→  });\n   298→\n   299→  const createGroupMutation = useMutation({\n   300→    mutationFn: (data: {\n   301→      name: string;\n   302→      color: string;\n   303→      _optimisticId?: string;\n   304→    }) => {\n   305→      const { _optimisticId, ...createData } = data;\n   306→      return client.group.create(createData);\n   307→    },\n   308→    onMutate: async (newGroup) => {\n   309→      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n   310→\n   311→      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n   312→      const previousSelectedGroupId = selectedGroupId;\n   313→\n   314→      const optimisticGroup: GroupItem = {\n   315→        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n   316→        name: newGroup.name,\n   317→        color: newGroup.color,\n   318→        bookmarkCount: 0,\n   319→      };\n   320→\n   321→      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) => [\n   322→        ...(old ?? []),\n   323→        optimisticGroup,\n   324→      ]);\n   325→\n   326→      setSelectedGroupId(optimisticGroup.id);\n   327→      setSelectedIndex(-1);\n   328→\n   329→      return {\n   330→        previousGroups,\n   331→        previousSelectedGroupId,\n   332→        optimisticId: optimisticGroup.id,\n   333→      };\n   334→    },\n   335→    onError: (_err, _newGroup, context) => {\n   336→      if (context?.previousGroups) {\n   337→        queryClient.setQueryData([\"groups\"], context.previousGroups);\n   338→      }\n   339→      if (context?.previousSelectedGroupId !== undefined) {\n   340→        setSelectedGroupId(context.previousSelectedGroupId);\n   341→      }\n   342→      toast.error(\"Failed to create group\");\n   343→    },\n   344→    onSettled: () => {\n   345→      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n   346→    },\n   347→  });\n   348→\n   349→  const deleteGroupMutation = useMutation({\n   350→    mutationFn: (data: { id: string }) => client.group.delete(data),\n   351→    onMutate: async (data) => {\n   352→      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n   353→\n   354→      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n   355→      const previousSelectedGroupId = selectedGroupId;\n   356→\n   357→      queryClient.setQueryData<GroupItem[]>(\n   358→        [\"groups\"],\n   359→        (old) => old?.filter((g) => g.id !== data.id) ?? []\n   360→      );\n   361→\n   362→      if (currentGroupId === data.id) {\n   363→        const remainingGroups =\n   364→          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n   365→        setSelectedGroupId(remainingGroups[0]?.id ?? null);\n   366→        setSelectedIndex(-1);\n   367→      }\n   368→\n   369→      return { previousGroups, previousSelectedGroupId, deletedId: data.id };\n   370→    },\n   371→    onError: (_err, _data, context) => {\n   372→      if (context?.previousGroups) {\n   373→        queryClient.setQueryData([\"groups\"], context.previousGroups);\n   374→      }\n   375→      if (context?.previousSelectedGroupId !== undefined) {\n   376→        setSelectedGroupId(context.previousSelectedGroupId);\n   377→      }\n   378→      toast.error(\"Failed to delete group\");\n   379→    },\n   380→    onSettled: () => {\n   381→      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n   382→    },\n   383→  });\n   384→\n   385→  const refetchBookmarkMutation = useMutation({\n   386→    mutationFn: (data: { id: string }) => client.bookmark.refetch(data),\n   387→    onSuccess: () => {\n   388→      queryClient.invalidateQueries({ queryKey: [\"bookmarks\"] });\n   389→      toast.success(\"Metadata refreshed\");\n   390→    },\n   391→    onError: () => {\n   392→      toast.error(\"Failed to refresh metadata\");\n   393→    },\n   394→  });\n   395→\n   396→  const bulkDeleteMutation = useMutation({\n   397→    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n   398→      const { _groupId, ...deleteData } = data;\n   399→      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n   400→      if (realIds.length === 0) {\n   401→        return { success: true };\n   402→      }\n   403→      return client.bookmark.bulkDelete({ ids: realIds });\n   404→    },\n   405→    onMutate: async (data) => {\n   406→      const groupId = data._groupId ?? currentGroupId;\n   407→\n   408→      await queryClient.cancelQueries({ queryKey: [\"bookmarks\", groupId] });\n   409→      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n   410→\n   411→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n   412→        \"bookmarks\",\n   413→        groupId,\n   414→      ]);\n   415→      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n   416→\n   417→      queryClient.setQueryData<BookmarkItem[]>(\n   418→        [\"bookmarks\", groupId],\n   419→        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? []\n   420→      );\n   421→\n   422→      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n   423→        old?.map((g) =>\n   424→          g.id === groupId\n   425→            ? {\n   426→              ...g,\n   427→              bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - data.ids.length),\n   428→            }\n   429→            : g\n   430→        )\n   431→      );\n   432→\n   433→      return { previousBookmarks, previousGroups, groupId };\n   434→    },\n   435→    onError: (_err, _data, context) => {\n   436→      if (context?.previousBookmarks) {\n   437→        queryClient.setQueryData(\n   438→          [\"bookmarks\", context.groupId],\n   439→          context.previousBookmarks\n   440→        );\n   441→      }\n   442→      if (context?.previousGroups) {\n   443→        queryClient.setQueryData([\"groups\"], context.previousGroups);\n   444→      }\n   445→      toast.error(\"Failed to delete bookmarks\");\n   446→    },\n   447→    onSettled: (_data, _error, _variables, context) => {\n   448→      if (context?.groupId) {\n   449→        queryClient.invalidateQueries({\n   450→          queryKey: [\"bookmarks\", context.groupId],\n   451→        });\n   452→      }\n   453→      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n   454→    },\n   455→  });\n   456→\n   457→  const bulkMoveMutation = useMutation({\n   458→    mutationFn: (data: {\n   459→      ids: string[];\n   460→      targetGroupId: string;\n   461→      _sourceGroupId?: string;\n   462→    }) => {\n   463→      const { _sourceGroupId, ...moveData } = data;\n   464→      return client.bookmark.bulkMove(moveData);\n   465→    },\n   466→    onMutate: async (data) => {\n   467→      const { ids, targetGroupId, _sourceGroupId } = data;\n   468→      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n   469→\n   470→      await queryClient.cancelQueries({ queryKey: [\"bookmarks\"] });\n   471→      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n   472→\n   473→      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n   474→        \"bookmarks\",\n   475→        sourceGroupId,\n   476→      ]);\n   477→      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n   478→        \"bookmarks\",\n   479→        targetGroupId,\n   480→      ]);\n   481→      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n   482→\n   483→      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n   484→        ids.includes(b.id)\n   485→      );\n   486→\n   487→      if (movedBookmarks) {\n   488→        queryClient.setQueryData<BookmarkItem[]>(\n   489→          [\"bookmarks\", sourceGroupId],\n   490→          (old) => old?.filter((b) => !ids.includes(b.id)) ?? []\n   491→        );\n   492→\n   493→        queryClient.setQueryData<BookmarkItem[]>(\n   494→          [\"bookmarks\", targetGroupId],\n   495→          (old) => [\n   496→            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n   497→            ...(old ?? []),\n   498→          ]\n   499→        );\n   500→\n   501→        queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n   502→          old?.map((g) => {\n   503→            if (g.id === sourceGroupId) {\n   504→              return {\n   505→                ...g,\n   506→                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n   507→              };\n   508→            }\n   509→            if (g.id === targetGroupId) {\n   510→              return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + ids.length };\n   511→            }\n   512→            return g;\n   513→          })\n   514→        );\n   515→      }\n   516→\n   517→      return {\n   518→        previousSourceBookmarks,\n   519→        previousTargetBookmarks,\n   520→        previousGroups,\n   521→        sourceGroupId,\n   522→        targetGroupId,\n   523→      };\n   524→    },\n   525→    onError: (_err, _data, context) => {\n   526→      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n   527→        queryClient.setQueryData(\n   528→          [\"bookmarks\", context.sourceGroupId],\n   529→          context.previousSourceBookmarks\n   530→        );\n   531→      }\n   532→      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n   533→        queryClient.setQueryData(\n   534→          [\"bookmarks\", context.targetGroupId],\n   535→          context.previousTargetBookmarks\n   536→        );\n   537→      }\n   538→      if (context?.previousGroups) {\n   539→        queryClient.setQueryData([\"groups\"], context.previousGroups);\n   540→      }\n   541→      toast.error(\"Failed to move bookmarks\");\n   542→    },\n   543→    onSettled: (_data, _error, _variables, context) => {\n   544→      if (context?.sourceGroupId) {\n   545→        queryClient.invalidateQueries({\n   546→          queryKey: [\"bookmarks\", context.sourceGroupId],\n   547→        });\n   548→      }\n   549→      if (context?.targetGroupId) {\n   550→        queryClient.invalidateQueries({\n   551→          queryKey: [\"bookmarks\", context.targetGroupId],\n   552→        });\n   553→      }\n   554→      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n   555→    },\n   556→  });\n   557→\n   558→  const selectedGroup =\n   559→    groups.find((g) => g.id === currentGroupId) || groups[0];\n   560→\n   561→  const handleStartRename = (id: string) => {\n   562→    setRenamingId(id);\n   563→  };\n   564→\n   565→  const handleFinishRename = () => {\n   566→    setRenamingId(null);\n   567→  };\n   568→\n   569→  const handleDeleteBookmark = useCallback(\n   570→    (id: string) => {\n   571→      bulkDeleteMutation.mutate({\n   572→        ids: [id],\n   573→        _groupId: currentGroupId ?? undefined,\n   574→      });\n   575→    },\n   576→    [bulkDeleteMutation, currentGroupId]\n   577→  );\n   578→\n   579→  const filteredBookmarks = useMemo(() => {\n   580→    return bookmarks.filter((b) => {\n   581→      if (!debouncedSearchQuery) return true;\n   582→      return (\n   583→        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n   584→        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n   585→      );\n   586→    });\n   587→  }, [bookmarks, debouncedSearchQuery]);\n   588→\n   589→  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n   590→    setSelectionMode(true);\n   591→    if (initialId) {\n   592→      setSelectedIds(new Set([initialId]));\n   593→    }\n   594→  }, []);\n   595→\n   596→  const handleExitSelectionMode = useCallback(() => {\n   597→    setSelectionMode(false);\n   598→    setSelectedIds(new Set());\n   599→  }, []);\n   600→\n   601→  const handleToggleSelection = useCallback((id: string) => {\n   602→    setSelectedIds((prev) => {\n   603→      const next = new Set(prev);\n   604→      if (next.has(id)) {\n   605→        next.delete(id);\n   606→      } else {\n   607→        next.add(id);\n   608→      }\n   609→      return next;\n   610→    });\n   611→  }, []);\n   612→\n   613→  const handleSelectAll = useCallback(() => {\n   614→    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n   615→  }, [filteredBookmarks]);\n   616→\n   617→  const handleCopyUrls = useCallback(() => {\n   618→    const urls = bookmarks\n   619→      .filter((b) => selectedIds.has(b.id) && b.url)\n   620→      .map((b) => b.url)\n   621→      .join(\"\\n\");\n   622→\n   623→    if (urls) {\n   624→      navigator.clipboard.writeText(urls);\n   625→      toast.success(`Copied ${selectedIds.size} URLs`);\n   626→    } else {\n   627→      toast.error(\"No URLs to copy\");\n   628→    }\n   629→  }, [bookmarks, selectedIds]);\n   630→\n   631→  const handleConfirmMove = useCallback(\n   632→    (targetGroupId: string) => {\n   633→      bulkMoveMutation.mutate({\n   634→        ids: Array.from(selectedIds),\n   635→        targetGroupId,\n   636→        _sourceGroupId: currentGroupId ?? undefined,\n   637→      });\n   638→      handleExitSelectionMode();\n   639→      toast.success(`Moved ${selectedIds.size} bookmarks`);\n   640→    },\n   641→    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode]\n   642→  );\n   643→\n   644→  const handleConfirmDelete = useCallback(() => {\n   645→    bulkDeleteMutation.mutate({\n   646→      ids: Array.from(selectedIds),\n   647→      _groupId: currentGroupId ?? undefined,\n   648→    });\n   649→    handleExitSelectionMode();\n   650→    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n   651→  }, [bulkDeleteMutation, selectedIds, currentGroupId, handleExitSelectionMode]);\n   652→\n   653→  const handleQuickExportAction = useCallback(\n   654→    (format: \"csv\" | \"json\") => {\n   655→      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n   656→      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n   657→      handleExitSelectionMode();\n   658→    },\n   659→    [bookmarks, selectedIds, groups, handleExitSelectionMode]\n   660→  );\n   661→\n   662→  const handleOpenExportDialog = useCallback(() => {\n   663→    setExportDialogOpen(true);\n   664→  }, []);\n   665→\n   666→  // Refs to store latest values for stable keyboard handler\n   667→  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n   668→  const selectedIndexRef = useLatestRef(selectedIndex);\n   669→  const hoveredIndexRef = useLatestRef(hoveredIndex);\n   670→  const renamingIdRef = useLatestRef(renamingId);\n   671→  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n   672→  const handleStartRenameRef = useLatestRef(handleStartRename);\n   673→  const selectionModeRef = useLatestRef(selectionMode);\n   674→  const selectedIdsRef = useLatestRef(selectedIds);\n   675→\n   676→  const handleSearchChange = useCallback((value: string) => {\n   677→    setSearchQuery(value);\n   678→    setSelectedIndex(-1);\n   679→  }, []);\n   680→\n   681→  const handleSelectGroup = useCallback(\n   682→    (id: string) => {\n   683→      setSelectedGroupId(id);\n   684→      setSelectedIndex(-1);\n   685→      handleExitSelectionMode();\n   686→    },\n   687→    [handleExitSelectionMode]\n   688→  );\n   689→\n   690→  const handleAddBookmark = useCallback(\n   691→    (value: string) => {\n   692→      if (!currentGroupId) return;\n   693→\n   694→      const trimmedValue = value.trim();\n   695→      if (!trimmedValue) return;\n   696→\n   697→      const colorResult = parseColor(trimmedValue);\n   698→\n   699→      if (colorResult.isColor) {\n   700→        createBookmarkMutation.mutate({\n   701→          title: colorResult.original || trimmedValue,\n   702→          url: \"\",\n   703→          type: \"color\",\n   704→          color: colorResult.hex,\n   705→          groupId: currentGroupId,\n   706→        });\n   707→      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n   708→        const url = normalizeUrl(trimmedValue);\n   709→        createBookmarkMutation.mutate({\n   710→          title: new URL(url).hostname.replace(\"www.\", \"\"),\n   711→          url,\n   712→          type: \"link\",\n   713→          groupId: currentGroupId,\n   714→        });\n   715→      } else {\n   716→        createBookmarkMutation.mutate({\n   717→          title: trimmedValue,\n   718→          url: \"\",\n   719→          type: \"text\",\n   720→          groupId: currentGroupId,\n   721→        });\n   722→      }\n   723→\n   724→      setSearchQuery(\"\");\n   725→      setSelectedIndex(-1);\n   726→    },\n   727→    [currentGroupId, createBookmarkMutation]\n   728→  );\n   729→\n   730→  const handleCreateGroup = useCallback(\n   731→    (name: string) => {\n   732→      const palette = [\n   733→        \"#3E63DD\",\n   734→        \"#208368\",\n   735→        \"#FFDC00\",\n   736→        \"#CE2C31\",\n   737→        \"#53195D\",\n   738→        \"#0086F0FA\",\n   739→        \"#838383\",\n   740→        \"#74B06F\",\n   741→        \"#4A90D9\",\n   742→        \"#E6A23C\",\n   743→        \"#9B59B6\",\n   744→        \"#E74C3C\",\n   745→        \"#202020\",\n   746→      ];\n   747→      const usedColors = new Set(groups.map((g) => g.color));\n   748→      const availableColors = palette.filter((c) => !usedColors.has(c));\n   749→      const color =\n   750→        availableColors.length > 0\n   751→          ? availableColors[0]\n   752→          : palette[groups.length % palette.length];\n   753→\n   754→      createGroupMutation.mutate(\n   755→        { name, color },\n   756→        {\n   757→          onSuccess: (newGroup) => {\n   758→            setSelectedGroupId(newGroup.id);\n   759→          },\n   760→        }\n   761→      );\n   762→    },\n   763→    [createGroupMutation, groups]\n   764→  );\n   765→\n   766→  const handleDeleteGroup = useCallback(\n   767→    (id: string) => {\n   768→      deleteGroupMutation.mutate({ id });\n   769→    },\n   770→    [deleteGroupMutation]\n   771→  );\n   772→\n   773→  const handleRenameBookmark = useCallback(\n   774→    (id: string, newTitle: string) => {\n   775→      updateBookmarkMutation.mutate({\n   776→        id,\n   777→        title: newTitle,\n   778→        _sourceGroupId: currentGroupId ?? undefined,\n   779→      });\n   780→    },\n   781→    [updateBookmarkMutation, currentGroupId]\n   782→  );\n   783→\n   784→  const handleMoveBookmark = useCallback(\n   785→    (id: string, targetGroupId: string) => {\n   786→      updateBookmarkMutation.mutate({\n   787→        id,\n   788→        groupId: targetGroupId,\n   789→        _sourceGroupId: currentGroupId ?? undefined,\n   790→      });\n   791→    },\n   792→    [updateBookmarkMutation, currentGroupId]\n   793→  );\n   794→\n   795→  const handleRefetchBookmark = useCallback(\n   796→    (id: string) => {\n   797→      refetchBookmarkMutation.mutate({ id });\n   798→    },\n   799→    [refetchBookmarkMutation]\n   800→  );\n   801→\n   802→  useEffect(() => {\n   803→    const handleKeyDown = (e: KeyboardEvent) => {\n   804→      if (renamingIdRef.current) return;\n   805→\n   806→      // Allow all keyboard events when focus is on the search input\n   807→      if (document.activeElement === inputRef.current) {\n   808→        return;\n   809→      }\n   810→\n   811→      // Allow standard text editing shortcuts when focus is on any input/textarea\n   812→      const isInputFocused =\n   813→        document.activeElement instanceof HTMLInputElement ||\n   814→        document.activeElement instanceof HTMLTextAreaElement;\n   815→      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n   816→        return;\n   817→      }\n   818→\n   819→      const bookmarks = filteredBookmarksRef.current;\n   820→      const inSelectionMode = selectionModeRef.current;\n   821→\n   822→      if (e.key === \"Escape\" && inSelectionMode) {\n   823→        e.preventDefault();\n   824→        handleExitSelectionMode();\n   825→        return;\n   826→      }\n   827→\n   828→      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n   829→        e.preventDefault();\n   830→        handleSelectAll();\n   831→        return;\n   832→      }\n   833→\n   834→      if (e.key === \"ArrowDown\") {\n   835→        e.preventDefault();\n   836→        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n   837→        return;\n   838→      }\n   839→      if (e.key === \"ArrowUp\") {\n   840→        e.preventDefault();\n   841→        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n   842→        return;\n   843→      }\n   844→\n   845→      const activeIndex =\n   846→        hoveredIndexRef.current >= 0\n   847→          ? hoveredIndexRef.current\n   848→          : selectedIndexRef.current;\n   849→      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n   850→      const activeBookmark = bookmarks[activeIndex];\n   851→      if (!activeBookmark) return;\n   852→\n   853→      if (e.key === \" \" && inSelectionMode) {\n   854→        e.preventDefault();\n   855→        handleToggleSelection(activeBookmark.id);\n   856→        return;\n   857→      }\n   858→\n   859→      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n   860→        e.preventDefault();\n   861→        if (activeBookmark.url) {\n   862→          window.open(activeBookmark.url, \"_blank\");\n   863→        } else {\n   864→          const textToCopy = activeBookmark.color || activeBookmark.title;\n   865→          navigator.clipboard.writeText(textToCopy ?? \"\");\n   866→        }\n   867→      }\n   868→\n   869→      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n   870→        e.preventDefault();\n   871→        const textToCopy =\n   872→          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n   873→        navigator.clipboard.writeText(textToCopy ?? \"\");\n   874→      }\n   875→\n   876→      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n   877→        e.preventDefault();\n   878→        handleStartRenameRef.current(activeBookmark.id);\n   879→      }\n   880→\n   881→      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n   882→        e.preventDefault();\n   883→        handleDeleteBookmarkRef.current(activeBookmark.id);\n   884→      }\n   885→    };\n   886→\n   887→    window.addEventListener(\"keydown\", handleKeyDown);\n   888→    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n   889→  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n   890→\n   891→  if (!selectedGroup) {\n   892→    return null;\n   893→  }\n   894→\n   895→  return (\n   896→    <div className=\"min-h-dvh bg-background\">\n   897→      <Header\n   898→        groups={groups}\n   899→        selectedGroup={selectedGroup}\n   900→        onSelectGroup={handleSelectGroup}\n   901→        onCreateGroup={handleCreateGroup}\n   902→        onDeleteGroup={handleDeleteGroup}\n   903→        userName={session.user.name}\n   904→        userEmail={session.user.email}\n   905→        onExport={handleOpenExportDialog}\n   906→      />\n   907→      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n   908→        <BookmarkInput\n   909→          ref={inputRef}\n   910→          value={searchQuery}\n   911→          onChange={handleSearchChange}\n   912→          onSubmit={handleAddBookmark}\n   913→        />\n   914→        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n   915→          <BookmarkListSkeleton />\n   916→        ) : (\n   917→          <BookmarkList\n   918→            bookmarks={filteredBookmarks}\n   919→            groups={groups}\n   920→            onDelete={handleDeleteBookmark}\n   921→            onRename={handleRenameBookmark}\n   922→            onMove={handleMoveBookmark}\n   923→            onRefetch={handleRefetchBookmark}\n   924→            currentGroupId={currentGroupId || \"\"}\n   925→            selectedIndex={selectedIndex}\n   926→            onSelect={setSelectedIndex}\n   927→            renamingId={renamingId}\n   928→            onStartRename={handleStartRename}\n   929→            onFinishRename={handleFinishRename}\n   930→            onHoverChange={setHoveredIndex}\n   931→            hoveredIndex={hoveredIndex}\n   932→            selectionMode={selectionMode}\n   933→            selectedIds={selectedIds}\n   934→            onToggleSelection={handleToggleSelection}\n   935→            onEnterSelectionMode={handleEnterSelectionMode}\n   936→            onBulkMove={handleConfirmMove}\n   937→            onBulkDelete={handleConfirmDelete}\n   938→          />\n   939→        )}\n   940→        {selectionMode && selectedIds.size > 0 && (\n   941→          <MultiSelectToolbar\n   942→            selectedCount={selectedIds.size}\n   943→            onSelectAll={handleSelectAll}\n   944→            onMove={() => setMoveDialogOpen(true)}\n   945→            onCopyUrls={handleCopyUrls}\n   946→            onExport={handleQuickExportAction}\n   947→            onDelete={() => setDeleteDialogOpen(true)}\n   948→            onClose={handleExitSelectionMode}\n   949→          />\n   950→        )}\n   951→        <BulkMoveDialog\n   952→          open={moveDialogOpen}\n   953→          onOpenChange={setMoveDialogOpen}\n   954→          groups={groups}\n   955→          currentGroupId={currentGroupId || \"\"}\n   956→          selectedCount={selectedIds.size}\n   957→          onConfirm={handleConfirmMove}\n   958→        />\n   959→        <BulkDeleteDialog\n   960→          open={deleteDialogOpen}\n   961→          onOpenChange={setDeleteDialogOpen}\n   962→          count={selectedIds.size}\n   963→          onConfirm={handleConfirmDelete}\n   964→        />\n   965→        <ExportDialog\n   966→          open={exportDialogOpen}\n   967→          onOpenChange={setExportDialogOpen}\n   968→          mode=\"settings\"\n   969→          bookmarks={allBookmarks}\n   970→          groups={groups}\n   971→        />\n   972→      </main>\n   973→    </div>\n   974→  );\n   975→}\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e15602f3-7c32-45f8-91b9-7b7ca61c0e81","timestamp":"2026-02-10T17:49:07.485Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/duncan/.REDACTED.txt","content":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\nimport { MultiSelectToolbar } from \"@/components/multi-select-toolbar\";\nimport { BulkMoveDialog } from \"@/components/bulk-move-dialog\";\nimport { BulkDeleteDialog } from \"@/components/bulk-delete-dialog\";\nimport { ExportDialog, handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl } from \"@/lib/utils\";\nimport { client } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n}\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [selectedGroupId, setSelectedGroupId] = useState<string | null>(null);\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    queryKey: [\"groups\"],\n    queryFn: () => client.group.list(),\n    initialData: initialGroups,\n    staleTime: 60 * 1000,\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  useFocusRefetch(groups);\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    queryKey: [\"bookmarks\", currentGroupId],\n    queryFn: () =>\n      client.bookmark.list({ groupId: currentGroupId ?? undefined }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    enabled: !!currentGroupId,\n    staleTime: 60 * 1000,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data]\n  );\n\n  const allBookmarksQuery = useQuery({\n    queryKey: [\"bookmarks\", \"all\"],\n    queryFn: () => client.bookmark.list({}),\n    enabled: exportDialogOpen,\n    staleTime: 60 * 1000,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data]\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    mutationFn: (data: {\n      title: string;\n      url?: string;\n      type: BookmarkType;\n      color?: string;\n      groupId: string;\n    }) => client.bookmark.create(data),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: [\"bookmarks\", newBookmark.groupId],\n      });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        newBookmark.groupId,\n      ]);\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type,\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        [\"bookmarks\", newBookmark.groupId],\n        (old) => [optimisticBookmark, ...(old || [])]\n      );\n\n      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g\n        )\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.groupId],\n          context.previousBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: [\"bookmarks\", variables.groupId],\n      });\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n\n      await queryClient.cancelQueries({ queryKey: [\"bookmarks\"] });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >([\"bookmarks\", _sourceGroupId]);\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >([\"bookmarks\", targetGroupId]);\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            [\"bookmarks\", _sourceGroupId],\n            (old) => old?.filter((b) => b.id !== id) ?? []\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            [\"bookmarks\", targetGroupId],\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ]\n          );\n\n          queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            })\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        sourceGroupId,\n      ]);\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        [\"bookmarks\", sourceGroupId],\n        (old) => old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? []\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.sourceGroupId],\n          context.previousSourceBookmarks\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.targetGroupId],\n          context.previousTargetBookmarks\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.sourceGroupId],\n          context.previousBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.sourceGroupId],\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.targetGroupId],\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n      const previousSelectedGroupId = selectedGroupId;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setSelectedGroupId(optimisticGroup.id);\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousSelectedGroupId,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      if (context?.previousSelectedGroupId !== undefined) {\n        setSelectedGroupId(context.previousSelectedGroupId);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    mutationFn: (data: { id: string }) => client.group.delete(data),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n      const previousSelectedGroupId = selectedGroupId;\n\n      queryClient.setQueryData<GroupItem[]>(\n        [\"groups\"],\n        (old) => old?.filter((g) => g.id !== data.id) ?? []\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setSelectedGroupId(remainingGroups[0]?.id ?? null);\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousSelectedGroupId, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      if (context?.previousSelectedGroupId !== undefined) {\n        setSelectedGroupId(context.previousSelectedGroupId);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string }) => client.bookmark.refetch(data),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: [\"bookmarks\"] });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: [\"bookmarks\", groupId] });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        groupId,\n      ]);\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        [\"bookmarks\", groupId],\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? []\n      );\n\n      queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n              ...g,\n              bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - data.ids.length),\n            }\n            : g\n        )\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.groupId],\n          context.previousBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.groupId],\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: [\"bookmarks\"] });\n      await queryClient.cancelQueries({ queryKey: [\"groups\"] });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        sourceGroupId,\n      ]);\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>([\n        \"bookmarks\",\n        targetGroupId,\n      ]);\n      const previousGroups = queryClient.getQueryData<GroupItem[]>([\"groups\"]);\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id)\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          [\"bookmarks\", sourceGroupId],\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? []\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          [\"bookmarks\", targetGroupId],\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ]\n        );\n\n        queryClient.setQueryData<GroupItem[]>([\"groups\"], (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + ids.length };\n            }\n            return g;\n          })\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.sourceGroupId],\n          context.previousSourceBookmarks\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData(\n          [\"bookmarks\", context.targetGroupId],\n          context.previousTargetBookmarks\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData([\"groups\"], context.previousGroups);\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.sourceGroupId],\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: [\"bookmarks\", context.targetGroupId],\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: [\"groups\"] });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId]\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode]\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [bulkDeleteMutation, selectedIds, currentGroupId, handleExitSelectionMode]);\n\n  const handleQuickExportAction = useCallback(\n    (format: \"csv\" | \"json\") => {\n      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n      handleExitSelectionMode();\n    },\n    [bookmarks, selectedIds, groups, handleExitSelectionMode]\n  );\n\n  const handleOpenExportDialog = useCallback(() => {\n    setExportDialogOpen(true);\n  }, []);\n\n  // Refs to store latest values for stable keyboard handler\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      setSelectedGroupId(id);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [handleExitSelectionMode]\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation]\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate(\n        { name, color },\n        {\n          onSuccess: (newGroup) => {\n            setSelectedGroupId(newGroup.id);\n          },\n        }\n      );\n    },\n    [createGroupMutation, groups]\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation]\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId]\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId]\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({ id });\n    },\n    [refetchBookmarkMutation]\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      // Allow all keyboard events when focus is on the search input\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      // Allow standard text editing shortcuts when focus is on any input/textarea\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        onExport={handleOpenExportDialog}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onExport={handleQuickExportAction}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n        <ExportDialog\n          open={exportDialogOpen}\n          onOpenChange={setExportDialogOpen}\n          mode=\"settings\"\n          bookmarks={allBookmarks}\n          groups={groups}\n        />\n      </main>\n    </div>\n  );\n}","numLines":975,"startLine":1,"totalLines":975}},"sourceToolAssistantUUID":"d54c61f3-64ef-4779-a3fe-5aab90170684"}
{"parentUuid":"e15602f3-7c32-45f8-91b9-7b7ca61c0e81","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01VWD1cmsvZshbajm7VCWUvA","toolUseID":"toolu_01VWD1cmsvZshbajm7VCWUvA","timestamp":"2026-02-10T17:49:07.485Z","uuid":"668f2472-8423-48dd-a688-0162453db560"}
{"parentUuid":"668f2472-8423-48dd-a688-0162453db560","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_012Xn39U8Phyk5EuTVXnDtZL","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have all versions from both branches. Let me now construct the merged versions:\n\n1. **`.claude/settings.local.json`** - Already resolved (took main's version)\n\n2. **`components/dashboard-content.tsx`** - Start from main's version, add:\n   - Import `ExportDialog, handleQuickExport` from `@/components/export-dialog`\n   - Add `exportDialogOpen` state\n   - Add `allBookmarksQuery` using orpc pattern\n   - Add `allBookmarks` memo\n   - Add `handleQuickExportAction` callback\n   - Add `handleOpenExportDialog` callback\n   - Pass `onExport` to Header and MultiSelectToolbar, then render `<ExportDialog>` at the bottom\n\n3. **`components/header.tsx`** - Start from main's version, add:\n   - `onExport?: () => void` to HeaderProps\n   - Destructure `onExport` and pass it to SettingsDialog\n\n4. **`components/multi-select-toolbar.tsx`** - Start from main's version, add:\n   - Export-related imports and the `onExport` prop handler\n   - Export dropdown menu between \"Copy URLs\" and visibility buttons with motion-reduce classes\n\n5. **`components/settings-dialog.tsx`** - Start from main's version, add:\n   - `onExport?: () => void` to SettingsDialogProps\n   - Add \"Data\" field with Export button in General tab\n\nNow I'm ready to write these files. I'll start from the main branch versions and integrate the export functionality across all of them. For dashboard-content.tsx, I need to pull in the dynamic import for ExportDialog and adapt the handleQuickExport logic from the feature branch.\n\nWriting component files... Setting up the query pattern... I'm setting up the merged files now. I'll use the content from the git show commands to write out the complete resolved versions directly rather than doing individual edits, which is more straightforward.\n\nFor dashboard-content.tsx, I need to integrate the export functionality by adding the import for `handleQuickExport` and the dynamic `ExportDialog`, setting up the `exportDialogOpen` state, creating the `allBookmarksQuery` and memoized `allBookmarks`, adding the `handleQuickExportAction` and `handleOpenExportDialog` callbacks, passing `onExport` to both Header and MultiSelectToolbar, and rendering the ExportDialog component at the bottom.\n\nFor header.tsx, I need to add the `onExport` prop and wire it to the export button click handler.\n\nFor multi-select-toolbar.tsx, I need to add the dropdown menu and export icon imports, add the `onExport` prop, create the export dropdown menu, and apply motion-reduce classes.\n\nFor settings-dialog.tsx, I need to add the `onExport` prop to the dialog props, destructure it, and add an Export button in the Data Field section of the General tab.\n\nWriting the merged files now...","signature":"EvAnCkYICxgCKkDNaB3rEixwSrZoP0Q+BsQVqCowTP6RuAjaS5cOVDa2GGz1O+AcxItTWU3H+rWFLGs53ZkHmWB9L8kn2hr/OjckEgwBHwIeI21lsNd/EBkaDI+BjLDdD1q+eAuiHSIwyvIwDFKQtKgB8kHBsNb/h3d7wJr16vQkzrf0wyMEITseqS1PKEdUaB5sgH7J8fJeKtcmAidNaj9QqiIuy4WbAAnqyCb16t5KMPQ1MVZFWZr+ED7NXm7GhRs1eBgrWIMqfMOuTkW3e4GTvGyj+hU2XWuXE2a9JmQD56p6knuv9F5dVxPj4/bTYXsSVe5kSi3bvmJfdFfAsdFZrW1m58B1r0itA4/b99P/iX3v3bZW9Gbnet6xf2/+i+BIVS1KntIhBX9iiAa+vevdg1Y8V3ZeyMpXEyZGlafcdyAFQXnYC2+pVwrkhWfLJR6Ub6bN6aXuN86WpW3DmgMJ6/7dUeLXrIOSA+2zy+6oNTxuV3aTuEMyLVH7DZLcIWZ4fTCleiIVLqQ2SbVavb9JpW0XCED83fCD3qLQwnflQ4EeTh5DUsWGeNmdQYsfHoFmOTqYswoYuo52Brz+RTeE9YU3aV0tpcuVEdU/kkm+SSjR9l/zKaUjcITOu2vr67MUo176sFytTvyvjtzL+8qolSK3dj0rxGKfF+G3RwllSNVAKJ2UdJBuaA/XKVttWOPt2TrDF8E1p4LxR6+JOurihxojdLy7JKHuxlsyawYNtP7NJr05euhLvisrlGCC+wT//+1/rN4a7jwcH3YncHhuQiE7dhPs19WCdBUL3tgsbj6DdObt86ukbz5Tb0VQKABNmeiwfpVFRLRXYtAKJad+Xmf6PvylT/YTXz5UUBthmPDzR44xXVyOsuRfWC+fobMPjHLq7G3etcNeHtfEqrZqfQ0eFu5jIewUFRy0xreMFZMGLrMFxTXtgcMRnTlefRgyFiHSRVupIBqr2qW5sZf9ODgN0Slp5TK6rsMIKQCA9TvlFkoKvRgh1yov8+Fa+3nOBFvs/nsnRKWyd/8UAJdWHXB3ejbZ3rpMUjg/7HmU8/wwujcl3zFHRGVda4BAsJceYRccug3p5ELi2YvTU+1z6LJ1tQ10B9HE8NwGWkCPRzmXCwr4clgbvX+CKEDOmCutry+vTtcPQ2mTdWiTHGe2KVhz3B94R4KlyetmWa5+/HtOWbqGJxsytSHE+0Z747RHhy4LFfBwnZaPe5i++ANVA5iblzSqZBB7BaI0/KnA0M39a+ZKiLO1xJUKN9tL8hGVmh77qI28hjaHnvL01FArmy8LuV0LOs5xiLoZ5XYA/PhsUtCJH3a6oPrkx2nF/RfFopYQ7/DYFMB1FJjEmdC3/VeBM0ZqB8VO9uRe71q0YeHJKy2IJ7iquEsNZ+0L4WOtI3y5p+v6Fm1qvX7lZiv+ORubYPdv9kD3vTkCTTl37V2AXSM6aReckj3+mEhKeBA9j8Txls7JecgVNKTgi/Hfp9hjJ4045ATuf93nYubUr0/SqtSUE1hbyweTxhOnK+Wrq3QL5WF+1BkOmHRcJvG4el/1IspvXuGHt+UnQcMoEVt91DXz7KcZx5NrdoEu+cxoAJoXeV5afXtlaqCnxWUSkegYPCp0yv+S2wEaW6SRGmzsrdL7jDs5/5q1QkFTwzdbSpHATavScHr+iqJCF6TJXY0pwDq44PsvMPvdPUaZsgCqNoXwLfn1EOKwgK0yoDIMduTEDSwwQYdwsFW+6/bk7c/dBL1VRl6wIEnkM+JlRRFaqcwrlpRN/gZCTyHXXJdb6v0R/CIFLWk+GGpdR7WweF7erXOaCigaZrZvsNSxWyssvb/4yfAVthIEU7oj47wl4o42G4Dz/kPwu9uOWCI0SwUr4EuQSE4B3dRgIEB2z05MnlQP9lF3RGUdTJKtjnuc353UJRz0bzGfeksoPDWLp/sCEhbpoz8vOwk4ysaFRHO8xmwegcHJKv6lUGbo11JIIulF60uQZfh7gsyJIVFIfneW/e9RCgOvRSi0yc2RFCCGawfoSjqPGfTNiloz8wjQGIX8dw/lNHN3v1addaLMK6YTGdAS78VYHLPs/ElaMI4TWzj8eKkmo2HUYmsR/cPQtJIvDxlurlbkEvwtZr2yIVt9MfbJPxUssAI4hKOVr7RgoN3es+lumOEBNA+Gt9KCY0YnegMQt7xMzw0SrK7mQezoTgQR6MghzlZK2f+B6i5t0ksci/wyJ979M5OfCtGVKSGJ8MayTHUSNc+LmZrn/RTDdqZ5TwFF/I3i4NvsQGjyaMMezL04QQpLA4nH+9A2C2odot+HrPuVE36Adk+NWiy2o7Z+749BRsXzAYCLid68SWyQNB0G4FofJlTmNAnkay/JE0ycXYEcxx0l7Go7QiJ46QXfzPYtSoy97BK169XHxkssR8FxMTwpZ4jStDLAOBTVtP/IcP0KxAIbyvEjwSL0GNtyFfD3pNGlWxgxdKrzLGW/Vr1rPpjUnqNj+5vlyVlXwH8MIccSdT3Nl10b9SeMZG7uwxoP1ZKjUgwU4k5HJJpYM7ButXQyCVjuJw3JMpHbZUe+pCjGjQDWlZGgxOhgD43SAKtTFlW0ENgqz0xnxZx1HPW9wZtI+O6a7gERWsQSb+z+XFscmnAMAn18OpFDXVjFVObDevlM1L9TpF1SVSw/ABRumAPAIdqw0kC1oaPwSFwQuiB/Qlh/HL34qPZ/98OKVQALB6JHEH2T0opM9hMIsbVRilIiXdwmz1GSIjsAiOeV7KMzLaYKfY+sdaxp/MI/KL+cv+n3sh5YNQrKb/YdcxRz4zlC+fMxF8DR200U43dM3bKjIWlj05NrC2yvY4shuW4sAkDT+Bml2BsRhQZkKtszphM96fk5gf9MoQpzgE8WNGMZKrj7fvVvBq8ZZpnRgug0aUyNFTjv5WreJfQcv3LKGPV70OggAyfGkK6IzgQOQF/GlZD6YvmdPQA87r+EKP/P6l9BBL19aOB30g7a3MYhx+gkjmovzZoDaIvQledXE9nXYkeuo0coI96/JJO5XAbjFwyqyx4LVDuroh20CfyuZrEnuuR/5jiKynRshzKek+kY9vvgT4vpHE1E4PaF5jo1LM1gds4fgyqW5ORDkv9GoHyN4p2AnZ2/rNmq+CA+5Ek+BjoVuUp96tvK6V+fg6qrB2ll0IXuGadvAiAJemRiyfPLfrU/X9ufD7OuPvU8CgwS9Yr8AjxGW4w/kEekmffZairmptwY7VkU7bl0eVFi/ITppLwgJGalj2ZwVAfyLZq29QZu7+TaMxa0ZEhB2E1y+RQjrA7N97Led6+7pS8yqoJMoATen9Z7i00m+6Jd7NQnBKaBzhXhfXa6/XLpHBaQk7p1wyOEM8AJq3bwy74ocuOwzS7PHsGTXrPH4dQTtfe2typ4nzIsAiOO/HdI+e6UFM/9wWeV9jfe4w9hr5tJZAi8bf+HEQ82puoMAMCL5qA5yhNe1KR1EoJYL1vHs8omR2Az3UQtlf3oJgXryt2MpbtK61yhu+EZqGw+OVIy9w65rEyBRbDxz8+L/Te2sPXzkTrWkSZrLauUbGJONb2HBp5D185ojUhZEQyUyQMnj9vZzAQiEqcm3Qxmza/1tj2DDH2zSJ0s8q82HVjHTSaSD7EA/1nCjJJUf+5TYZHRy82DX5da2eWlYmUv/8Imz3m8aIHq/ZmGdLM6g8ImTr0XmzX9PjMXsWPJyfkK/t65lIud4IiZ1UzFdEfc14OXJ6QbH9eBZPjl6Cu7cEWXFQABMOC/i6AMeLj9+kKLR+eLLmaGepWpZP1QxiYRtBqx+2LFtxOrxdMW3IydeSrMZ9QUQs9ad7n0k+9n/g2yLrgQKlSiv6CzBkFeiBM5QCMzLbMUeuP+uztwaC26bw/9IoILndK/cpELw1mMnR0MAkwsxsEs4J4iVD43terFpRQH3h/wqQpV9A4uYyvUL/Pednawa7AFyRfC+8+2UQb0auU7S3COlsPseEKa/BBKqVFBod1jZNc7LwwzlZiNowGBzemEg8S2APH0uWsoG4y6JIFajZIIF1DvBrci/EiSvftjmIX0zgu5U06GQAvlmALjhjH64NDFJ4XxDnaGDb4a4ADpe62//J2oO8tL1Bjz8KfO5yqmpIZjO9teSJeM5SgYEizN2mXe8tOPyKChCTTvhvOjLBH61H3/i45MXTima+wm35uJRU0qwdAQ55GG7InnAXR9mXZty2kd10WKsRKEIj9mAckRZDk8sHJOcLwKYltyNhKf5fU+YiNebjXQGR7mzGUEGAc8P3kEOzM8qyPEOxkz+vhYRtSp/ya3bXbq1kj+WNBxbWgYcoeGEkI0+bbq0eiKkk+vTc9HBpDRNm7+SPNpKAb4nx3givLEcaw6rGWt/ea/VOTv6jjfo4LFwiOwrL7g3xuEQfDx+/TJXCDwQfSlCp4NHssEnCQL76ps3AvnodKw+OHmvSAvW5pXMmXsahD6vdLUAGEjr4yfwV7r/edvSafE2THDaEMlXV7ESXESgpLZwuVECNJztoV4xjXOX3uObDIZYhbF3SugyFMS6qAKQWeHjRY4kAq+Ds0QcekcExGmfZhNzMrLm8bEZ38WyGfa2vqFDR8ojYPfy1KWnwIIx+D4S2+wydcq6kjF5RHm+CfgidyjKWJaVRrbU/NeLRk0beExg42XM7KboK8wGa1smdxIpgI7VmjydEagPYXvPagpYhdK6MYIFBNeG9f1sxcDup3mkyDXY+GD1yF+h92L5lvXq6e8vpwUXe/8MVDe2pAgAKzHUn835l7UJOHELoEBU1Y60MGT6RATOooqzCxLAF2CsWqeODaOwFJhyRdCKrng6LGAiXeWzKz7EfBQvO0P95c68am3FGLuHArLO9d6yahNnz+Lj6dds40/9flmTmLr+nZlf+clgp/sBK+efiiBeKyJnD6yiH/bGdY7y/4PeDIG96rVXPUwJNHOubCrq+Wz6uOyC+A1ZOZ1nKzkGwcWkpOCfyi/uXI9v1+iDOjUzo/DTwMUeLk+EKDJDAqpBrSMMOHbUxXb5m5pwfrXHpRK0FST+u9ZlpjUWK0es0YEaCmkuYyg+MfVDhE3GQz608ldUoIw0hsmHlBkPyXsff3vEYCwXMD1kz4y0/KLy917nUX9zKF/lzQmSlEfcnl3RpdPXTWaHBUNUOoFqBMPh6NHZCfPK1CKjIRSljC37RFvwQ/y+5yS5//KSUuMpR7okpDnSH+0IVNCvVWhMhdHTmgcxb1+X+x3AA6qT3q+3Ew4H6R8buJ2RQVKkOrC01giASkb8UM+AaWrVkv6m6fIZoftUVv0vP6JmX/rJh1fM5nrFYSC4NCGFqo+GMK087aBkv3HlN/IVyc9aTRw/vPZ8quEDd9De1uXIqhyqvME9d+mhGfaxNfVrcMbauZns/z4ISJpkHQ+9f5K949dE5uOcKcvwMYVnWLQk/gCq71jIAPd95xxjNd3mr/i7G3sNMlxpTEteuM9jxBk43xBPO+zGUIhwPJZMAeN0FPRtxSfuixMbdt5FsOx9M6hjoH2jw5O2H58vq/6tEIP5XQjs9jcfgdsRY+VaHpUAJksuwdRAyfkCQbMlR4JgOiKGxNXmX+fgnmEQdDieo6ZCdHE0sj8SwvZx949NhU4TvlXKZK8XsshZxxsSIMN+odOIGM5u2SjQbxozDbBwJ24xwaIZM7dC+hQR3TRPFzEv243NNPKD4OR5EPMTyniHeYN0T6IAXqHP/aQg8/Z+G8YGWuvHV75m6bphTXEyzjEgCnThwZJZZ85qkWTxphAI+4D23S6RbZcsmWP5kG1BaXpcDpVZTYE/zRYkLK0ilSaBlcxPJWKjNn0yAepeHv1XClwuHFX6y+mT2AANqsgJZCPkBefXiLxxdipHYOvBJPMi5pm7PJlY7g1YosU2Gu52h6ATrYgv8ga6+FoIExXKWEuTuuFoVMxBfIEmz2vtDovUD/XClNt/FR0j5CaEm0x10PG2x+7kMkeZ0SBrH0R09MFWxH89EveKayDQZo/p7Fop/T4b9D0AdNNi1GYEkvV3exKFE/4PRFR19GDlwheTVpYpOyzFAjSWpWh+vuhBfCMon/JN9I0zDAsb19bya7nJsWdGAKBvS9Szgxznn6Ng0xwpY5NxfxqynTfidM2kDFer/0xLB29IV1A60AQL4PuMAczlGUqDK8/99KDx5TvqyOc0naIF2c9cfWGH334CBVedGMbRGWhCgoJclsTlzxvLqc85SzvFCVsPrx1IwoQMGIBdc1AqqNmOx7pKFrEri7zUWsTvhG//t5QrjuDFnkUcDr0ryzc2COCfHoNOxVZiRto6zkLJEiZdenlTBcqQBq9C4+ineue1+j+p/AnZ+NPyn2DzuGRsYNkOVpOq5ykc+CT98F0cz2p5+3gA8KRdadIcBan0FMveYi51EsJOsKDJz7VNt7GJhTCHcCUZ33LM/CzhotCccwToc+yFUNtaXuATCr/7TTgHg4IImGid+lqqHMbd4NJT4Yb924GIKN7chmuQ3oDoDNW9UpuGGjcLGg1WIFxnO6fdHJr7bUKjPIL2vIHHJZe5IeHeGqJGIOxZS0K0U/TiKsD7NfEoiS7otwq+peLxZ+GXPkw4R1DoCTufCYXHauGLr3SOb8/XMxaBIyfygHIb3QlZXJkvQjRtcjh8z08yDXOa1WQ9wD3xYwxvL2H9uUCW3yf0zNbZ2Bd95kJVl3fyCu1nieD0xUa3ONp7efhpwEcWGj0qZ+thwSXHPkmSxHc3/Xp+prk+6l9Q7gWNzaD3IVmHqUpGn9BVvzNxX5smrxNfbeyqSe4xl3wLwYvVBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34237,"cache_creation_input_tokens":13651,"cache_read_input_tokens":51204,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13651},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzowQBxMuaXoTfK4A1Mw","type":"assistant","uuid":"d7dc7398-5cea-4811-b7b5-df3ef4b039d4","timestamp":"2026-02-10T17:49:37.124Z"}
{"parentUuid":"d7dc7398-5cea-4811-b7b5-df3ef4b039d4","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_012Xn39U8Phyk5EuTVXnDtZL","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have all the content from both branches. Let me resolve each file. I'll start from main's version for each conflicting component and graft in the export features."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34237,"cache_creation_input_tokens":13651,"cache_read_input_tokens":51204,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13651},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzowQBxMuaXoTfK4A1Mw","type":"assistant","uuid":"f72a9948-b075-45de-b1aa-8ad1bda5cb5c","timestamp":"2026-02-10T17:49:37.299Z"}
{"parentUuid":"f72a9948-b075-45de-b1aa-8ad1bda5cb5c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_012Xn39U8Phyk5EuTVXnDtZL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GzDuQbRXDbjUqmvLQXG19i","name":"Bash","input":{"command":"git checkout main -- components/dashboard-content.tsx components/header.tsx components/multi-select-toolbar.tsx components/settings-dialog.tsx","description":"Reset all conflicting component files to main's version"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34237,"cache_creation_input_tokens":13651,"cache_read_input_tokens":51204,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":13651},"output_tokens":8,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzowQBxMuaXoTfK4A1Mw","type":"assistant","uuid":"672e783a-598c-45b8-ba52-7cbb1036a2fc","timestamp":"2026-02-10T17:49:37.726Z"}
{"parentUuid":"672e783a-598c-45b8-ba52-7cbb1036a2fc","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GzDuQbRXDbjUqmvLQXG19i","type":"tool_result","content":"","is_error":false}]},"uuid":"a8f35843-d166-4e6a-a665-45951a8c480d","timestamp":"2026-02-10T17:49:37.991Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"672e783a-598c-45b8-ba52-7cbb1036a2fc"}
{"parentUuid":"a8f35843-d166-4e6a-a665-45951a8c480d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01Uz8Sb1rqnykM36iLf7D3Ez","type":"message","role":"assistant","content":[{"type":"text","text":"Good, now all 4 component files are main's version. Let me graft the export features into each one. I'll read and edit them:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":35870,"cache_read_input_tokens":64855,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":35870},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzoyfMKzC1uzwWurmZ2q","type":"assistant","uuid":"7416bb32-9792-489d-91e6-f2b1c88c57b8","timestamp":"2026-02-10T17:49:42.018Z"}
{"parentUuid":"7416bb32-9792-489d-91e6-f2b1c88c57b8","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01Uz8Sb1rqnykM36iLf7D3Ez","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T5rnbzcSZFTkewQkR1pfFX","name":"Read","input":{"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":35870,"cache_read_input_tokens":64855,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":35870},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzoyfMKzC1uzwWurmZ2q","type":"assistant","uuid":"b2659673-3d93-4227-842f-6213f48fb01d","timestamp":"2026-02-10T17:49:42.658Z"}
{"parentUuid":"b2659673-3d93-4227-842f-6213f48fb01d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T5rnbzcSZFTkewQkR1pfFX","type":"tool_result","content":"     1→\"use client\";\n     2→\n     3→import { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\n     4→import { useQueryState } from \"nuqs\";\n     5→import { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\n     6→import { toast } from \"sonner\";\n     7→import dynamic from \"next/dynamic\";\n     8→import { Header } from \"@/components/header\";\n     9→import { BookmarkInput } from \"@/components/bookmark-input\";\n    10→import { BookmarkList } from \"@/components/bookmark-list\";\n    11→import { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n    12→\n    13→const MultiSelectToolbar = dynamic(\n    14→  () =>\n    15→    import(\"@/components/multi-select-toolbar\").then(\n    16→      (m) => m.MultiSelectToolbar,\n    17→    ),\n    18→  { ssr: false },\n    19→);\n    20→const BulkMoveDialog = dynamic(\n    21→  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n    22→  { ssr: false },\n    23→);\n    24→const BulkDeleteDialog = dynamic(\n    25→  () =>\n    26→    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n    27→  { ssr: false },\n    28→);\n    29→import { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\n    30→import { client, orpc } from \"@/lib/orpc\";\n    31→import { useDebounce } from \"@/hooks/use-debounce\";\n    32→import { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\n    33→import { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\n    34→import type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\n    35→import type { Session } from \"@/lib/auth\";\n    36→\n    37→export interface ProfileData {\n    38→  image: string | null;\n    39→  username: string | null;\n    40→  bio: string | null;\n    41→  github: string | null;\n    42→  twitter: string | null;\n    43→  website: string | null;\n    44→  isProfilePublic: boolean;\n    45→}\n    46→\n    47→interface DashboardContentProps {\n    48→  session: NonNullable<Session>;\n    49→  initialGroups: GroupItem[];\n    50→  initialBookmarks: BookmarkItem[];\n    51→  profile: ProfileData;\n    52→}\n    53→\n    54→const groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\n    55→const bookmarkListKey = (groupId?: string | null) =>\n    56→  orpc.bookmark.list.queryKey({\n    57→    input: { groupId: groupId ?? undefined },\n    58→  }) as readonly unknown[];\n    59→\n    60→export function DashboardContent({\n    61→  session,\n    62→  initialGroups,\n    63→  initialBookmarks,\n    64→  profile,\n    65→}: DashboardContentProps) {\n    66→  const queryClient = useQueryClient();\n    67→\n    68→  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n    69→  const [searchQuery, setSearchQuery] = useState(\"\");\n    70→  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n    71→  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n    72→  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n    73→  const inputRef = useRef<HTMLInputElement>(null);\n    74→  const [renamingId, setRenamingId] = useState<string | null>(null);\n    75→  const [selectionMode, setSelectionMode] = useState(false);\n    76→  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n    77→  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n    78→  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n    79→\n    80→  const groupsQuery = useQuery({\n    81→    ...orpc.group.list.queryOptions(),\n    82→    initialData: initialGroups,\n    83→    initialDataUpdatedAt: Date.now(),\n    84→  });\n    85→\n    86→  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n    87→\n    88→  const hasUsername = profile.username !== null;\n    89→  const publicGroupIds = useMemo(\n    90→    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    91→    [groups],\n    92→  );\n    93→\n    94→  useFocusRefetch(groups);\n    95→\n    96→  const groupIdBySlug = useMemo(\n    97→    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    98→    [groups],\n    99→  );\n   100→  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n   101→\n   102→  const selectedGroupId = groupSlug\n   103→    ? (groupIdBySlug.get(groupSlug) ?? null)\n   104→    : null;\n   105→\n   106→  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n   107→\n   108→  const bookmarksQuery = useQuery({\n   109→    ...orpc.bookmark.list.queryOptions({\n   110→      input: { groupId: currentGroupId ?? undefined },\n   111→    }),\n   112→    initialData:\n   113→      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n   114→    initialDataUpdatedAt: Date.now(),\n   115→    enabled: !!currentGroupId,\n   116→  });\n   117→\n   118→  const bookmarks = useMemo(\n   119→    () => bookmarksQuery.data ?? [],\n   120→    [bookmarksQuery.data],\n   121→  );\n   122→\n   123→  useEffect(() => {\n   124→    setSelectedIndex(-1);\n   125→    setHoveredIndex(-1);\n   126→  }, [bookmarks, currentGroupId]);\n   127→\n   128→  const createBookmarkMutation = useMutation({\n   129→    ...orpc.bookmark.create.mutationOptions(),\n   130→    onMutate: async (newBookmark) => {\n   131→      await queryClient.cancelQueries({\n   132→        queryKey: orpc.bookmark.list.queryKey({\n   133→          input: { groupId: newBookmark.groupId },\n   134→        }),\n   135→      });\n   136→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   137→\n   138→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   139→        bookmarkListKey(newBookmark.groupId),\n   140→      );\n   141→      const previousGroups =\n   142→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   143→\n   144→      const optimisticBookmark: BookmarkItem = {\n   145→        id: `temp-${Date.now()}`,\n   146→        title: newBookmark.title,\n   147→        url: newBookmark.url || null,\n   148→        favicon: null,\n   149→        type: newBookmark.type ?? \"link\",\n   150→        color: newBookmark.color || null,\n   151→        groupId: newBookmark.groupId,\n   152→        createdAt: new Date().toISOString(),\n   153→      };\n   154→\n   155→      queryClient.setQueryData<BookmarkItem[]>(\n   156→        bookmarkListKey(newBookmark.groupId),\n   157→        (old) => [optimisticBookmark, ...(old || [])],\n   158→      );\n   159→\n   160→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   161→        old?.map((g) =>\n   162→          g.id === newBookmark.groupId\n   163→            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n   164→            : g,\n   165→        ),\n   166→      );\n   167→\n   168→      return {\n   169→        previousBookmarks,\n   170→        previousGroups,\n   171→        groupId: newBookmark.groupId,\n   172→      };\n   173→    },\n   174→    onError: (_err, _newBookmark, context) => {\n   175→      if (context?.previousBookmarks) {\n   176→        queryClient.setQueryData<BookmarkItem[]>(\n   177→          bookmarkListKey(context.groupId),\n   178→          context.previousBookmarks,\n   179→        );\n   180→      }\n   181→      if (context?.previousGroups) {\n   182→        queryClient.setQueryData<GroupItem[]>(\n   183→          groupListKey(),\n   184→          context.previousGroups,\n   185→        );\n   186→      }\n   187→      toast.error(\"Failed to create bookmark\");\n   188→    },\n   189→    onSettled: (_data, _error, variables) => {\n   190→      queryClient.invalidateQueries({\n   191→        queryKey: orpc.bookmark.list.key({\n   192→          input: { groupId: variables.groupId },\n   193→        }),\n   194→      });\n   195→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   196→    },\n   197→  });\n   198→\n   199→  const updateBookmarkMutation = useMutation({\n   200→    mutationFn: async (data: {\n   201→      id: string;\n   202→      title?: string;\n   203→      url?: string;\n   204→      type?: BookmarkType;\n   205→      color?: string;\n   206→      groupId?: string;\n   207→      _sourceGroupId?: string;\n   208→    }) => {\n   209→      if (data.id.startsWith(\"temp-\")) {\n   210→        return { id: data.id, title: data.title ?? \"\" } as Pick<\n   211→          BookmarkItem,\n   212→          \"id\" | \"title\"\n   213→        >;\n   214→      }\n   215→      const { _sourceGroupId, ...updateData } = data;\n   216→      return client.bookmark.update(updateData);\n   217→    },\n   218→    onMutate: async (data) => {\n   219→      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n   220→      const isMove =\n   221→        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n   222→      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n   223→\n   224→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   225→      await queryClient.cancelQueries({\n   226→        queryKey: orpc.bookmark.list.queryKey({\n   227→          input: { groupId: sourceGroupId ?? undefined },\n   228→        }),\n   229→      });\n   230→      if (isMove) {\n   231→        await queryClient.cancelQueries({\n   232→          queryKey: orpc.bookmark.list.queryKey({\n   233→            input: { groupId: targetGroupId },\n   234→          }),\n   235→        });\n   236→      }\n   237→\n   238→      const previousGroups =\n   239→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   240→\n   241→      if (isMove) {\n   242→        const previousSourceBookmarks = queryClient.getQueryData<\n   243→          BookmarkItem[]\n   244→        >(bookmarkListKey(_sourceGroupId));\n   245→        const previousTargetBookmarks = queryClient.getQueryData<\n   246→          BookmarkItem[]\n   247→        >(bookmarkListKey(targetGroupId));\n   248→\n   249→        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n   250→\n   251→        if (movedBookmark) {\n   252→          queryClient.setQueryData<BookmarkItem[]>(\n   253→            bookmarkListKey(_sourceGroupId),\n   254→            (old) => old?.filter((b) => b.id !== id) ?? [],\n   255→          );\n   256→\n   257→          queryClient.setQueryData<BookmarkItem[]>(\n   258→            bookmarkListKey(targetGroupId),\n   259→            (old) => [\n   260→              { ...movedBookmark, groupId: targetGroupId },\n   261→              ...(old ?? []),\n   262→            ],\n   263→          );\n   264→\n   265→          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   266→            old?.map((g) => {\n   267→              if (g.id === _sourceGroupId) {\n   268→                return {\n   269→                  ...g,\n   270→                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n   271→                };\n   272→              }\n   273→              if (g.id === targetGroupId) {\n   274→                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n   275→              }\n   276→              return g;\n   277→            }),\n   278→          );\n   279→        }\n   280→\n   281→        return {\n   282→          previousSourceBookmarks,\n   283→          previousTargetBookmarks,\n   284→          previousGroups,\n   285→          sourceGroupId: _sourceGroupId,\n   286→          targetGroupId,\n   287→        };\n   288→      }\n   289→\n   290→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   291→        bookmarkListKey(sourceGroupId),\n   292→      );\n   293→\n   294→      queryClient.setQueryData<BookmarkItem[]>(\n   295→        bookmarkListKey(sourceGroupId),\n   296→        (old) =>\n   297→          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n   298→      );\n   299→\n   300→      return { previousBookmarks, sourceGroupId, previousGroups };\n   301→    },\n   302→    onError: (_err, data, context) => {\n   303→      if (\n   304→        context?.previousSourceBookmarks !== undefined &&\n   305→        context?.sourceGroupId\n   306→      ) {\n   307→        queryClient.setQueryData<BookmarkItem[]>(\n   308→          bookmarkListKey(context.sourceGroupId),\n   309→          context.previousSourceBookmarks,\n   310→        );\n   311→      }\n   312→      if (\n   313→        context?.previousTargetBookmarks !== undefined &&\n   314→        context?.targetGroupId\n   315→      ) {\n   316→        queryClient.setQueryData<BookmarkItem[]>(\n   317→          bookmarkListKey(context.targetGroupId),\n   318→          context.previousTargetBookmarks,\n   319→        );\n   320→      }\n   321→      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n   322→        queryClient.setQueryData<BookmarkItem[]>(\n   323→          bookmarkListKey(context.sourceGroupId),\n   324→          context.previousBookmarks,\n   325→        );\n   326→      }\n   327→      if (context?.previousGroups) {\n   328→        queryClient.setQueryData<GroupItem[]>(\n   329→          groupListKey(),\n   330→          context.previousGroups,\n   331→        );\n   332→      }\n   333→      toast.error(\"Failed to update bookmark\");\n   334→    },\n   335→    onSettled: (_data, _error, data, context) => {\n   336→      if (context?.sourceGroupId) {\n   337→        queryClient.invalidateQueries({\n   338→          queryKey: orpc.bookmark.list.key({\n   339→            input: { groupId: context.sourceGroupId },\n   340→          }),\n   341→        });\n   342→      }\n   343→      if (context?.targetGroupId) {\n   344→        queryClient.invalidateQueries({\n   345→          queryKey: orpc.bookmark.list.key({\n   346→            input: { groupId: context.targetGroupId },\n   347→          }),\n   348→        });\n   349→      }\n   350→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   351→    },\n   352→  });\n   353→\n   354→  const createGroupMutation = useMutation({\n   355→    mutationFn: (data: {\n   356→      name: string;\n   357→      color: string;\n   358→      _optimisticId?: string;\n   359→    }) => {\n   360→      const { _optimisticId, ...createData } = data;\n   361→      return client.group.create(createData);\n   362→    },\n   363→    onMutate: async (newGroup) => {\n   364→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   365→\n   366→      const previousGroups =\n   367→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   368→      const previousGroupSlug = groupSlug;\n   369→\n   370→      const optimisticGroup: GroupItem = {\n   371→        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n   372→        name: newGroup.name,\n   373→        color: newGroup.color,\n   374→        bookmarkCount: 0,\n   375→      };\n   376→\n   377→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n   378→        ...(old ?? []),\n   379→        optimisticGroup,\n   380→      ]);\n   381→\n   382→      setGroupSlug(slugify(newGroup.name));\n   383→      setSelectedIndex(-1);\n   384→\n   385→      return {\n   386→        previousGroups,\n   387→        previousGroupSlug,\n   388→        optimisticId: optimisticGroup.id,\n   389→      };\n   390→    },\n   391→    onError: (_err, _newGroup, context) => {\n   392→      if (context?.previousGroups) {\n   393→        queryClient.setQueryData<GroupItem[]>(\n   394→          groupListKey(),\n   395→          context.previousGroups,\n   396→        );\n   397→      }\n   398→      if (context?.previousGroupSlug !== undefined) {\n   399→        setGroupSlug(context.previousGroupSlug);\n   400→      }\n   401→      toast.error(\"Failed to create group\");\n   402→    },\n   403→    onSettled: () => {\n   404→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   405→    },\n   406→  });\n   407→\n   408→  const deleteGroupMutation = useMutation({\n   409→    ...orpc.group.delete.mutationOptions(),\n   410→    onMutate: async (data) => {\n   411→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   412→\n   413→      const previousGroups =\n   414→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   415→      const previousGroupSlug = groupSlug;\n   416→\n   417→      queryClient.setQueryData<GroupItem[]>(\n   418→        groupListKey(),\n   419→        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n   420→      );\n   421→\n   422→      if (currentGroupId === data.id) {\n   423→        const remainingGroups =\n   424→          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n   425→        setGroupSlug(\n   426→          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n   427→        );\n   428→        setSelectedIndex(-1);\n   429→      }\n   430→\n   431→      return { previousGroups, previousGroupSlug, deletedId: data.id };\n   432→    },\n   433→    onError: (_err, _data, context) => {\n   434→      if (context?.previousGroups) {\n   435→        queryClient.setQueryData<GroupItem[]>(\n   436→          groupListKey(),\n   437→          context.previousGroups,\n   438→        );\n   439→      }\n   440→      if (context?.previousGroupSlug !== undefined) {\n   441→        setGroupSlug(context.previousGroupSlug);\n   442→      }\n   443→      toast.error(\"Failed to delete group\");\n   444→    },\n   445→    onSettled: () => {\n   446→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   447→    },\n   448→  });\n   449→\n   450→  const refetchBookmarkMutation = useMutation({\n   451→    mutationFn: (data: { id: string; groupId?: string }) =>\n   452→      client.bookmark.refetch({ id: data.id }),\n   453→    onSuccess: (_data, variables) => {\n   454→      queryClient.invalidateQueries({\n   455→        queryKey: orpc.bookmark.list.key({\n   456→          input: { groupId: variables.groupId },\n   457→        }),\n   458→      });\n   459→      toast.success(\"Metadata refreshed\");\n   460→    },\n   461→    onError: () => {\n   462→      toast.error(\"Failed to refresh metadata\");\n   463→    },\n   464→  });\n   465→\n   466→  const bulkDeleteMutation = useMutation({\n   467→    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n   468→      const { _groupId, ...deleteData } = data;\n   469→      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n   470→      if (realIds.length === 0) {\n   471→        return { success: true };\n   472→      }\n   473→      return client.bookmark.bulkDelete({ ids: realIds });\n   474→    },\n   475→    onMutate: async (data) => {\n   476→      const groupId = data._groupId ?? currentGroupId;\n   477→\n   478→      await queryClient.cancelQueries({\n   479→        queryKey: orpc.bookmark.list.queryKey({\n   480→          input: { groupId: groupId ?? undefined },\n   481→        }),\n   482→      });\n   483→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   484→\n   485→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   486→        bookmarkListKey(groupId),\n   487→      );\n   488→      const previousGroups =\n   489→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   490→\n   491→      queryClient.setQueryData<BookmarkItem[]>(\n   492→        bookmarkListKey(groupId),\n   493→        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n   494→      );\n   495→\n   496→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   497→        old?.map((g) =>\n   498→          g.id === groupId\n   499→            ? {\n   500→                ...g,\n   501→                bookmarkCount: Math.max(\n   502→                  0,\n   503→                  (g.bookmarkCount ?? 0) - data.ids.length,\n   504→                ),\n   505→              }\n   506→            : g,\n   507→        ),\n   508→      );\n   509→\n   510→      return { previousBookmarks, previousGroups, groupId };\n   511→    },\n   512→    onError: (_err, _data, context) => {\n   513→      if (context?.previousBookmarks) {\n   514→        queryClient.setQueryData<BookmarkItem[]>(\n   515→          bookmarkListKey(context.groupId),\n   516→          context.previousBookmarks,\n   517→        );\n   518→      }\n   519→      if (context?.previousGroups) {\n   520→        queryClient.setQueryData<GroupItem[]>(\n   521→          groupListKey(),\n   522→          context.previousGroups,\n   523→        );\n   524→      }\n   525→      toast.error(\"Failed to delete bookmarks\");\n   526→    },\n   527→    onSettled: (_data, _error, _variables, context) => {\n   528→      if (context?.groupId) {\n   529→        queryClient.invalidateQueries({\n   530→          queryKey: orpc.bookmark.list.key({\n   531→            input: { groupId: context.groupId },\n   532→          }),\n   533→        });\n   534→      }\n   535→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   536→    },\n   537→  });\n   538→\n   539→  const bulkMoveMutation = useMutation({\n   540→    mutationFn: (data: {\n   541→      ids: string[];\n   542→      targetGroupId: string;\n   543→      _sourceGroupId?: string;\n   544→    }) => {\n   545→      const { _sourceGroupId, ...moveData } = data;\n   546→      return client.bookmark.bulkMove(moveData);\n   547→    },\n   548→    onMutate: async (data) => {\n   549→      const { ids, targetGroupId, _sourceGroupId } = data;\n   550→      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n   551→\n   552→      await queryClient.cancelQueries({\n   553→        queryKey: orpc.bookmark.list.queryKey({\n   554→          input: { groupId: sourceGroupId ?? undefined },\n   555→        }),\n   556→      });\n   557→      await queryClient.cancelQueries({\n   558→        queryKey: orpc.bookmark.list.queryKey({\n   559→          input: { groupId: targetGroupId },\n   560→        }),\n   561→      });\n   562→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   563→\n   564→      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   565→        bookmarkListKey(sourceGroupId),\n   566→      );\n   567→      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   568→        bookmarkListKey(targetGroupId),\n   569→      );\n   570→      const previousGroups =\n   571→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   572→\n   573→      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n   574→        ids.includes(b.id),\n   575→      );\n   576→\n   577→      if (movedBookmarks) {\n   578→        queryClient.setQueryData<BookmarkItem[]>(\n   579→          bookmarkListKey(sourceGroupId),\n   580→          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n   581→        );\n   582→\n   583→        queryClient.setQueryData<BookmarkItem[]>(\n   584→          bookmarkListKey(targetGroupId),\n   585→          (old) => [\n   586→            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n   587→            ...(old ?? []),\n   588→          ],\n   589→        );\n   590→\n   591→        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   592→          old?.map((g) => {\n   593→            if (g.id === sourceGroupId) {\n   594→              return {\n   595→                ...g,\n   596→                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n   597→              };\n   598→            }\n   599→            if (g.id === targetGroupId) {\n   600→              return {\n   601→                ...g,\n   602→                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n   603→              };\n   604→            }\n   605→            return g;\n   606→          }),\n   607→        );\n   608→      }\n   609→\n   610→      return {\n   611→        previousSourceBookmarks,\n   612→        previousTargetBookmarks,\n   613→        previousGroups,\n   614→        sourceGroupId,\n   615→        targetGroupId,\n   616→      };\n   617→    },\n   618→    onError: (_err, _data, context) => {\n   619→      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n   620→        queryClient.setQueryData<BookmarkItem[]>(\n   621→          bookmarkListKey(context.sourceGroupId),\n   622→          context.previousSourceBookmarks,\n   623→        );\n   624→      }\n   625→      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n   626→        queryClient.setQueryData<BookmarkItem[]>(\n   627→          bookmarkListKey(context.targetGroupId),\n   628→          context.previousTargetBookmarks,\n   629→        );\n   630→      }\n   631→      if (context?.previousGroups) {\n   632→        queryClient.setQueryData<GroupItem[]>(\n   633→          groupListKey(),\n   634→          context.previousGroups,\n   635→        );\n   636→      }\n   637→      toast.error(\"Failed to move bookmarks\");\n   638→    },\n   639→    onSettled: (_data, _error, _variables, context) => {\n   640→      if (context?.sourceGroupId) {\n   641→        queryClient.invalidateQueries({\n   642→          queryKey: orpc.bookmark.list.key({\n   643→            input: { groupId: context.sourceGroupId },\n   644→          }),\n   645→        });\n   646→      }\n   647→      if (context?.targetGroupId) {\n   648→        queryClient.invalidateQueries({\n   649→          queryKey: orpc.bookmark.list.key({\n   650→            input: { groupId: context.targetGroupId },\n   651→          }),\n   652→        });\n   653→      }\n   654→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   655→    },\n   656→  });\n   657→\n   658→  const setVisibilityMutation = useMutation({\n   659→    ...orpc.bookmark.setVisibility.mutationOptions(),\n   660→    onMutate: async (data) => {\n   661→      const groupId = currentGroupId;\n   662→      await queryClient.cancelQueries({\n   663→        queryKey: orpc.bookmark.list.queryKey({\n   664→          input: { groupId: groupId ?? undefined },\n   665→        }),\n   666→      });\n   667→\n   668→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   669→        bookmarkListKey(groupId),\n   670→      );\n   671→\n   672→      queryClient.setQueryData<BookmarkItem[]>(\n   673→        bookmarkListKey(groupId),\n   674→        (old) =>\n   675→          old?.map((b) =>\n   676→            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n   677→          ) ?? [],\n   678→      );\n   679→\n   680→      return { previousBookmarks, groupId };\n   681→    },\n   682→    onError: (_err, _data, context) => {\n   683→      if (context?.previousBookmarks && context?.groupId) {\n   684→        queryClient.setQueryData<BookmarkItem[]>(\n   685→          bookmarkListKey(context.groupId),\n   686→          context.previousBookmarks,\n   687→        );\n   688→      }\n   689→      toast.error(\"Failed to update visibility\");\n   690→    },\n   691→    onSettled: (_data, _error, _variables, context) => {\n   692→      if (context?.groupId) {\n   693→        queryClient.invalidateQueries({\n   694→          queryKey: orpc.bookmark.list.key({\n   695→            input: { groupId: context.groupId },\n   696→          }),\n   697→        });\n   698→      }\n   699→    },\n   700→  });\n   701→\n   702→  const bulkSetVisibilityMutation = useMutation({\n   703→    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n   704→    onMutate: async (data) => {\n   705→      const groupId = currentGroupId;\n   706→      await queryClient.cancelQueries({\n   707→        queryKey: orpc.bookmark.list.queryKey({\n   708→          input: { groupId: groupId ?? undefined },\n   709→        }),\n   710→      });\n   711→\n   712→      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n   713→        bookmarkListKey(groupId),\n   714→      );\n   715→\n   716→      queryClient.setQueryData<BookmarkItem[]>(\n   717→        bookmarkListKey(groupId),\n   718→        (old) =>\n   719→          old?.map((b) =>\n   720→            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n   721→          ) ?? [],\n   722→      );\n   723→\n   724→      return { previousBookmarks, groupId };\n   725→    },\n   726→    onError: (_err, _data, context) => {\n   727→      if (context?.previousBookmarks && context?.groupId) {\n   728→        queryClient.setQueryData<BookmarkItem[]>(\n   729→          bookmarkListKey(context.groupId),\n   730→          context.previousBookmarks,\n   731→        );\n   732→      }\n   733→      toast.error(\"Failed to update visibility\");\n   734→    },\n   735→    onSettled: (_data, _error, _variables, context) => {\n   736→      if (context?.groupId) {\n   737→        queryClient.invalidateQueries({\n   738→          queryKey: orpc.bookmark.list.key({\n   739→            input: { groupId: context.groupId },\n   740→          }),\n   741→        });\n   742→      }\n   743→    },\n   744→  });\n   745→\n   746→  const setGroupVisibilityMutation = useMutation({\n   747→    ...orpc.group.setVisibility.mutationOptions(),\n   748→    onMutate: async (data) => {\n   749→      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n   750→\n   751→      const previousGroups =\n   752→        queryClient.getQueryData<GroupItem[]>(groupListKey());\n   753→\n   754→      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n   755→        old?.map((g) =>\n   756→          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n   757→        ),\n   758→      );\n   759→\n   760→      return { previousGroups };\n   761→    },\n   762→    onSuccess: (_data, variables) => {\n   763→      toast.success(\n   764→        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n   765→      );\n   766→    },\n   767→    onError: (_err, _data, context) => {\n   768→      if (context?.previousGroups) {\n   769→        queryClient.setQueryData<GroupItem[]>(\n   770→          groupListKey(),\n   771→          context.previousGroups,\n   772→        );\n   773→      }\n   774→      toast.error(\"Failed to update group visibility\");\n   775→    },\n   776→    onSettled: () => {\n   777→      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n   778→    },\n   779→  });\n   780→\n   781→  const selectedGroup =\n   782→    groups.find((g) => g.id === currentGroupId) || groups[0];\n   783→\n   784→  const handleStartRename = (id: string) => {\n   785→    setRenamingId(id);\n   786→  };\n   787→\n   788→  const handleFinishRename = () => {\n   789→    setRenamingId(null);\n   790→  };\n   791→\n   792→  const handleDeleteBookmark = useCallback(\n   793→    (id: string) => {\n   794→      bulkDeleteMutation.mutate({\n   795→        ids: [id],\n   796→        _groupId: currentGroupId ?? undefined,\n   797→      });\n   798→    },\n   799→    [bulkDeleteMutation, currentGroupId],\n   800→  );\n   801→\n   802→  const filteredBookmarks = useMemo(() => {\n   803→    return bookmarks.filter((b) => {\n   804→      if (!debouncedSearchQuery) return true;\n   805→      return (\n   806→        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n   807→        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n   808→      );\n   809→    });\n   810→  }, [bookmarks, debouncedSearchQuery]);\n   811→\n   812→  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n   813→    setSelectionMode(true);\n   814→    if (initialId) {\n   815→      setSelectedIds(new Set([initialId]));\n   816→    }\n   817→  }, []);\n   818→\n   819→  const handleExitSelectionMode = useCallback(() => {\n   820→    setSelectionMode(false);\n   821→    setSelectedIds(new Set());\n   822→  }, []);\n   823→\n   824→  const handleToggleSelection = useCallback((id: string) => {\n   825→    setSelectedIds((prev) => {\n   826→      const next = new Set(prev);\n   827→      if (next.has(id)) {\n   828→        next.delete(id);\n   829→      } else {\n   830→        next.add(id);\n   831→      }\n   832→      return next;\n   833→    });\n   834→  }, []);\n   835→\n   836→  const handleSelectAll = useCallback(() => {\n   837→    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n   838→  }, [filteredBookmarks]);\n   839→\n   840→  const handleCopyUrls = useCallback(() => {\n   841→    const urls = bookmarks\n   842→      .filter((b) => selectedIds.has(b.id) && b.url)\n   843→      .map((b) => b.url)\n   844→      .join(\"\\n\");\n   845→\n   846→    if (urls) {\n   847→      navigator.clipboard.writeText(urls);\n   848→      toast.success(`Copied ${selectedIds.size} URLs`);\n   849→    } else {\n   850→      toast.error(\"No URLs to copy\");\n   851→    }\n   852→  }, [bookmarks, selectedIds]);\n   853→\n   854→  const handleConfirmMove = useCallback(\n   855→    (targetGroupId: string) => {\n   856→      bulkMoveMutation.mutate({\n   857→        ids: Array.from(selectedIds),\n   858→        targetGroupId,\n   859→        _sourceGroupId: currentGroupId ?? undefined,\n   860→      });\n   861→      handleExitSelectionMode();\n   862→      toast.success(`Moved ${selectedIds.size} bookmarks`);\n   863→    },\n   864→    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n   865→  );\n   866→\n   867→  const handleConfirmDelete = useCallback(() => {\n   868→    bulkDeleteMutation.mutate({\n   869→      ids: Array.from(selectedIds),\n   870→      _groupId: currentGroupId ?? undefined,\n   871→    });\n   872→    handleExitSelectionMode();\n   873→    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n   874→  }, [\n   875→    bulkDeleteMutation,\n   876→    selectedIds,\n   877→    currentGroupId,\n   878→    handleExitSelectionMode,\n   879→  ]);\n   880→\n   881→  // Refs to store latest values for stable keyboard handler\n   882→  const groupsRef = useLatestRef(groups);\n   883→  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n   884→  const selectedIndexRef = useLatestRef(selectedIndex);\n   885→  const hoveredIndexRef = useLatestRef(hoveredIndex);\n   886→  const renamingIdRef = useLatestRef(renamingId);\n   887→  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n   888→  const handleStartRenameRef = useLatestRef(handleStartRename);\n   889→  const selectionModeRef = useLatestRef(selectionMode);\n   890→  const selectedIdsRef = useLatestRef(selectedIds);\n   891→\n   892→  const handleSearchChange = useCallback((value: string) => {\n   893→    setSearchQuery(value);\n   894→    setSelectedIndex(-1);\n   895→  }, []);\n   896→\n   897→  const handleSelectGroup = useCallback(\n   898→    (id: string) => {\n   899→      const group = groupsRef.current.find((g) => g.id === id);\n   900→      setGroupSlug(group ? slugify(group.name) : null);\n   901→      setSelectedIndex(-1);\n   902→      handleExitSelectionMode();\n   903→    },\n   904→    [setGroupSlug, handleExitSelectionMode],\n   905→  );\n   906→\n   907→  const handleAddBookmark = useCallback(\n   908→    (value: string) => {\n   909→      if (!currentGroupId) return;\n   910→\n   911→      const trimmedValue = value.trim();\n   912→      if (!trimmedValue) return;\n   913→\n   914→      const colorResult = parseColor(trimmedValue);\n   915→\n   916→      if (colorResult.isColor) {\n   917→        createBookmarkMutation.mutate({\n   918→          title: colorResult.original || trimmedValue,\n   919→          url: \"\",\n   920→          type: \"color\",\n   921→          color: colorResult.hex,\n   922→          groupId: currentGroupId,\n   923→        });\n   924→      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n   925→        const url = normalizeUrl(trimmedValue);\n   926→        createBookmarkMutation.mutate({\n   927→          title: new URL(url).hostname.replace(\"www.\", \"\"),\n   928→          url,\n   929→          type: \"link\",\n   930→          groupId: currentGroupId,\n   931→        });\n   932→      } else {\n   933→        createBookmarkMutation.mutate({\n   934→          title: trimmedValue,\n   935→          url: \"\",\n   936→          type: \"text\",\n   937→          groupId: currentGroupId,\n   938→        });\n   939→      }\n   940→\n   941→      setSearchQuery(\"\");\n   942→      setSelectedIndex(-1);\n   943→    },\n   944→    [currentGroupId, createBookmarkMutation],\n   945→  );\n   946→\n   947→  const handleCreateGroup = useCallback(\n   948→    (name: string) => {\n   949→      const palette = [\n   950→        \"#3E63DD\",\n   951→        \"#208368\",\n   952→        \"#FFDC00\",\n   953→        \"#CE2C31\",\n   954→        \"#53195D\",\n   955→        \"#0086F0FA\",\n   956→        \"#838383\",\n   957→        \"#74B06F\",\n   958→        \"#4A90D9\",\n   959→        \"#E6A23C\",\n   960→        \"#9B59B6\",\n   961→        \"#E74C3C\",\n   962→        \"#202020\",\n   963→      ];\n   964→      const usedColors = new Set(groups.map((g) => g.color));\n   965→      const availableColors = palette.filter((c) => !usedColors.has(c));\n   966→      const color =\n   967→        availableColors.length > 0\n   968→          ? availableColors[0]\n   969→          : palette[groups.length % palette.length];\n   970→\n   971→      createGroupMutation.mutate({ name, color });\n   972→    },\n   973→    [createGroupMutation, groups],\n   974→  );\n   975→\n   976→  const handleDeleteGroup = useCallback(\n   977→    (id: string) => {\n   978→      deleteGroupMutation.mutate({ id });\n   979→    },\n   980→    [deleteGroupMutation],\n   981→  );\n   982→\n   983→  const handleRenameBookmark = useCallback(\n   984→    (id: string, newTitle: string) => {\n   985→      updateBookmarkMutation.mutate({\n   986→        id,\n   987→        title: newTitle,\n   988→        _sourceGroupId: currentGroupId ?? undefined,\n   989→      });\n   990→    },\n   991→    [updateBookmarkMutation, currentGroupId],\n   992→  );\n   993→\n   994→  const handleMoveBookmark = useCallback(\n   995→    (id: string, targetGroupId: string) => {\n   996→      updateBookmarkMutation.mutate({\n   997→        id,\n   998→        groupId: targetGroupId,\n   999→        _sourceGroupId: currentGroupId ?? undefined,\n  1000→      });\n  1001→    },\n  1002→    [updateBookmarkMutation, currentGroupId],\n  1003→  );\n  1004→\n  1005→  const handleRefetchBookmark = useCallback(\n  1006→    (id: string) => {\n  1007→      refetchBookmarkMutation.mutate({\n  1008→        id,\n  1009→        groupId: currentGroupId ?? undefined,\n  1010→      });\n  1011→    },\n  1012→    [refetchBookmarkMutation, currentGroupId],\n  1013→  );\n  1014→\n  1015→  const handleToggleBookmarkVisibility = useCallback(\n  1016→    (id: string, currentIsPublic: boolean | null | undefined) => {\n  1017→      const isInPublicGroup = currentGroupId\n  1018→        ? publicGroupIds.has(currentGroupId)\n  1019→        : false;\n  1020→      const isEffectivelyPublic =\n  1021→        currentIsPublic === true ||\n  1022→        (isInPublicGroup && currentIsPublic !== false);\n  1023→\n  1024→      if (isEffectivelyPublic) {\n  1025→        setVisibilityMutation.mutate({\n  1026→          id,\n  1027→          isPublic: isInPublicGroup ? false : null,\n  1028→        });\n  1029→        toast.success(\"Bookmark hidden from public profile\");\n  1030→      } else {\n  1031→        setVisibilityMutation.mutate({ id, isPublic: true });\n  1032→        toast.success(\"Bookmark visible on public profile\");\n  1033→      }\n  1034→    },\n  1035→    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  1036→  );\n  1037→\n  1038→  const handleBulkMakePublic = useCallback(() => {\n  1039→    bulkSetVisibilityMutation.mutate({\n  1040→      ids: Array.from(selectedIds),\n  1041→      isPublic: true,\n  1042→    });\n  1043→    handleExitSelectionMode();\n  1044→    toast.success(`${selectedIds.size} bookmarks made public`);\n  1045→  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n  1046→\n  1047→  const handleBulkMakePrivate = useCallback(() => {\n  1048→    const isInPublicGroup = currentGroupId\n  1049→      ? publicGroupIds.has(currentGroupId)\n  1050→      : false;\n  1051→    bulkSetVisibilityMutation.mutate({\n  1052→      ids: Array.from(selectedIds),\n  1053→      isPublic: isInPublicGroup ? false : null,\n  1054→    });\n  1055→    handleExitSelectionMode();\n  1056→    toast.success(`${selectedIds.size} bookmarks made private`);\n  1057→  }, [\n  1058→    bulkSetVisibilityMutation,\n  1059→    selectedIds,\n  1060→    currentGroupId,\n  1061→    publicGroupIds,\n  1062→    handleExitSelectionMode,\n  1063→  ]);\n  1064→\n  1065→  const handleToggleGroupVisibility = useCallback(\n  1066→    (id: string, isPublic: boolean) => {\n  1067→      setGroupVisibilityMutation.mutate({ id, isPublic });\n  1068→    },\n  1069→    [setGroupVisibilityMutation],\n  1070→  );\n  1071→\n  1072→  useEffect(() => {\n  1073→    const handleKeyDown = (e: KeyboardEvent) => {\n  1074→      if (renamingIdRef.current) return;\n  1075→\n  1076→      if (document.activeElement === inputRef.current) {\n  1077→        return;\n  1078→      }\n  1079→\n  1080→      const isInputFocused =\n  1081→        document.activeElement instanceof HTMLInputElement ||\n  1082→        document.activeElement instanceof HTMLTextAreaElement;\n  1083→      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n  1084→        return;\n  1085→      }\n  1086→\n  1087→      const bookmarks = filteredBookmarksRef.current;\n  1088→      const inSelectionMode = selectionModeRef.current;\n  1089→\n  1090→      if (e.key === \"Escape\" && inSelectionMode) {\n  1091→        e.preventDefault();\n  1092→        handleExitSelectionMode();\n  1093→        return;\n  1094→      }\n  1095→\n  1096→      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n  1097→        e.preventDefault();\n  1098→        handleSelectAll();\n  1099→        return;\n  1100→      }\n  1101→\n  1102→      if (e.key === \"ArrowDown\") {\n  1103→        e.preventDefault();\n  1104→        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n  1105→        return;\n  1106→      }\n  1107→      if (e.key === \"ArrowUp\") {\n  1108→        e.preventDefault();\n  1109→        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n  1110→        return;\n  1111→      }\n  1112→\n  1113→      const activeIndex =\n  1114→        hoveredIndexRef.current >= 0\n  1115→          ? hoveredIndexRef.current\n  1116→          : selectedIndexRef.current;\n  1117→      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n  1118→      const activeBookmark = bookmarks[activeIndex];\n  1119→      if (!activeBookmark) return;\n  1120→\n  1121→      if (e.key === \" \" && inSelectionMode) {\n  1122→        e.preventDefault();\n  1123→        handleToggleSelection(activeBookmark.id);\n  1124→        return;\n  1125→      }\n  1126→\n  1127→      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n  1128→        e.preventDefault();\n  1129→        if (activeBookmark.url) {\n  1130→          window.open(activeBookmark.url, \"_blank\");\n  1131→        } else {\n  1132→          const textToCopy = activeBookmark.color || activeBookmark.title;\n  1133→          navigator.clipboard.writeText(textToCopy ?? \"\");\n  1134→        }\n  1135→      }\n  1136→\n  1137→      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n  1138→        e.preventDefault();\n  1139→        const textToCopy =\n  1140→          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n  1141→        navigator.clipboard.writeText(textToCopy ?? \"\");\n  1142→      }\n  1143→\n  1144→      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n  1145→        e.preventDefault();\n  1146→        handleStartRenameRef.current(activeBookmark.id);\n  1147→      }\n  1148→\n  1149→      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n  1150→        e.preventDefault();\n  1151→        handleDeleteBookmarkRef.current(activeBookmark.id);\n  1152→      }\n  1153→    };\n  1154→\n  1155→    window.addEventListener(\"keydown\", handleKeyDown);\n  1156→    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  1157→  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n  1158→\n  1159→  if (!selectedGroup) {\n  1160→    return null;\n  1161→  }\n  1162→\n  1163→  return (\n  1164→    <div className=\"min-h-dvh bg-background\">\n  1165→      <Header\n  1166→        groups={groups}\n  1167→        selectedGroup={selectedGroup}\n  1168→        onSelectGroup={handleSelectGroup}\n  1169→        onCreateGroup={handleCreateGroup}\n  1170→        onDeleteGroup={handleDeleteGroup}\n  1171→        onToggleGroupVisibility={\n  1172→          hasUsername ? handleToggleGroupVisibility : undefined\n  1173→        }\n  1174→        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n  1175→        userName={session.user.name}\n  1176→        userEmail={session.user.email}\n  1177→        userImage={profile.image}\n  1178→        username={profile.username}\n  1179→        profile={profile}\n  1180→      />\n  1181→      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n  1182→        <BookmarkInput\n  1183→          ref={inputRef}\n  1184→          value={searchQuery}\n  1185→          onChange={handleSearchChange}\n  1186→          onSubmit={handleAddBookmark}\n  1187→        />\n  1188→        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n  1189→          <BookmarkListSkeleton />\n  1190→        ) : (\n  1191→          <BookmarkList\n  1192→            bookmarks={filteredBookmarks}\n  1193→            groups={groups}\n  1194→            onDelete={handleDeleteBookmark}\n  1195→            onRename={handleRenameBookmark}\n  1196→            onMove={handleMoveBookmark}\n  1197→            onRefetch={handleRefetchBookmark}\n  1198→            currentGroupId={currentGroupId || \"\"}\n  1199→            selectedIndex={selectedIndex}\n  1200→            onSelect={setSelectedIndex}\n  1201→            renamingId={renamingId}\n  1202→            onStartRename={handleStartRename}\n  1203→            onFinishRename={handleFinishRename}\n  1204→            onHoverChange={setHoveredIndex}\n  1205→            hoveredIndex={hoveredIndex}\n  1206→            selectionMode={selectionMode}\n  1207→            selectedIds={selectedIds}\n  1208→            onToggleSelection={handleToggleSelection}\n  1209→            onEnterSelectionMode={handleEnterSelectionMode}\n  1210→            onBulkMove={handleConfirmMove}\n  1211→            onBulkDelete={handleConfirmDelete}\n  1212→            hasUsername={hasUsername}\n  1213→            publicGroupIds={publicGroupIds}\n  1214→            onToggleVisibility={handleToggleBookmarkVisibility}\n  1215→          />\n  1216→        )}\n  1217→        {selectionMode && selectedIds.size > 0 && (\n  1218→          <MultiSelectToolbar\n  1219→            selectedCount={selectedIds.size}\n  1220→            onSelectAll={handleSelectAll}\n  1221→            onMove={() => setMoveDialogOpen(true)}\n  1222→            onCopyUrls={handleCopyUrls}\n  1223→            onDelete={() => setDeleteDialogOpen(true)}\n  1224→            onClose={handleExitSelectionMode}\n  1225→            hasUsername={hasUsername}\n  1226→            onMakePublic={\n  1227→              currentGroupId && publicGroupIds.has(currentGroupId)\n  1228→                ? undefined\n  1229→                : handleBulkMakePublic\n  1230→            }\n  1231→            onMakePrivate={\n  1232→              currentGroupId && publicGroupIds.has(currentGroupId)\n  1233→                ? handleBulkMakePrivate\n  1234→                : undefined\n  1235→            }\n  1236→          />\n  1237→        )}\n  1238→        <BulkMoveDialog\n  1239→          open={moveDialogOpen}\n  1240→          onOpenChange={setMoveDialogOpen}\n  1241→          groups={groups}\n  1242→          currentGroupId={currentGroupId || \"\"}\n  1243→          selectedCount={selectedIds.size}\n  1244→          onConfirm={handleConfirmMove}\n  1245→        />\n  1246→        <BulkDeleteDialog\n  1247→          open={deleteDialogOpen}\n  1248→          onOpenChange={setDeleteDialogOpen}\n  1249→          count={selectedIds.size}\n  1250→          onConfirm={handleConfirmDelete}\n  1251→        />\n  1252→      </main>\n  1253→    </div>\n  1254→  );\n  1255→}\n  1256→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"abdf65c1-4acc-4d42-8130-543b77ce6500","timestamp":"2026-02-10T17:49:43.246Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","content":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","numLines":1256,"startLine":1,"totalLines":1256}},"sourceToolAssistantUUID":"b2659673-3d93-4227-842f-6213f48fb01d"}
{"parentUuid":"abdf65c1-4acc-4d42-8130-543b77ce6500","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01T5rnbzcSZFTkewQkR1pfFX","toolUseID":"toolu_01T5rnbzcSZFTkewQkR1pfFX","timestamp":"2026-02-10T17:49:43.247Z","uuid":"532b084b-6fa5-4915-915d-8d51cb6c2c0f"}
{"parentUuid":"532b084b-6fa5-4915-915d-8d51cb6c2c0f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01X1yGkK1ZxYEDsp3CMkkDzT","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me apply all the export grafts to the 4 files in parallel:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":15731,"cache_read_input_tokens":100725,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15731},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzoz7Kn3kMa7H3tcCKzc","type":"assistant","uuid":"32f8046f-eded-41d2-852b-958862ef271a","timestamp":"2026-02-10T17:49:47.650Z"}
{"parentUuid":"32f8046f-eded-41d2-852b-958862ef271a","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01X1yGkK1ZxYEDsp3CMkkDzT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UDkRhhaxctgqG8yVWiscbn","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"const BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);","new_string":"const BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":15731,"cache_read_input_tokens":100725,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15731},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzoz7Kn3kMa7H3tcCKzc","type":"assistant","uuid":"92e42d36-b70f-43f4-b49e-98d4a101807c","timestamp":"2026-02-10T17:49:50.409Z"}
{"parentUuid":"92e42d36-b70f-43f4-b49e-98d4a101807c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01X1yGkK1ZxYEDsp3CMkkDzT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nj4kMUCihU4PMmHFTfyWev","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"import { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";","new_string":"import { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":15731,"cache_read_input_tokens":100725,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":15731},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzoz7Kn3kMa7H3tcCKzc","type":"assistant","uuid":"4b114180-587a-4a33-8039-01b6c1352b08","timestamp":"2026-02-10T17:49:52.172Z"}
{"parentUuid":"4b114180-587a-4a33-8039-01b6c1352b08","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01X1yGkK1ZxYEDsp3CMkkDzT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CZL3SkdD7DGAGonjEt7Xkw","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);","new_string":"  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":15731,"cache_read_input_tokens":100725,"output_tokens":609,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":15731,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXzoz7Kn3kMa7H3tcCKzc","type":"assistant","uuid":"39b08819-c11e-49e4-889e-c2bd7a6d0a76","timestamp":"2026-02-10T17:49:53.646Z"}
{"type":"file-history-snapshot","messageId":"92e42d36-b70f-43f4-b49e-98d4a101807c","snapshot":{"messageId":"06123b67-0019-4aec-aa67-ba0dfdf62319","trackedFileBackups":{"components/dashboard-content.tsx":{"backupFileName":"d30ebca3ed1ec74d@v1","version":1,"backupTime":"2026-02-10T17:49:53.671Z"}},"timestamp":"2026-02-10T17:48:34.297Z"},"isSnapshotUpdate":true}
{"parentUuid":"92e42d36-b70f-43f4-b49e-98d4a101807c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UDkRhhaxctgqG8yVWiscbn","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"9ab37fb0-8359-4bf7-90d8-3767b2886f9b","timestamp":"2026-02-10T17:49:53.676Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"const BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);","newString":"const BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":26,"oldLines":6,"newStart":26,"newLines":10,"lines":["     import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),","   { ssr: false },"," );","+const ExportDialog = dynamic(","+  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),","+  { ssr: false },","+);"," import { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";"," import { client, orpc } from \"@/lib/orpc\";"," import { useDebounce } from \"@/hooks/use-debounce\";"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"92e42d36-b70f-43f4-b49e-98d4a101807c"}
{"parentUuid":"9ab37fb0-8359-4bf7-90d8-3767b2886f9b","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01UDkRhhaxctgqG8yVWiscbn","toolUseID":"toolu_01UDkRhhaxctgqG8yVWiscbn","timestamp":"2026-02-10T17:49:53.677Z","uuid":"1d7f6f6d-23b2-4ac1-926a-30a48c3f186a"}
{"parentUuid":"4b114180-587a-4a33-8039-01b6c1352b08","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Nj4kMUCihU4PMmHFTfyWev","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"8ced84ea-a316-4273-9ec3-ac2da7a6e537","timestamp":"2026-02-10T17:49:53.703Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"import { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";","newString":"import { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":30,"oldLines":6,"newStart":30,"newLines":7,"lines":["   () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),","   { ssr: false },"," );","+import { handleQuickExport } from \"@/components/export-dialog\";"," import { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";"," import { client, orpc } from \"@/lib/orpc\";"," import { useDebounce } from \"@/hooks/use-debounce\";"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"4b114180-587a-4a33-8039-01b6c1352b08"}
{"parentUuid":"8ced84ea-a316-4273-9ec3-ac2da7a6e537","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Nj4kMUCihU4PMmHFTfyWev","toolUseID":"toolu_01Nj4kMUCihU4PMmHFTfyWev","timestamp":"2026-02-10T17:49:53.703Z","uuid":"6e99a206-4522-4d6e-9ea2-9cd00a45ff2b"}
{"parentUuid":"39b08819-c11e-49e4-889e-c2bd7a6d0a76","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CZL3SkdD7DGAGonjEt7Xkw","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"ca1e0f8f-f6cc-4b4e-a5c6-00ea4c369d7a","timestamp":"2026-02-10T17:49:53.713Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);","newString":"  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);\nimport { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":81,"oldLines":6,"newStart":81,"newLines":7,"lines":["   const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());","   const [moveDialogOpen, setMoveDialogOpen] = useState(false);","   const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);","+  const [exportDialogOpen, setExportDialogOpen] = useState(false);"," ","   const groupsQuery = useQuery({","     ...orpc.group.list.queryOptions(),"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"39b08819-c11e-49e4-889e-c2bd7a6d0a76"}
{"parentUuid":"ca1e0f8f-f6cc-4b4e-a5c6-00ea4c369d7a","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01CZL3SkdD7DGAGonjEt7Xkw","toolUseID":"toolu_01CZL3SkdD7DGAGonjEt7Xkw","timestamp":"2026-02-10T17:49:53.713Z","uuid":"9ad4670d-fd76-4937-8dc2-1cde0ace3dff"}
{"parentUuid":"9ad4670d-fd76-4937-8dc2-1cde0ace3dff","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_012QErrKfTR5nw5d3U7GPckU","type":"message","role":"assistant","content":[{"type":"text","text":"Now add the `allBookmarksQuery`, `allBookmarks` memo, and the export callbacks:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":851,"cache_read_input_tokens":116456,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":851},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzozsc3q7Mxzqwi14yGZ","type":"assistant","uuid":"2a685169-46ee-4d48-8fbd-45a54d2ebe5c","timestamp":"2026-02-10T17:49:58.126Z"}
{"parentUuid":"2a685169-46ee-4d48-8fbd-45a54d2ebe5c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_012QErrKfTR5nw5d3U7GPckU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LW5xBzw2b1hzhonyehnp9o","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {","new_string":"  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  const allBookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: {},\n    }),\n    enabled: exportDialogOpen,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data],\n  );\n\n  useEffect(() => {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":851,"cache_read_input_tokens":116456,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":851},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzozsc3q7Mxzqwi14yGZ","type":"assistant","uuid":"1f978543-d98c-4da2-beb8-8ec8b7985e57","timestamp":"2026-02-10T17:50:01.155Z"}
{"parentUuid":"1f978543-d98c-4da2-beb8-8ec8b7985e57","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_012QErrKfTR5nw5d3U7GPckU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UREAFuw38sEQb3sg8w6bQx","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler","new_string":"  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  const handleQuickExportAction = useCallback(\n    (format: \"csv\" | \"json\") => {\n      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n      handleExitSelectionMode();\n    },\n    [bookmarks, selectedIds, groups, handleExitSelectionMode],\n  );\n\n  const handleOpenExportDialog = useCallback(() => {\n    setExportDialogOpen(true);\n  }, []);\n\n  // Refs to store latest values for stable keyboard handler"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":851,"cache_read_input_tokens":116456,"output_tokens":808,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":851,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXzozsc3q7Mxzqwi14yGZ","type":"assistant","uuid":"2845cf04-362c-4020-bce8-15939d37b387","timestamp":"2026-02-10T17:50:06.377Z"}
{"parentUuid":"1f978543-d98c-4da2-beb8-8ec8b7985e57","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LW5xBzw2b1hzhonyehnp9o","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"e1ad686b-02b6-4d2c-829b-7a4b05b19b30","timestamp":"2026-02-10T17:50:06.513Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {","newString":"  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  const allBookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: {},\n    }),\n    enabled: exportDialogOpen,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data],\n  );\n\n  useEffect(() => {","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);\nimport { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":126,"oldLines":6,"newStart":126,"newLines":18,"lines":["     [bookmarksQuery.data],","   );"," ","+  const allBookmarksQuery = useQuery({","+    ...orpc.bookmark.list.queryOptions({","+      input: {},","+    }),","+    enabled: exportDialogOpen,","+  });","+","+  const allBookmarks = useMemo(","+    () => allBookmarksQuery.data ?? [],","+    [allBookmarksQuery.data],","+  );","+","   useEffect(() => {","     setSelectedIndex(-1);","     setHoveredIndex(-1);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"1f978543-d98c-4da2-beb8-8ec8b7985e57"}
{"parentUuid":"e1ad686b-02b6-4d2c-829b-7a4b05b19b30","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01LW5xBzw2b1hzhonyehnp9o","toolUseID":"toolu_01LW5xBzw2b1hzhonyehnp9o","timestamp":"2026-02-10T17:50:06.514Z","uuid":"bca110ae-1651-42a6-ab64-0f44ed118d58"}
{"parentUuid":"2845cf04-362c-4020-bce8-15939d37b387","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UREAFuw38sEQb3sg8w6bQx","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"9a193938-9a79-42cc-84c4-99f7586eecb2","timestamp":"2026-02-10T17:50:06.539Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler","newString":"  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  const handleQuickExportAction = useCallback(\n    (format: \"csv\" | \"json\") => {\n      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n      handleExitSelectionMode();\n    },\n    [bookmarks, selectedIds, groups, handleExitSelectionMode],\n  );\n\n  const handleOpenExportDialog = useCallback(() => {\n    setExportDialogOpen(true);\n  }, []);\n\n  // Refs to store latest values for stable keyboard handler","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);\nimport { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  const allBookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: {},\n    }),\n    enabled: exportDialogOpen,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":896,"oldLines":6,"newStart":896,"newLines":19,"lines":["     handleExitSelectionMode,","   ]);"," ","+  const handleQuickExportAction = useCallback(","+    (format: \"csv\" | \"json\") => {","+      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));","+      handleQuickExport(format, bookmarks, selectedIds, groupsMap);","+      handleExitSelectionMode();","+    },","+    [bookmarks, selectedIds, groups, handleExitSelectionMode],","+  );","+","+  const handleOpenExportDialog = useCallback(() => {","+    setExportDialogOpen(true);","+  }, []);","+","   // Refs to store latest values for stable keyboard handler","   const groupsRef = useLatestRef(groups);","   const filteredBookmarksRef = useLatestRef(filteredBookmarks);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"2845cf04-362c-4020-bce8-15939d37b387"}
{"parentUuid":"9a193938-9a79-42cc-84c4-99f7586eecb2","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01UREAFuw38sEQb3sg8w6bQx","toolUseID":"toolu_01UREAFuw38sEQb3sg8w6bQx","timestamp":"2026-02-10T17:50:06.539Z","uuid":"b9c89d23-90d2-42ce-be6f-8e61409184d6"}
{"parentUuid":"b9c89d23-90d2-42ce-be6f-8e61409184d6","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01DCKYjQhnh2fRuAbvJhAXUz","type":"message","role":"assistant","content":[{"type":"text","text":"Now add `onExport` to the Header and MultiSelectToolbar, and render ExportDialog:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1057,"cache_read_input_tokens":117307,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1057},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp1roi73FGANLXDgCD4","type":"assistant","uuid":"7b407314-e0c7-467b-99eb-1bfc5f3b73a3","timestamp":"2026-02-10T17:50:11.693Z"}
{"parentUuid":"7b407314-e0c7-467b-99eb-1bfc5f3b73a3","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01DCKYjQhnh2fRuAbvJhAXUz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013698QfoRuN2bGXQKtnxSfH","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"        username={profile.username}\n        profile={profile}\n      />","new_string":"        username={profile.username}\n        profile={profile}\n        onExport={handleOpenExportDialog}\n      />"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1057,"cache_read_input_tokens":117307,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1057},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp1roi73FGANLXDgCD4","type":"assistant","uuid":"31cd901d-179f-4ba9-b118-c8f6b5a9f3da","timestamp":"2026-02-10T17:50:12.969Z"}
{"parentUuid":"31cd901d-179f-4ba9-b118-c8f6b5a9f3da","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01DCKYjQhnh2fRuAbvJhAXUz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M3mWjVn94drb3dzcAiUUKS","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}","new_string":"            onCopyUrls={handleCopyUrls}\n            onExport={handleQuickExportAction}\n            onDelete={() => setDeleteDialogOpen(true)}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1057,"cache_read_input_tokens":117307,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1057},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp1roi73FGANLXDgCD4","type":"assistant","uuid":"496995ea-7a82-4453-a02d-edffba7c4f0d","timestamp":"2026-02-10T17:50:14.727Z"}
{"parentUuid":"496995ea-7a82-4453-a02d-edffba7c4f0d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01DCKYjQhnh2fRuAbvJhAXUz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0166YdqdfMkJYXDAP4yuFeD5","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","old_string":"        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>","new_string":"        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n        <ExportDialog\n          open={exportDialogOpen}\n          onOpenChange={setExportDialogOpen}\n          mode=\"settings\"\n          bookmarks={allBookmarks}\n          groups={groups}\n        />\n      </main>"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1057,"cache_read_input_tokens":117307,"output_tokens":637,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1057,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXzp1roi73FGANLXDgCD4","type":"assistant","uuid":"5cebccdb-186d-4f5c-9c23-9b9be1ee7f6e","timestamp":"2026-02-10T17:50:18.388Z"}
{"parentUuid":"31cd901d-179f-4ba9-b118-c8f6b5a9f3da","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013698QfoRuN2bGXQKtnxSfH","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"518751e4-20ed-44b2-bb6c-1c680a8238f6","timestamp":"2026-02-10T17:50:18.413Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"        username={profile.username}\n        profile={profile}\n      />","newString":"        username={profile.username}\n        profile={profile}\n        onExport={handleOpenExportDialog}\n      />","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);\nimport { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  const allBookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: {},\n    }),\n    enabled: exportDialogOpen,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  const handleQuickExportAction = useCallback(\n    (format: \"csv\" | \"json\") => {\n      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n      handleExitSelectionMode();\n    },\n    [bookmarks, selectedIds, groups, handleExitSelectionMode],\n  );\n\n  const handleOpenExportDialog = useCallback(() => {\n    setExportDialogOpen(true);\n  }, []);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":1208,"oldLines":6,"newStart":1208,"newLines":7,"lines":["         userImage={profile.image}","         username={profile.username}","         profile={profile}","+        onExport={handleOpenExportDialog}","       />","       <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">","         <BookmarkInput"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"31cd901d-179f-4ba9-b118-c8f6b5a9f3da"}
{"parentUuid":"518751e4-20ed-44b2-bb6c-1c680a8238f6","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_013698QfoRuN2bGXQKtnxSfH","toolUseID":"toolu_013698QfoRuN2bGXQKtnxSfH","timestamp":"2026-02-10T17:50:18.413Z","uuid":"cb4841ac-1dc5-4d48-8d49-525799de140c"}
{"parentUuid":"496995ea-7a82-4453-a02d-edffba7c4f0d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M3mWjVn94drb3dzcAiUUKS","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"6ef943ce-7f60-4180-8b4f-3dd932df0d6e","timestamp":"2026-02-10T17:50:18.436Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}","newString":"            onCopyUrls={handleCopyUrls}\n            onExport={handleQuickExportAction}\n            onDelete={() => setDeleteDialogOpen(true)}","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);\nimport { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  const allBookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: {},\n    }),\n    enabled: exportDialogOpen,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  const handleQuickExportAction = useCallback(\n    (format: \"csv\" | \"json\") => {\n      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n      handleExitSelectionMode();\n    },\n    [bookmarks, selectedIds, groups, handleExitSelectionMode],\n  );\n\n  const handleOpenExportDialog = useCallback(() => {\n    setExportDialogOpen(true);\n  }, []);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n        onExport={handleOpenExportDialog}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":1252,"oldLines":6,"newStart":1252,"newLines":7,"lines":["             onSelectAll={handleSelectAll}","             onMove={() => setMoveDialogOpen(true)}","             onCopyUrls={handleCopyUrls}","+            onExport={handleQuickExportAction}","             onDelete={() => setDeleteDialogOpen(true)}","             onClose={handleExitSelectionMode}","             hasUsername={hasUsername}"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"496995ea-7a82-4453-a02d-edffba7c4f0d"}
{"parentUuid":"6ef943ce-7f60-4180-8b4f-3dd932df0d6e","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01M3mWjVn94drb3dzcAiUUKS","toolUseID":"toolu_01M3mWjVn94drb3dzcAiUUKS","timestamp":"2026-02-10T17:50:18.437Z","uuid":"5a727994-938a-413f-9dd4-ddaee2ab1e17"}
{"parentUuid":"5cebccdb-186d-4f5c-9c23-9b9be1ee7f6e","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0166YdqdfMkJYXDAP4yuFeD5","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/dashboard-content.tsx has been updated successfully."}]},"uuid":"7d0bb33b-f06f-4953-93fe-716360ed8515","timestamp":"2026-02-10T17:50:18.450Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/dashboard-content.tsx","oldString":"        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>","newString":"        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n        <ExportDialog\n          open={exportDialogOpen}\n          onOpenChange={setExportDialogOpen}\n          mode=\"settings\"\n          bookmarks={allBookmarks}\n          groups={groups}\n        />\n      </main>","originalFile":"\"use client\";\n\nimport { useState, useCallback, useRef, useEffect, useMemo } from \"react\";\nimport { useQueryState } from \"nuqs\";\nimport { useQuery, useMutation, useQueryClient } from \"@tanstack/react-query\";\nimport { toast } from \"sonner\";\nimport dynamic from \"next/dynamic\";\nimport { Header } from \"@/components/header\";\nimport { BookmarkInput } from \"@/components/bookmark-input\";\nimport { BookmarkList } from \"@/components/bookmark-list\";\nimport { BookmarkListSkeleton } from \"@/components/dashboard-skeleton\";\n\nconst MultiSelectToolbar = dynamic(\n  () =>\n    import(\"@/components/multi-select-toolbar\").then(\n      (m) => m.MultiSelectToolbar,\n    ),\n  { ssr: false },\n);\nconst BulkMoveDialog = dynamic(\n  () => import(\"@/components/bulk-move-dialog\").then((m) => m.BulkMoveDialog),\n  { ssr: false },\n);\nconst BulkDeleteDialog = dynamic(\n  () =>\n    import(\"@/components/bulk-delete-dialog\").then((m) => m.BulkDeleteDialog),\n  { ssr: false },\n);\nconst ExportDialog = dynamic(\n  () => import(\"@/components/export-dialog\").then((m) => m.ExportDialog),\n  { ssr: false },\n);\nimport { handleQuickExport } from \"@/components/export-dialog\";\nimport { parseColor, isUrl, normalizeUrl, slugify } from \"@/lib/utils\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { useFocusRefetch } from \"@/hooks/use-focus-refetch\";\nimport { useLatestRef } from \"@/lib/hooks/use-latest-ref\";\nimport type { BookmarkType, GroupItem, BookmarkItem } from \"@/lib/schema\";\nimport type { Session } from \"@/lib/auth\";\n\nexport interface ProfileData {\n  image: string | null;\n  username: string | null;\n  bio: string | null;\n  github: string | null;\n  twitter: string | null;\n  website: string | null;\n  isProfilePublic: boolean;\n}\n\ninterface DashboardContentProps {\n  session: NonNullable<Session>;\n  initialGroups: GroupItem[];\n  initialBookmarks: BookmarkItem[];\n  profile: ProfileData;\n}\n\nconst groupListKey = () => orpc.group.list.queryKey() as readonly unknown[];\nconst bookmarkListKey = (groupId?: string | null) =>\n  orpc.bookmark.list.queryKey({\n    input: { groupId: groupId ?? undefined },\n  }) as readonly unknown[];\n\nexport function DashboardContent({\n  session,\n  initialGroups,\n  initialBookmarks,\n  profile,\n}: DashboardContentProps) {\n  const queryClient = useQueryClient();\n\n  const [groupSlug, setGroupSlug] = useQueryState(\"group\");\n  const [searchQuery, setSearchQuery] = useState(\"\");\n  const debouncedSearchQuery = useDebounce(searchQuery, 500);\n  const [selectedIndex, setSelectedIndex] = useState<number>(-1);\n  const [hoveredIndex, setHoveredIndex] = useState<number>(-1);\n  const inputRef = useRef<HTMLInputElement>(null);\n  const [renamingId, setRenamingId] = useState<string | null>(null);\n  const [selectionMode, setSelectionMode] = useState(false);\n  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());\n  const [moveDialogOpen, setMoveDialogOpen] = useState(false);\n  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);\n  const [exportDialogOpen, setExportDialogOpen] = useState(false);\n\n  const groupsQuery = useQuery({\n    ...orpc.group.list.queryOptions(),\n    initialData: initialGroups,\n    initialDataUpdatedAt: Date.now(),\n  });\n\n  const groups = useMemo(() => groupsQuery.data ?? [], [groupsQuery.data]);\n\n  const hasUsername = profile.username !== null;\n  const publicGroupIds = useMemo(\n    () => new Set(groups.filter((g) => g.isPublic).map((g) => g.id)),\n    [groups],\n  );\n\n  useFocusRefetch(groups);\n\n  const groupIdBySlug = useMemo(\n    () => new Map(groups.map((g) => [slugify(g.name), g.id])),\n    [groups],\n  );\n  const groupIdBySlugRef = useLatestRef(groupIdBySlug);\n\n  const selectedGroupId = groupSlug\n    ? (groupIdBySlug.get(groupSlug) ?? null)\n    : null;\n\n  const currentGroupId = selectedGroupId ?? groups[0]?.id ?? null;\n\n  const bookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: { groupId: currentGroupId ?? undefined },\n    }),\n    initialData:\n      currentGroupId === initialGroups[0]?.id ? initialBookmarks : undefined,\n    initialDataUpdatedAt: Date.now(),\n    enabled: !!currentGroupId,\n  });\n\n  const bookmarks = useMemo(\n    () => bookmarksQuery.data ?? [],\n    [bookmarksQuery.data],\n  );\n\n  const allBookmarksQuery = useQuery({\n    ...orpc.bookmark.list.queryOptions({\n      input: {},\n    }),\n    enabled: exportDialogOpen,\n  });\n\n  const allBookmarks = useMemo(\n    () => allBookmarksQuery.data ?? [],\n    [allBookmarksQuery.data],\n  );\n\n  useEffect(() => {\n    setSelectedIndex(-1);\n    setHoveredIndex(-1);\n  }, [bookmarks, currentGroupId]);\n\n  const createBookmarkMutation = useMutation({\n    ...orpc.bookmark.create.mutationOptions(),\n    onMutate: async (newBookmark) => {\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: newBookmark.groupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const optimisticBookmark: BookmarkItem = {\n        id: `temp-${Date.now()}`,\n        title: newBookmark.title,\n        url: newBookmark.url || null,\n        favicon: null,\n        type: newBookmark.type ?? \"link\",\n        color: newBookmark.color || null,\n        groupId: newBookmark.groupId,\n        createdAt: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(newBookmark.groupId),\n        (old) => [optimisticBookmark, ...(old || [])],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === newBookmark.groupId\n            ? { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 }\n            : g,\n        ),\n      );\n\n      return {\n        previousBookmarks,\n        previousGroups,\n        groupId: newBookmark.groupId,\n      };\n    },\n    onError: (_err, _newBookmark, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to create bookmark\");\n    },\n    onSettled: (_data, _error, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const updateBookmarkMutation = useMutation({\n    mutationFn: async (data: {\n      id: string;\n      title?: string;\n      url?: string;\n      type?: BookmarkType;\n      color?: string;\n      groupId?: string;\n      _sourceGroupId?: string;\n    }) => {\n      if (data.id.startsWith(\"temp-\")) {\n        return { id: data.id, title: data.title ?? \"\" } as Pick<\n          BookmarkItem,\n          \"id\" | \"title\"\n        >;\n      }\n      const { _sourceGroupId, ...updateData } = data;\n      return client.bookmark.update(updateData);\n    },\n    onMutate: async (data) => {\n      const { id, groupId: targetGroupId, _sourceGroupId, ...updates } = data;\n      const isMove =\n        targetGroupId && _sourceGroupId && targetGroupId !== _sourceGroupId;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      if (isMove) {\n        await queryClient.cancelQueries({\n          queryKey: orpc.bookmark.list.queryKey({\n            input: { groupId: targetGroupId },\n          }),\n        });\n      }\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      if (isMove) {\n        const previousSourceBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(_sourceGroupId));\n        const previousTargetBookmarks = queryClient.getQueryData<\n          BookmarkItem[]\n        >(bookmarkListKey(targetGroupId));\n\n        const movedBookmark = previousSourceBookmarks?.find((b) => b.id === id);\n\n        if (movedBookmark) {\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(_sourceGroupId),\n            (old) => old?.filter((b) => b.id !== id) ?? [],\n          );\n\n          queryClient.setQueryData<BookmarkItem[]>(\n            bookmarkListKey(targetGroupId),\n            (old) => [\n              { ...movedBookmark, groupId: targetGroupId },\n              ...(old ?? []),\n            ],\n          );\n\n          queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n            old?.map((g) => {\n              if (g.id === _sourceGroupId) {\n                return {\n                  ...g,\n                  bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - 1),\n                };\n              }\n              if (g.id === targetGroupId) {\n                return { ...g, bookmarkCount: (g.bookmarkCount ?? 0) + 1 };\n              }\n              return g;\n            }),\n          );\n        }\n\n        return {\n          previousSourceBookmarks,\n          previousTargetBookmarks,\n          previousGroups,\n          sourceGroupId: _sourceGroupId,\n          targetGroupId,\n        };\n      }\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n        (old) =>\n          old?.map((b) => (b.id === id ? { ...b, ...updates } : b)) ?? [],\n      );\n\n      return { previousBookmarks, sourceGroupId, previousGroups };\n    },\n    onError: (_err, data, context) => {\n      if (\n        context?.previousSourceBookmarks !== undefined &&\n        context?.sourceGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (\n        context?.previousTargetBookmarks !== undefined &&\n        context?.targetGroupId\n      ) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousBookmarks !== undefined && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update bookmark\");\n    },\n    onSettled: (_data, _error, data, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const createGroupMutation = useMutation({\n    mutationFn: (data: {\n      name: string;\n      color: string;\n      _optimisticId?: string;\n    }) => {\n      const { _optimisticId, ...createData } = data;\n      return client.group.create(createData);\n    },\n    onMutate: async (newGroup) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      const optimisticGroup: GroupItem = {\n        id: newGroup._optimisticId ?? `temp-${Date.now()}`,\n        name: newGroup.name,\n        color: newGroup.color,\n        bookmarkCount: 0,\n      };\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) => [\n        ...(old ?? []),\n        optimisticGroup,\n      ]);\n\n      setGroupSlug(slugify(newGroup.name));\n      setSelectedIndex(-1);\n\n      return {\n        previousGroups,\n        previousGroupSlug,\n        optimisticId: optimisticGroup.id,\n      };\n    },\n    onError: (_err, _newGroup, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to create group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const deleteGroupMutation = useMutation({\n    ...orpc.group.delete.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n      const previousGroupSlug = groupSlug;\n\n      queryClient.setQueryData<GroupItem[]>(\n        groupListKey(),\n        (old) => old?.filter((g) => g.id !== data.id) ?? [],\n      );\n\n      if (currentGroupId === data.id) {\n        const remainingGroups =\n          previousGroups?.filter((g) => g.id !== data.id) ?? [];\n        setGroupSlug(\n          remainingGroups[0] ? slugify(remainingGroups[0].name) : null,\n        );\n        setSelectedIndex(-1);\n      }\n\n      return { previousGroups, previousGroupSlug, deletedId: data.id };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      if (context?.previousGroupSlug !== undefined) {\n        setGroupSlug(context.previousGroupSlug);\n      }\n      toast.error(\"Failed to delete group\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const refetchBookmarkMutation = useMutation({\n    mutationFn: (data: { id: string; groupId?: string }) =>\n      client.bookmark.refetch({ id: data.id }),\n    onSuccess: (_data, variables) => {\n      queryClient.invalidateQueries({\n        queryKey: orpc.bookmark.list.key({\n          input: { groupId: variables.groupId },\n        }),\n      });\n      toast.success(\"Metadata refreshed\");\n    },\n    onError: () => {\n      toast.error(\"Failed to refresh metadata\");\n    },\n  });\n\n  const bulkDeleteMutation = useMutation({\n    mutationFn: async (data: { ids: string[]; _groupId?: string }) => {\n      const { _groupId, ...deleteData } = data;\n      const realIds = deleteData.ids.filter((id) => !id.startsWith(\"temp-\"));\n      if (realIds.length === 0) {\n        return { success: true };\n      }\n      return client.bookmark.bulkDelete({ ids: realIds });\n    },\n    onMutate: async (data) => {\n      const groupId = data._groupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) => old?.filter((b) => !data.ids.includes(b.id)) ?? [],\n      );\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === groupId\n            ? {\n                ...g,\n                bookmarkCount: Math.max(\n                  0,\n                  (g.bookmarkCount ?? 0) - data.ids.length,\n                ),\n              }\n            : g,\n        ),\n      );\n\n      return { previousBookmarks, previousGroups, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to delete bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const bulkMoveMutation = useMutation({\n    mutationFn: (data: {\n      ids: string[];\n      targetGroupId: string;\n      _sourceGroupId?: string;\n    }) => {\n      const { _sourceGroupId, ...moveData } = data;\n      return client.bookmark.bulkMove(moveData);\n    },\n    onMutate: async (data) => {\n      const { ids, targetGroupId, _sourceGroupId } = data;\n      const sourceGroupId = _sourceGroupId ?? currentGroupId;\n\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: sourceGroupId ?? undefined },\n        }),\n      });\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: targetGroupId },\n        }),\n      });\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousSourceBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(sourceGroupId),\n      );\n      const previousTargetBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(targetGroupId),\n      );\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      const movedBookmarks = previousSourceBookmarks?.filter((b) =>\n        ids.includes(b.id),\n      );\n\n      if (movedBookmarks) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(sourceGroupId),\n          (old) => old?.filter((b) => !ids.includes(b.id)) ?? [],\n        );\n\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(targetGroupId),\n          (old) => [\n            ...movedBookmarks.map((b) => ({ ...b, groupId: targetGroupId })),\n            ...(old ?? []),\n          ],\n        );\n\n        queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n          old?.map((g) => {\n            if (g.id === sourceGroupId) {\n              return {\n                ...g,\n                bookmarkCount: Math.max(0, (g.bookmarkCount ?? 0) - ids.length),\n              };\n            }\n            if (g.id === targetGroupId) {\n              return {\n                ...g,\n                bookmarkCount: (g.bookmarkCount ?? 0) + ids.length,\n              };\n            }\n            return g;\n          }),\n        );\n      }\n\n      return {\n        previousSourceBookmarks,\n        previousTargetBookmarks,\n        previousGroups,\n        sourceGroupId,\n        targetGroupId,\n      };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousSourceBookmarks && context?.sourceGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.sourceGroupId),\n          context.previousSourceBookmarks,\n        );\n      }\n      if (context?.previousTargetBookmarks && context?.targetGroupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.targetGroupId),\n          context.previousTargetBookmarks,\n        );\n      }\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to move bookmarks\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.sourceGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.sourceGroupId },\n          }),\n        });\n      }\n      if (context?.targetGroupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.targetGroupId },\n          }),\n        });\n      }\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const setVisibilityMutation = useMutation({\n    ...orpc.bookmark.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            b.id === data.id ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const bulkSetVisibilityMutation = useMutation({\n    ...orpc.bookmark.bulkSetVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      const groupId = currentGroupId;\n      await queryClient.cancelQueries({\n        queryKey: orpc.bookmark.list.queryKey({\n          input: { groupId: groupId ?? undefined },\n        }),\n      });\n\n      const previousBookmarks = queryClient.getQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n      );\n\n      queryClient.setQueryData<BookmarkItem[]>(\n        bookmarkListKey(groupId),\n        (old) =>\n          old?.map((b) =>\n            data.ids.includes(b.id) ? { ...b, isPublic: data.isPublic } : b,\n          ) ?? [],\n      );\n\n      return { previousBookmarks, groupId };\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousBookmarks && context?.groupId) {\n        queryClient.setQueryData<BookmarkItem[]>(\n          bookmarkListKey(context.groupId),\n          context.previousBookmarks,\n        );\n      }\n      toast.error(\"Failed to update visibility\");\n    },\n    onSettled: (_data, _error, _variables, context) => {\n      if (context?.groupId) {\n        queryClient.invalidateQueries({\n          queryKey: orpc.bookmark.list.key({\n            input: { groupId: context.groupId },\n          }),\n        });\n      }\n    },\n  });\n\n  const setGroupVisibilityMutation = useMutation({\n    ...orpc.group.setVisibility.mutationOptions(),\n    onMutate: async (data) => {\n      await queryClient.cancelQueries({ queryKey: orpc.group.list.queryKey() });\n\n      const previousGroups =\n        queryClient.getQueryData<GroupItem[]>(groupListKey());\n\n      queryClient.setQueryData<GroupItem[]>(groupListKey(), (old) =>\n        old?.map((g) =>\n          g.id === data.id ? { ...g, isPublic: data.isPublic } : g,\n        ),\n      );\n\n      return { previousGroups };\n    },\n    onSuccess: (_data, variables) => {\n      toast.success(\n        variables.isPublic ? \"Group is now public\" : \"Group is now private\",\n      );\n    },\n    onError: (_err, _data, context) => {\n      if (context?.previousGroups) {\n        queryClient.setQueryData<GroupItem[]>(\n          groupListKey(),\n          context.previousGroups,\n        );\n      }\n      toast.error(\"Failed to update group visibility\");\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: orpc.group.key() });\n    },\n  });\n\n  const selectedGroup =\n    groups.find((g) => g.id === currentGroupId) || groups[0];\n\n  const handleStartRename = (id: string) => {\n    setRenamingId(id);\n  };\n\n  const handleFinishRename = () => {\n    setRenamingId(null);\n  };\n\n  const handleDeleteBookmark = useCallback(\n    (id: string) => {\n      bulkDeleteMutation.mutate({\n        ids: [id],\n        _groupId: currentGroupId ?? undefined,\n      });\n    },\n    [bulkDeleteMutation, currentGroupId],\n  );\n\n  const filteredBookmarks = useMemo(() => {\n    return bookmarks.filter((b) => {\n      if (!debouncedSearchQuery) return true;\n      return (\n        b.title.toLowerCase().includes(debouncedSearchQuery.toLowerCase()) ||\n        b.url?.toLowerCase().includes(debouncedSearchQuery.toLowerCase())\n      );\n    });\n  }, [bookmarks, debouncedSearchQuery]);\n\n  const handleEnterSelectionMode = useCallback((initialId?: string) => {\n    setSelectionMode(true);\n    if (initialId) {\n      setSelectedIds(new Set([initialId]));\n    }\n  }, []);\n\n  const handleExitSelectionMode = useCallback(() => {\n    setSelectionMode(false);\n    setSelectedIds(new Set());\n  }, []);\n\n  const handleToggleSelection = useCallback((id: string) => {\n    setSelectedIds((prev) => {\n      const next = new Set(prev);\n      if (next.has(id)) {\n        next.delete(id);\n      } else {\n        next.add(id);\n      }\n      return next;\n    });\n  }, []);\n\n  const handleSelectAll = useCallback(() => {\n    setSelectedIds(new Set(filteredBookmarks.map((b) => b.id)));\n  }, [filteredBookmarks]);\n\n  const handleCopyUrls = useCallback(() => {\n    const urls = bookmarks\n      .filter((b) => selectedIds.has(b.id) && b.url)\n      .map((b) => b.url)\n      .join(\"\\n\");\n\n    if (urls) {\n      navigator.clipboard.writeText(urls);\n      toast.success(`Copied ${selectedIds.size} URLs`);\n    } else {\n      toast.error(\"No URLs to copy\");\n    }\n  }, [bookmarks, selectedIds]);\n\n  const handleConfirmMove = useCallback(\n    (targetGroupId: string) => {\n      bulkMoveMutation.mutate({\n        ids: Array.from(selectedIds),\n        targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n      handleExitSelectionMode();\n      toast.success(`Moved ${selectedIds.size} bookmarks`);\n    },\n    [bulkMoveMutation, selectedIds, currentGroupId, handleExitSelectionMode],\n  );\n\n  const handleConfirmDelete = useCallback(() => {\n    bulkDeleteMutation.mutate({\n      ids: Array.from(selectedIds),\n      _groupId: currentGroupId ?? undefined,\n    });\n    handleExitSelectionMode();\n    toast.success(`Deleted ${selectedIds.size} bookmarks`);\n  }, [\n    bulkDeleteMutation,\n    selectedIds,\n    currentGroupId,\n    handleExitSelectionMode,\n  ]);\n\n  const handleQuickExportAction = useCallback(\n    (format: \"csv\" | \"json\") => {\n      const groupsMap = new Map(groups.map((g) => [g.id, g.name]));\n      handleQuickExport(format, bookmarks, selectedIds, groupsMap);\n      handleExitSelectionMode();\n    },\n    [bookmarks, selectedIds, groups, handleExitSelectionMode],\n  );\n\n  const handleOpenExportDialog = useCallback(() => {\n    setExportDialogOpen(true);\n  }, []);\n\n  // Refs to store latest values for stable keyboard handler\n  const groupsRef = useLatestRef(groups);\n  const filteredBookmarksRef = useLatestRef(filteredBookmarks);\n  const selectedIndexRef = useLatestRef(selectedIndex);\n  const hoveredIndexRef = useLatestRef(hoveredIndex);\n  const renamingIdRef = useLatestRef(renamingId);\n  const handleDeleteBookmarkRef = useLatestRef(handleDeleteBookmark);\n  const handleStartRenameRef = useLatestRef(handleStartRename);\n  const selectionModeRef = useLatestRef(selectionMode);\n  const selectedIdsRef = useLatestRef(selectedIds);\n\n  const handleSearchChange = useCallback((value: string) => {\n    setSearchQuery(value);\n    setSelectedIndex(-1);\n  }, []);\n\n  const handleSelectGroup = useCallback(\n    (id: string) => {\n      const group = groupsRef.current.find((g) => g.id === id);\n      setGroupSlug(group ? slugify(group.name) : null);\n      setSelectedIndex(-1);\n      handleExitSelectionMode();\n    },\n    [setGroupSlug, handleExitSelectionMode],\n  );\n\n  const handleAddBookmark = useCallback(\n    (value: string) => {\n      if (!currentGroupId) return;\n\n      const trimmedValue = value.trim();\n      if (!trimmedValue) return;\n\n      const colorResult = parseColor(trimmedValue);\n\n      if (colorResult.isColor) {\n        createBookmarkMutation.mutate({\n          title: colorResult.original || trimmedValue,\n          url: \"\",\n          type: \"color\",\n          color: colorResult.hex,\n          groupId: currentGroupId,\n        });\n      } else if (!trimmedValue.includes(\"\\n\") && isUrl(trimmedValue)) {\n        const url = normalizeUrl(trimmedValue);\n        createBookmarkMutation.mutate({\n          title: new URL(url).hostname.replace(\"www.\", \"\"),\n          url,\n          type: \"link\",\n          groupId: currentGroupId,\n        });\n      } else {\n        createBookmarkMutation.mutate({\n          title: trimmedValue,\n          url: \"\",\n          type: \"text\",\n          groupId: currentGroupId,\n        });\n      }\n\n      setSearchQuery(\"\");\n      setSelectedIndex(-1);\n    },\n    [currentGroupId, createBookmarkMutation],\n  );\n\n  const handleCreateGroup = useCallback(\n    (name: string) => {\n      const palette = [\n        \"#3E63DD\",\n        \"#208368\",\n        \"#FFDC00\",\n        \"#CE2C31\",\n        \"#53195D\",\n        \"#0086F0FA\",\n        \"#838383\",\n        \"#74B06F\",\n        \"#4A90D9\",\n        \"#E6A23C\",\n        \"#9B59B6\",\n        \"#E74C3C\",\n        \"#202020\",\n      ];\n      const usedColors = new Set(groups.map((g) => g.color));\n      const availableColors = palette.filter((c) => !usedColors.has(c));\n      const color =\n        availableColors.length > 0\n          ? availableColors[0]\n          : palette[groups.length % palette.length];\n\n      createGroupMutation.mutate({ name, color });\n    },\n    [createGroupMutation, groups],\n  );\n\n  const handleDeleteGroup = useCallback(\n    (id: string) => {\n      deleteGroupMutation.mutate({ id });\n    },\n    [deleteGroupMutation],\n  );\n\n  const handleRenameBookmark = useCallback(\n    (id: string, newTitle: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        title: newTitle,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleMoveBookmark = useCallback(\n    (id: string, targetGroupId: string) => {\n      updateBookmarkMutation.mutate({\n        id,\n        groupId: targetGroupId,\n        _sourceGroupId: currentGroupId ?? undefined,\n      });\n    },\n    [updateBookmarkMutation, currentGroupId],\n  );\n\n  const handleRefetchBookmark = useCallback(\n    (id: string) => {\n      refetchBookmarkMutation.mutate({\n        id,\n        groupId: currentGroupId ?? undefined,\n      });\n    },\n    [refetchBookmarkMutation, currentGroupId],\n  );\n\n  const handleToggleBookmarkVisibility = useCallback(\n    (id: string, currentIsPublic: boolean | null | undefined) => {\n      const isInPublicGroup = currentGroupId\n        ? publicGroupIds.has(currentGroupId)\n        : false;\n      const isEffectivelyPublic =\n        currentIsPublic === true ||\n        (isInPublicGroup && currentIsPublic !== false);\n\n      if (isEffectivelyPublic) {\n        setVisibilityMutation.mutate({\n          id,\n          isPublic: isInPublicGroup ? false : null,\n        });\n        toast.success(\"Bookmark hidden from public profile\");\n      } else {\n        setVisibilityMutation.mutate({ id, isPublic: true });\n        toast.success(\"Bookmark visible on public profile\");\n      }\n    },\n    [setVisibilityMutation, currentGroupId, publicGroupIds],\n  );\n\n  const handleBulkMakePublic = useCallback(() => {\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: true,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made public`);\n  }, [bulkSetVisibilityMutation, selectedIds, handleExitSelectionMode]);\n\n  const handleBulkMakePrivate = useCallback(() => {\n    const isInPublicGroup = currentGroupId\n      ? publicGroupIds.has(currentGroupId)\n      : false;\n    bulkSetVisibilityMutation.mutate({\n      ids: Array.from(selectedIds),\n      isPublic: isInPublicGroup ? false : null,\n    });\n    handleExitSelectionMode();\n    toast.success(`${selectedIds.size} bookmarks made private`);\n  }, [\n    bulkSetVisibilityMutation,\n    selectedIds,\n    currentGroupId,\n    publicGroupIds,\n    handleExitSelectionMode,\n  ]);\n\n  const handleToggleGroupVisibility = useCallback(\n    (id: string, isPublic: boolean) => {\n      setGroupVisibilityMutation.mutate({ id, isPublic });\n    },\n    [setGroupVisibilityMutation],\n  );\n\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      if (renamingIdRef.current) return;\n\n      if (document.activeElement === inputRef.current) {\n        return;\n      }\n\n      const isInputFocused =\n        document.activeElement instanceof HTMLInputElement ||\n        document.activeElement instanceof HTMLTextAreaElement;\n      if (isInputFocused && (e.metaKey || e.ctrlKey)) {\n        return;\n      }\n\n      const bookmarks = filteredBookmarksRef.current;\n      const inSelectionMode = selectionModeRef.current;\n\n      if (e.key === \"Escape\" && inSelectionMode) {\n        e.preventDefault();\n        handleExitSelectionMode();\n        return;\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"a\" && inSelectionMode) {\n        e.preventDefault();\n        handleSelectAll();\n        return;\n      }\n\n      if (e.key === \"ArrowDown\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.min(prev + 1, bookmarks.length - 1));\n        return;\n      }\n      if (e.key === \"ArrowUp\") {\n        e.preventDefault();\n        setSelectedIndex((prev) => Math.max(prev - 1, -1));\n        return;\n      }\n\n      const activeIndex =\n        hoveredIndexRef.current >= 0\n          ? hoveredIndexRef.current\n          : selectedIndexRef.current;\n      if (activeIndex < 0 || activeIndex >= bookmarks.length) return;\n      const activeBookmark = bookmarks[activeIndex];\n      if (!activeBookmark) return;\n\n      if (e.key === \" \" && inSelectionMode) {\n        e.preventDefault();\n        handleToggleSelection(activeBookmark.id);\n        return;\n      }\n\n      if (e.key === \"Enter\" && document.activeElement !== inputRef.current) {\n        e.preventDefault();\n        if (activeBookmark.url) {\n          window.open(activeBookmark.url, \"_blank\");\n        } else {\n          const textToCopy = activeBookmark.color || activeBookmark.title;\n          navigator.clipboard.writeText(textToCopy ?? \"\");\n        }\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"c\") {\n        e.preventDefault();\n        const textToCopy =\n          activeBookmark.url || activeBookmark.color || activeBookmark.title;\n        navigator.clipboard.writeText(textToCopy ?? \"\");\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"e\") {\n        e.preventDefault();\n        handleStartRenameRef.current(activeBookmark.id);\n      }\n\n      if ((e.metaKey || e.ctrlKey) && e.key === \"Backspace\") {\n        e.preventDefault();\n        handleDeleteBookmarkRef.current(activeBookmark.id);\n      }\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown);\n    return () => window.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleExitSelectionMode, handleSelectAll, handleToggleSelection]);\n\n  if (!selectedGroup) {\n    return null;\n  }\n\n  return (\n    <div className=\"min-h-dvh bg-background\">\n      <Header\n        groups={groups}\n        selectedGroup={selectedGroup}\n        onSelectGroup={handleSelectGroup}\n        onCreateGroup={handleCreateGroup}\n        onDeleteGroup={handleDeleteGroup}\n        onToggleGroupVisibility={\n          hasUsername ? handleToggleGroupVisibility : undefined\n        }\n        isTogglingGroupVisibility={setGroupVisibilityMutation.isPending}\n        userName={session.user.name}\n        userEmail={session.user.email}\n        userImage={profile.image}\n        username={profile.username}\n        profile={profile}\n        onExport={handleOpenExportDialog}\n      />\n      <main className=\"mx-auto w-full max-w-2xl px-5 py-20\">\n        <BookmarkInput\n          ref={inputRef}\n          value={searchQuery}\n          onChange={handleSearchChange}\n          onSubmit={handleAddBookmark}\n        />\n        {bookmarksQuery.isPending && !bookmarksQuery.data ? (\n          <BookmarkListSkeleton />\n        ) : (\n          <BookmarkList\n            bookmarks={filteredBookmarks}\n            groups={groups}\n            onDelete={handleDeleteBookmark}\n            onRename={handleRenameBookmark}\n            onMove={handleMoveBookmark}\n            onRefetch={handleRefetchBookmark}\n            currentGroupId={currentGroupId || \"\"}\n            selectedIndex={selectedIndex}\n            onSelect={setSelectedIndex}\n            renamingId={renamingId}\n            onStartRename={handleStartRename}\n            onFinishRename={handleFinishRename}\n            onHoverChange={setHoveredIndex}\n            hoveredIndex={hoveredIndex}\n            selectionMode={selectionMode}\n            selectedIds={selectedIds}\n            onToggleSelection={handleToggleSelection}\n            onEnterSelectionMode={handleEnterSelectionMode}\n            onBulkMove={handleConfirmMove}\n            onBulkDelete={handleConfirmDelete}\n            hasUsername={hasUsername}\n            publicGroupIds={publicGroupIds}\n            onToggleVisibility={handleToggleBookmarkVisibility}\n          />\n        )}\n        {selectionMode && selectedIds.size > 0 && (\n          <MultiSelectToolbar\n            selectedCount={selectedIds.size}\n            onSelectAll={handleSelectAll}\n            onMove={() => setMoveDialogOpen(true)}\n            onCopyUrls={handleCopyUrls}\n            onExport={handleQuickExportAction}\n            onDelete={() => setDeleteDialogOpen(true)}\n            onClose={handleExitSelectionMode}\n            hasUsername={hasUsername}\n            onMakePublic={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? undefined\n                : handleBulkMakePublic\n            }\n            onMakePrivate={\n              currentGroupId && publicGroupIds.has(currentGroupId)\n                ? handleBulkMakePrivate\n                : undefined\n            }\n          />\n        )}\n        <BulkMoveDialog\n          open={moveDialogOpen}\n          onOpenChange={setMoveDialogOpen}\n          groups={groups}\n          currentGroupId={currentGroupId || \"\"}\n          selectedCount={selectedIds.size}\n          onConfirm={handleConfirmMove}\n        />\n        <BulkDeleteDialog\n          open={deleteDialogOpen}\n          onOpenChange={setDeleteDialogOpen}\n          count={selectedIds.size}\n          onConfirm={handleConfirmDelete}\n        />\n      </main>\n    </div>\n  );\n}\n","structuredPatch":[{"oldStart":1282,"oldLines":6,"newStart":1282,"newLines":13,"lines":["           count={selectedIds.size}","           onConfirm={handleConfirmDelete}","         />","+        <ExportDialog","+          open={exportDialogOpen}","+          onOpenChange={setExportDialogOpen}","+          mode=\"settings\"","+          bookmarks={allBookmarks}","+          groups={groups}","+        />","       </main>","     </div>","   );"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5cebccdb-186d-4f5c-9c23-9b9be1ee7f6e"}
{"parentUuid":"7d0bb33b-f06f-4953-93fe-716360ed8515","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_0166YdqdfMkJYXDAP4yuFeD5","toolUseID":"toolu_0166YdqdfMkJYXDAP4yuFeD5","timestamp":"2026-02-10T17:50:18.450Z","uuid":"d97aa46b-82b9-4319-8586-4d39cef98ccc"}
{"parentUuid":"d97aa46b-82b9-4319-8586-4d39cef98ccc","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01AU74MN8fiCVvieRAKmDgs7","type":"message","role":"assistant","content":[{"type":"text","text":"Dashboard-content is done. Now let me graft exports into the other 3 files. Let me read and edit them:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":822,"cache_read_input_tokens":118364,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":822},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp2jgc9vVYdbNcqqYs7","type":"assistant","uuid":"b2d267c4-427c-4247-b7ff-6769422388c9","timestamp":"2026-02-10T17:50:23.277Z"}
{"parentUuid":"b2d267c4-427c-4247-b7ff-6769422388c9","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01AU74MN8fiCVvieRAKmDgs7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015e9DBMPLMdbiszyCiNwXbc","name":"Read","input":{"file_path":"/Users/duncan/dev/bmrks/components/header.tsx","limit":30,"offset":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":822,"cache_read_input_tokens":118364,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":822},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp2jgc9vVYdbNcqqYs7","type":"assistant","uuid":"de79de13-acf5-46da-a5e8-6f624416328c","timestamp":"2026-02-10T17:50:24.055Z"}
{"parentUuid":"de79de13-acf5-46da-a5e8-6f624416328c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01AU74MN8fiCVvieRAKmDgs7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AscnK639ztLcXuP9PmpnXV","name":"Read","input":{"file_path":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":822,"cache_read_input_tokens":118364,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":822},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp2jgc9vVYdbNcqqYs7","type":"assistant","uuid":"02a6a550-5f5d-4b9b-920c-931321f9edfe","timestamp":"2026-02-10T17:50:24.483Z"}
{"parentUuid":"02a6a550-5f5d-4b9b-920c-931321f9edfe","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01AU74MN8fiCVvieRAKmDgs7","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015Xf8VxsYToHwWWPVN5A8M2","name":"Read","input":{"file_path":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","limit":40}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":822,"cache_read_input_tokens":118364,"output_tokens":255,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":822,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXzp2jgc9vVYdbNcqqYs7","type":"assistant","uuid":"7a866636-6dae-44b9-b065-67dfe3054980","timestamp":"2026-02-10T17:50:25.203Z"}
{"parentUuid":"de79de13-acf5-46da-a5e8-6f624416328c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015e9DBMPLMdbiszyCiNwXbc","type":"tool_result","content":"    40→  DialogContent,\n    41→  DialogDescription,\n    42→  DialogFooter,\n    43→  DialogHeader,\n    44→  DialogTitle,\n    45→} from \"@/components/ui/dialog\";\n    46→import { Form } from \"@/components/ui/form\";\n    47→import { Field, FieldLabel } from \"@/components/ui/field\";\n    48→import { cn } from \"@/lib/utils\";\n    49→import { type GroupItem } from \"@/lib/schema\";\n    50→import type { ProfileData } from \"@/components/dashboard-content\";\n    51→\n    52→const SettingsDialog = dynamic(\n    53→  () => import(\"@/components/settings-dialog\").then((m) => m.SettingsDialog),\n    54→  { ssr: false },\n    55→);\n    56→\n    57→interface HeaderProps {\n    58→  groups: GroupItem[];\n    59→  selectedGroup: GroupItem;\n    60→  onSelectGroup: (id: string) => void;\n    61→  onCreateGroup: (name: string) => void;\n    62→  onDeleteGroup?: (id: string) => void;\n    63→  onToggleGroupVisibility?: (id: string, isPublic: boolean) => void;\n    64→  isTogglingGroupVisibility?: boolean;\n    65→  userName: string;\n    66→  userEmail: string;\n    67→  userImage?: string | null;\n    68→  username?: string | null;\n    69→  profile?: ProfileData;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"17836f5c-31c3-4519-9380-d0e6cba73706","timestamp":"2026-02-10T17:50:25.217Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/duncan/dev/bmrks/components/header.tsx","content":"  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\n\nconst SettingsDialog = dynamic(\n  () => import(\"@/components/settings-dialog\").then((m) => m.SettingsDialog),\n  { ssr: false },\n);\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  onToggleGroupVisibility?: (id: string, isPublic: boolean) => void;\n  isTogglingGroupVisibility?: boolean;\n  userName: string;\n  userEmail: string;\n  userImage?: string | null;\n  username?: string | null;\n  profile?: ProfileData;","numLines":30,"startLine":40,"totalLines":552}},"sourceToolAssistantUUID":"de79de13-acf5-46da-a5e8-6f624416328c"}
{"parentUuid":"02a6a550-5f5d-4b9b-920c-931321f9edfe","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AscnK639ztLcXuP9PmpnXV","type":"tool_result","content":"     1→\"use client\";\n     2→\n     3→import { motion } from \"motion/react\";\n     4→import { Button } from \"@/components/ui/button\";\n     5→import {\n     6→  IconListCheck,\n     7→  IconX,\n     8→  IconDragDrop,\n     9→  IconCopyCheckFilled,\n    10→  IconTrash,\n    11→  IconWorld,\n    12→  IconWorldOff,\n    13→} from \"@tabler/icons-react\";\n    14→\n    15→interface MultiSelectToolbarProps {\n    16→  selectedCount: number;\n    17→  onSelectAll: () => void;\n    18→  onMove: () => void;\n    19→  onCopyUrls: () => void;\n    20→  onDelete: () => void;\n    21→  onClose: () => void;\n    22→  hasUsername?: boolean;\n    23→  onMakePublic?: () => void;\n    24→  onMakePrivate?: () => void;\n    25→}\n    26→\n    27→export function MultiSelectToolbar({\n    28→  selectedCount,\n    29→  onSelectAll,\n    30→  onMove,\n    31→  onCopyUrls,\n    32→  onDelete,\n    33→  onClose,\n    34→  hasUsername,\n    35→  onMakePublic,\n    36→  onMakePrivate,\n    37→}: MultiSelectToolbarProps) {\n    38→  return (\n    39→    <motion.div\n    40→      initial={{ y: 100, opacity: 0 }}\n    41→      animate={{ y: 0, opacity: 1 }}\n    42→      exit={{ y: 100, opacity: 0 }}\n    43→      transition={{ duration: 0.2, ease: \"easeOut\" }}\n    44→      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    45→    >\n    46→      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n    47→        <Button\n    48→          variant=\"ghost\"\n    49→          size=\"sm\"\n    50→          onClick={onSelectAll}\n    51→          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n    52→        >\n    53→          <IconListCheck className=\"h-4 w-4\" />\n    54→          Select All\n    55→        </Button>\n    56→        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n    57→        <Button\n    58→          variant=\"ghost\"\n    59→          size=\"sm\"\n    60→          onClick={onMove}\n    61→          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n    62→        >\n    63→          <IconDragDrop className=\"h-4 w-4\" />\n    64→          Move\n    65→        </Button>\n    66→        <Button\n    67→          variant=\"ghost\"\n    68→          size=\"sm\"\n    69→          onClick={onCopyUrls}\n    70→          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n    71→        >\n    72→          <IconCopyCheckFilled className=\"h-4 w-4\" />\n    73→          Copy URLs\n    74→        </Button>\n    75→        {hasUsername && onMakePublic && (\n    76→          <Button\n    77→            variant=\"ghost\"\n    78→            size=\"sm\"\n    79→            onClick={onMakePublic}\n    80→            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n    81→          >\n    82→            <IconWorld className=\"h-4 w-4\" />\n    83→            Public\n    84→          </Button>\n    85→        )}\n    86→        {hasUsername && onMakePrivate && (\n    87→          <Button\n    88→            variant=\"ghost\"\n    89→            size=\"sm\"\n    90→            onClick={onMakePrivate}\n    91→            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n    92→          >\n    93→            <IconWorldOff className=\"h-4 w-4\" />\n    94→            Private\n    95→          </Button>\n    96→        )}\n    97→        <Button\n    98→          variant=\"ghost\"\n    99→          size=\"sm\"\n   100→          onClick={onDelete}\n   101→          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n   102→        >\n   103→          <IconTrash className=\"h-4 w-4\" />\n   104→          Delete\n   105→        </Button>\n   106→        <div className=\"h-4 w-px bg-border mx-0.5\" />\n   107→        <Button\n   108→          variant=\"ghost\"\n   109→          size=\"sm\"\n   110→          onClick={onClose}\n   111→          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n   112→          aria-label=\"Close multi-select toolbar\"\n   113→        >\n   114→          <IconX className=\"h-4 w-4\" />\n   115→        </Button>\n   116→      </div>\n   117→    </motion.div>\n   118→  );\n   119→}\n   120→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"8418d08e-db03-408a-977e-d731d81672af","timestamp":"2026-02-10T17:50:25.217Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","content":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}\n","numLines":120,"startLine":1,"totalLines":120}},"sourceToolAssistantUUID":"02a6a550-5f5d-4b9b-920c-931321f9edfe"}
{"parentUuid":"7a866636-6dae-44b9-b065-67dfe3054980","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015Xf8VxsYToHwWWPVN5A8M2","type":"tool_result","content":"     1→\"use client\";\n     2→\n     3→import {\n     4→  useState,\n     5→  useCallback,\n     6→  useRef,\n     7→  useEffect,\n     8→  type ChangeEvent,\n     9→} from \"react\";\n    10→import { useRouter } from \"next/navigation\";\n    11→import { toast } from \"sonner\";\n    12→import { useQuery, useMutation } from \"@tanstack/react-query\";\n    13→import { authClient } from \"@/lib/auth-client\";\n    14→import { client, orpc } from \"@/lib/orpc\";\n    15→import type { ProfileData } from \"@/components/dashboard-content\";\n    16→import {\n    17→  Dialog,\n    18→  DialogClose,\n    19→  DialogContent,\n    20→  DialogDescription,\n    21→  DialogFooter,\n    22→  DialogHeader,\n    23→  DialogTitle,\n    24→} from \"@/components/ui/dialog\";\n    25→import { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\n    26→import { Button } from \"@/components/ui/button\";\n    27→import { Input } from \"@/components/ui/input\";\n    28→import { Textarea } from \"@/components/ui/textarea\";\n    29→import { Form } from \"@/components/ui/form\";\n    30→import { Field, FieldLabel } from \"@/components/ui/field\";\n    31→import { Avatar, AvatarImage, AvatarFallback } from \"@/components/ui/avatar\";\n    32→import { Switch } from \"@/components/ui/switch\";\n    33→import {\n    34→  IconCheck,\n    35→  IconX,\n    36→  IconLoader2,\n    37→  IconCopy,\n    38→  IconExternalLink,\n    39→} from \"@tabler/icons-react\";\n    40→import { ImagePlusIcon } from \"lucide-react\";\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1a1c749c-db72-4a5d-8596-a1549155f55b","timestamp":"2026-02-10T17:50:25.217Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","content":"\"use client\";\n\nimport {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  type ChangeEvent,\n} from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { authClient } from \"@/lib/auth-client\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { Avatar, AvatarImage, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n  IconCheck,\n  IconX,\n  IconLoader2,\n  IconCopy,\n  IconExternalLink,\n} from \"@tabler/icons-react\";\nimport { ImagePlusIcon } from \"lucide-react\";","numLines":40,"startLine":1,"totalLines":630}},"sourceToolAssistantUUID":"7a866636-6dae-44b9-b065-67dfe3054980"}
{"parentUuid":"1a1c749c-db72-4a5d-8596-a1549155f55b","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_015e9DBMPLMdbiszyCiNwXbc","toolUseID":"toolu_015e9DBMPLMdbiszyCiNwXbc","timestamp":"2026-02-10T17:50:25.219Z","uuid":"1fc0bd5d-2961-40d5-a3bd-e88b4917f4f4"}
{"parentUuid":"1fc0bd5d-2961-40d5-a3bd-e88b4917f4f4","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01AscnK639ztLcXuP9PmpnXV","toolUseID":"toolu_01AscnK639ztLcXuP9PmpnXV","timestamp":"2026-02-10T17:50:25.219Z","uuid":"d2245e8a-5b78-463e-ae4e-a40bca5188df"}
{"parentUuid":"d2245e8a-5b78-463e-ae4e-a40bca5188df","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_015Xf8VxsYToHwWWPVN5A8M2","toolUseID":"toolu_015Xf8VxsYToHwWWPVN5A8M2","timestamp":"2026-02-10T17:50:25.219Z","uuid":"117f16ec-76d8-4b49-872f-37b88c51321d"}
{"parentUuid":"117f16ec-76d8-4b49-872f-37b88c51321d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"text","text":"Good, I have the context. Let me now apply all the remaining edits in parallel:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"350005d4-c52a-42f2-a272-af4c598758a9","timestamp":"2026-02-10T17:50:29.725Z"}
{"parentUuid":"350005d4-c52a-42f2-a272-af4c598758a9","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014T7bMXSQVLzZSqXcUZ7DX3","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/header.tsx","old_string":"  profile?: ProfileData;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}","new_string":"  profile?: ProfileData;\n  onExport?: () => void;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"c64e8b03-95e4-4621-a0ec-508cf50abff7","timestamp":"2026-02-10T17:50:31.303Z"}
{"parentUuid":"c64e8b03-95e4-4621-a0ec-508cf50abff7","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015K7XNmqZ4rEscDEdCRh2HW","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/header.tsx","old_string":"  profile,\n  readOnly = false,","new_string":"  profile,\n  onExport,\n  readOnly = false,"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"07650d2a-c5f5-4207-9737-d9c30a8f1550","timestamp":"2026-02-10T17:50:32.475Z"}
{"parentUuid":"07650d2a-c5f5-4207-9737-d9c30a8f1550","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YcALHKgukAtNiCVyh7UjP8","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/header.tsx","old_string":"            profile={profile}\n          />","new_string":"            profile={profile}\n            onExport={onExport}\n          />"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"f831486f-f743-4244-86cc-7c850b637f55","timestamp":"2026-02-10T17:50:33.508Z"}
{"parentUuid":"f831486f-f743-4244-86cc-7c850b637f55","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011FZCgAvpHszp26qMqHMUhd","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","old_string":"import { Button } from \"@/components/ui/button\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";","new_string":"import { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"d8d18afe-57eb-4d56-81f7-4099c6ded085","timestamp":"2026-02-10T17:50:36.381Z"}
{"parentUuid":"d8d18afe-57eb-4d56-81f7-4099c6ded085","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GYmKyEFo8t1kBiNbEfrSWz","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","old_string":"  onCopyUrls: () => void;\n  onDelete: () => void;","new_string":"  onCopyUrls: () => void;\n  onExport: (format: \"csv\" | \"json\") => void;\n  onDelete: () => void;"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"0dedd721-e20c-4a43-b728-2c39dc7e3528","timestamp":"2026-02-10T17:50:37.629Z"}
{"parentUuid":"0dedd721-e20c-4a43-b728-2c39dc7e3528","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0193icakncV9UQC183iZEw14","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","old_string":"  onCopyUrls,\n  onDelete,","new_string":"  onCopyUrls,\n  onExport,\n  onDelete,"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"0c08ab55-6a81-4d41-8ee1-6ed0ed806086","timestamp":"2026-02-10T17:50:38.885Z"}
{"parentUuid":"0c08ab55-6a81-4d41-8ee1-6ed0ed806086","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PXq2m5vdNeHtHkRsh5MNVo","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","old_string":"      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"","new_string":"      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50 motion-reduce:transition-none motion-reduce:animate-none\""}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"b7422d2b-e53a-4e7c-a447-4d9fe8031eb4","timestamp":"2026-02-10T17:50:40.517Z"}
{"parentUuid":"b7422d2b-e53a-4e7c-a447-4d9fe8031eb4","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XsETUx3dq7ULUKxkT7cWqJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KtmrBtQFcW5Dcot2gzLUjd","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","old_string":"          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (","new_string":"          Copy URLs\n        </Button>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            render={\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n              />\n            }\n          >\n            <IconFileExport className=\"h-4 w-4\" />\n            Export\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"center\" className=\"w-40\">\n            <DropdownMenuItem onClick={() => onExport(\"csv\")} className=\"whitespace-nowrap\">\n              <IconFileTypeCsv className=\"h-4 w-4\" />\n              Export as CSV\n            </DropdownMenuItem>\n            <DropdownMenuItem onClick={() => onExport(\"json\")} className=\"whitespace-nowrap\">\n              <IconJson className=\"h-4 w-4\" />\n              Export as JSON\n            </DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n        {hasUsername && onMakePublic && ("}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3044,"cache_read_input_tokens":119186,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":3044},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp3BHjYZzes5ZcJwawc","type":"assistant","uuid":"a5685285-6b67-4f2a-aac0-763329550b9e","timestamp":"2026-02-10T17:50:45.883Z"}
{"type":"file-history-snapshot","messageId":"c64e8b03-95e4-4621-a0ec-508cf50abff7","snapshot":{"messageId":"06123b67-0019-4aec-aa67-ba0dfdf62319","trackedFileBackups":{"components/dashboard-content.tsx":{"backupFileName":"d30ebca3ed1ec74d@v1","version":1,"backupTime":"2026-02-10T17:49:53.671Z"},"components/header.tsx":{"backupFileName":"1d89d7abd201ae59@v1","version":1,"backupTime":"2026-02-10T17:50:45.999Z"}},"timestamp":"2026-02-10T17:48:34.297Z"},"isSnapshotUpdate":true}
{"parentUuid":"c64e8b03-95e4-4621-a0ec-508cf50abff7","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014T7bMXSQVLzZSqXcUZ7DX3","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/header.tsx has been updated successfully."}]},"uuid":"295bea83-374b-4a0a-a5b5-e70f18a38e43","timestamp":"2026-02-10T17:50:46.002Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/header.tsx","oldString":"  profile?: ProfileData;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}","newString":"  profile?: ProfileData;\n  onExport?: () => void;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}","originalFile":"\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport dynamic from \"next/dynamic\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  IconSelector,\n  IconPlus,\n  IconCheck,\n  IconTrash,\n  IconSettings,\n  IconLogout,\n  IconWorld,\n  IconWorldOff,\n  IconUser,\n  IconLoader2,\n} from \"@tabler/icons-react\";\nimport { signOut } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\n\nconst SettingsDialog = dynamic(\n  () => import(\"@/components/settings-dialog\").then((m) => m.SettingsDialog),\n  { ssr: false },\n);\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  onToggleGroupVisibility?: (id: string, isPublic: boolean) => void;\n  isTogglingGroupVisibility?: boolean;\n  userName: string;\n  userEmail: string;\n  userImage?: string | null;\n  username?: string | null;\n  profile?: ProfileData;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}\n\nexport function Header({\n  groups,\n  selectedGroup,\n  onSelectGroup,\n  onCreateGroup,\n  onDeleteGroup,\n  onToggleGroupVisibility,\n  isTogglingGroupVisibility,\n  userName,\n  userEmail,\n  userImage,\n  username,\n  profile,\n  readOnly = false,\n  showUserMenu = true,\n  logoSize = 24,\n}: HeaderProps) {\n  const router = useRouter();\n  const [newGroupName, setNewGroupName] = useState(\"\");\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [signOutOpen, setSignOutOpen] = useState(false);\n  const [visibilityDialogOpen, setVisibilityDialogOpen] = useState(false);\n  const [pendingVisibilityGroupId, setPendingVisibilityGroupId] = useState<\n    string | null\n  >(null);\n  const [pendingVisibilityTarget, setPendingVisibilityTarget] = useState<\n    boolean | null\n  >(null);\n  const [holdingGroupId, setHoldingGroupId] = useState<string | null>(null);\n  const [holdProgress, setHoldProgress] = useState(0);\n  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const holdStartRef = useRef<number>(0);\n  const initiatedToggleRef = useRef(false);\n\n  useEffect(() => {\n    if (!isTogglingGroupVisibility && initiatedToggleRef.current) {\n      initiatedToggleRef.current = false;\n      const timer = setTimeout(() => {\n        setVisibilityDialogOpen(false);\n        setPendingVisibilityGroupId(null);\n        setPendingVisibilityTarget(null);\n      }, 0);\n      return () => clearTimeout(timer);\n    }\n  }, [isTogglingGroupVisibility]);\n\n  const handleSignOut = async () => {\n    setSignOutOpen(false);\n    await signOut();\n    router.push(\"/login\");\n  };\n\n  const handleCreateGroup = () => {\n    if (newGroupName.trim()) {\n      onCreateGroup(newGroupName.trim());\n      setNewGroupName(\"\");\n      setDialogOpen(false);\n    }\n  };\n\n  const cancelHold = useCallback(() => {\n    if (holdTimerRef.current) {\n      clearTimeout(holdTimerRef.current);\n    }\n    setHoldingGroupId(null);\n    setHoldProgress(0);\n  }, []);\n\n  const startHold = useCallback(\n    (groupId: string) => {\n      if (readOnly) return;\n      if (groups.length <= 1) return;\n      setHoldingGroupId(groupId);\n      holdStartRef.current = Date.now();\n\n      const updateProgress = () => {\n        const elapsed = Date.now() - holdStartRef.current;\n        const progress = Math.min((elapsed / 2000) * 100, 100);\n        setHoldProgress(progress);\n\n        if (progress >= 100) {\n          onDeleteGroup?.(groupId);\n          cancelHold();\n        } else {\n          holdTimerRef.current = setTimeout(updateProgress, 16);\n        }\n      };\n\n      holdTimerRef.current = setTimeout(updateProgress, 16);\n    },\n    [groups.length, onDeleteGroup, cancelHold, readOnly],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (holdTimerRef.current) {\n        clearTimeout(holdTimerRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <header\n      className={cn(\n        \"flex items-center justify-between\",\n        readOnly ? \"px-4 py-2\" : \"px-6 py-3\",\n      )}\n    >\n      <div className=\"flex items-center gap-2\">\n        <BmrksLogo size={logoSize} />\n        <span className=\"text-muted-foreground\">/</span>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            className=\"rounded-xl\"\n            render={<Button variant=\"ghost\" className=\"gap-2 px-2\" />}\n          >\n            <span\n              className=\"h-2.5 w-2.5 rounded-full\"\n              style={{ backgroundColor: selectedGroup.color }}\n            />\n            <span>{selectedGroup.name}</span>\n            <IconSelector className=\"h-4 w-4 text-muted-foreground\" />\n          </DropdownMenuTrigger>\n          <DropdownMenuContent\n            align=\"start\"\n            className=\"w-48 space-y-1 rounded-xl\"\n          >\n            {groups.map((group) => (\n              <DropdownMenuItem\n                key={group.id}\n                onClick={() => onSelectGroup(group.id)}\n                className={cn(\n                  \"flex items-start justify-between rounded-lg px-2 py-1.5\",\n                  group.id === selectedGroup.id && \"bg-accent\",\n                )}\n              >\n                <div className=\"flex items-start gap-2\">\n                  <span\n                    className=\"mt-[5px] h-2.5 w-2.5 shrink-0 rounded-full\"\n                    style={{ backgroundColor: group.color }}\n                  />\n                  <span>{group.name}</span>\n                  {group.isPublic && (\n                    <IconWorld className=\"mt-1 h-3 w-3 shrink-0 text-muted-foreground\" />\n                  )}\n                </div>\n                {group.id === selectedGroup.id ? (\n                  <IconCheck className=\"mt-0.5 h-4 w-4 shrink-0\" />\n                ) : (\n                  <span className=\"mt-0.5 shrink-0 text-xs text-muted-foreground\">\n                    {group.bookmarkCount ?? 0}\n                  </span>\n                )}\n              </DropdownMenuItem>\n            ))}\n            <DropdownMenuItem\n              onClick={() => {\n                if (!readOnly) setDialogOpen(true);\n              }}\n              disabled={readOnly}\n              className=\"rounded-lg w-full px-2 py-1.5\"\n            >\n              <IconPlus className=\"h-4 w-4 mr-0\" />\n              Create Group\n            </DropdownMenuItem>\n            {!readOnly && onToggleGroupVisibility && (\n              <DropdownMenuItem\n                onClick={() => {\n                  setPendingVisibilityGroupId(selectedGroup.id);\n                  setPendingVisibilityTarget(!selectedGroup.isPublic);\n                  setVisibilityDialogOpen(true);\n                }}\n                className=\"rounded-lg px-2 py-1.5\"\n              >\n                {selectedGroup.isPublic ? (\n                  <>\n                    <IconWorldOff className=\"h-4 w-4\" />\n                    Make Private\n                  </>\n                ) : (\n                  <>\n                    <IconWorld className=\"h-4 w-4\" />\n                    Make Public\n                  </>\n                )}\n              </DropdownMenuItem>\n            )}\n            {!readOnly && groups.length > 1 && (\n              <DropdownMenuItem\n                onSelect={(e) => e.preventDefault()}\n                onMouseDown={() => startHold(selectedGroup.id)}\n                onMouseUp={cancelHold}\n                onMouseLeave={cancelHold}\n                onTouchStart={() => startHold(selectedGroup.id)}\n                onTouchEnd={cancelHold}\n                className=\"relative overflow-hidden text-destructive focus:text-destructive rounded-lg px-2 py-1.5\"\n              >\n                {holdingGroupId === selectedGroup.id && (\n                  <div\n                    className=\"absolute inset-0 bg-destructive/20 origin-left\"\n                    style={{ transform: `scaleX(${holdProgress / 100})` }}\n                  />\n                )}\n                <span className=\"relative z-10 flex items-center gap-2\">\n                  <IconTrash className=\"h-4 w-4 text-destructive\" />\n                  {holdingGroupId === selectedGroup.id\n                    ? \"Hold to delete...\"\n                    : \"Delete Group\"}\n                </span>\n              </DropdownMenuItem>\n            )}\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n          <DialogContent className=\"sm:max-w-sm\" showCloseButton={false}>\n            <Form\n              className=\"contents\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleCreateGroup();\n              }}\n            >\n              <DialogHeader>\n                <DialogTitle>Create Group</DialogTitle>\n                <DialogDescription>\n                  Create a new group to organize your bookmarks.\n                </DialogDescription>\n              </DialogHeader>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  placeholder=\"Enter group name\"\n                  value={newGroupName}\n                  onChange={(e) => setNewGroupName(e.target.value)}\n                  autoFocus\n                />\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button type=\"submit\" disabled={!newGroupName.trim()}>\n                  Create\n                </Button>\n              </DialogFooter>\n            </Form>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      {showUserMenu ? (\n        <>\n          <DropdownMenu>\n            <DropdownMenuTrigger\n              className=\"rounded-xl\"\n              render={\n                <Button\n                  variant=\"ghost\"\n                  className=\"w-44 justify-start gap-2 px-2 border-0\"\n                />\n              }\n            >\n              <UserAvatar name={userName} image={userImage} />\n              <span className=\"truncate\">{userName}</span>\n              <IconSelector className=\"ml-auto h-4 w-4 shrink-0 text-muted-foreground\" />\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\" className=\"rounded-2xl\">\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSettingsOpen(true)}\n                disabled={readOnly}\n              >\n                <IconSettings className=\"h-4 w-4\" />\n                Settings\n              </DropdownMenuItem>\n              {username && (\n                <DropdownMenuItem\n                  className=\"rounded-lg\"\n                  render={\n                    <a\n                      href={`/u/${username}`}\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                    />\n                  }\n                >\n                  <IconUser className=\"h-4 w-4\" />\n                  Public Profile\n                </DropdownMenuItem>\n              )}\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                render={\n                  <a href=\"/chrome\" target=\"_blank\" rel=\"noopener noreferrer\" />\n                }\n                disabled={readOnly}\n              >\n                <ChromeIcon />\n                Chrome Extension\n              </DropdownMenuItem>\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSignOutOpen(true)}\n                disabled={readOnly}\n              >\n                <IconLogout className=\"h-4 w-4\" />\n                Sign out\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n          <AlertDialog open={signOutOpen} onOpenChange={setSignOutOpen}>\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  Sign out?\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  You will need to sign in again to access your bookmarks.\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <AlertDialogCancel variant=\"ghost\">Cancel</AlertDialogCancel>\n                <AlertDialogAction\n                  variant=\"destructive\"\n                  onClick={handleSignOut}\n                >\n                  Sign out\n                </AlertDialogAction>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <AlertDialog\n            open={visibilityDialogOpen}\n            onOpenChange={(open) => {\n              if (isTogglingGroupVisibility) return;\n              setVisibilityDialogOpen(open);\n              if (!open) {\n                setPendingVisibilityGroupId(null);\n                setPendingVisibilityTarget(null);\n              }\n            }}\n          >\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  {pendingVisibilityTarget ? \"Make group public?\" : \"Make group private?\"}\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  {pendingVisibilityTarget\n                    ? \"All bookmarks in this group will become publicly visible on your profile.\"\n                    : \"All bookmarks in this group will no longer be publicly visible on your profile.\"}\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <Button\n                  variant=\"ghost\"\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    setVisibilityDialogOpen(false);\n                    setPendingVisibilityGroupId(null);\n                    setPendingVisibilityTarget(null);\n                  }}\n                >\n                  Cancel\n                </Button>\n                <Button\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    if (\n                      pendingVisibilityGroupId &&\n                      pendingVisibilityTarget !== null\n                    ) {\n                      onToggleGroupVisibility?.(\n                        pendingVisibilityGroupId,\n                        pendingVisibilityTarget,\n                      );\n                      initiatedToggleRef.current = true;\n                    }\n                  }}\n                >\n                  {isTogglingGroupVisibility && (\n                    <IconLoader2 className=\"h-4 w-4 animate-spin\" />\n                  )}\n                  {pendingVisibilityTarget ? \"Make Public\" : \"Make Private\"}\n                </Button>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <SettingsDialog\n            open={settingsOpen}\n            onOpenChange={setSettingsOpen}\n            user={{\n              name: userName,\n              email: userEmail,\n              image: userImage ?? null,\n            }}\n            profile={profile}\n          />\n        </>\n      ) : null}\n    </header>\n  );\n}\n\nfunction BmrksLogo({ size = 24 }: { size?: number }) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      aria-label=\"Logo\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12.432 17.949c.863 1.544 2.589 1.976 4.13 1.112c1.54 -.865 1.972 -2.594 1.048 -4.138c-.185 -.309 -.309 -.556 -.494 -.74c.247 .06 .555 .06 .925 .06c1.726 0 2.959 -1.234 2.959 -2.963c0 -1.73 -1.233 -2.965 -3.02 -2.965c-.37 0 -.617 0 -.925 .062c.185 -.185 .308 -.432 .493 -.74c.863 -1.545 .431 -3.274 -1.048 -4.138c-1.541 -.865 -3.205 -.433 -4.13 1.111c-.185 .309 -.308 .556 -.432 .803c-.123 -.247 -.246 -.494 -.431 -.803c-.802 -1.605 -2.528 -2.038 -4.007 -1.173c-1.541 .865 -1.973 2.594 -1.048 4.137c.185 .31 .308 .556 .493 .741c-.246 -.061 -.555 -.061 -.924 -.061c-1.788 0 -3.021 1.235 -3.021 2.964c0 1.729 1.233 2.964 3.02 2.964\" />\n      <path d=\"M4.073 21c4.286 -2.756 5.9 -5.254 7.927 -9\" />\n    </svg>\n  );\n}\n\nfunction UserAvatar({ name, image }: { name: string; image?: string | null }) {\n  if (image) {\n    return (\n      // eslint-disable-next-line @next/next/no-img-element\n      <img\n        src={image}\n        alt={name}\n        className=\"size-4.5 shrink-0 rounded-full object-cover\"\n      />\n    );\n  }\n\n  return (\n    <svg viewBox=\"0 0 32 32\" fill=\"none\" width=\"18\" height=\"18\">\n      <rect width=\"32\" height=\"32\" rx=\"16\" fill=\"#74B06F\" />\n      <text\n        x=\"50%\"\n        y=\"50%\"\n        dominantBaseline=\"central\"\n        textAnchor=\"middle\"\n        fill=\"white\"\n        fontSize=\"14\"\n        fontWeight=\"500\"\n      >\n        {name.charAt(0).toUpperCase()}\n      </text>\n    </svg>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}\n","structuredPatch":[{"oldStart":67,"oldLines":6,"newStart":67,"newLines":7,"lines":["   userImage?: string | null;","   username?: string | null;","   profile?: ProfileData;","+  onExport?: () => void;","   readOnly?: boolean;","   showUserMenu?: boolean;","   logoSize?: number;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"c64e8b03-95e4-4621-a0ec-508cf50abff7"}
{"parentUuid":"295bea83-374b-4a0a-a5b5-e70f18a38e43","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014T7bMXSQVLzZSqXcUZ7DX3","toolUseID":"toolu_014T7bMXSQVLzZSqXcUZ7DX3","timestamp":"2026-02-10T17:50:46.002Z","uuid":"44454346-9a36-4b1c-b9c4-86693c83c57f"}
{"parentUuid":"07650d2a-c5f5-4207-9737-d9c30a8f1550","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015K7XNmqZ4rEscDEdCRh2HW","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/header.tsx has been updated successfully."}]},"uuid":"91b968c6-fc72-4c3f-ac44-db8300b28d6e","timestamp":"2026-02-10T17:50:46.015Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/header.tsx","oldString":"  profile,\n  readOnly = false,","newString":"  profile,\n  onExport,\n  readOnly = false,","originalFile":"\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport dynamic from \"next/dynamic\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  IconSelector,\n  IconPlus,\n  IconCheck,\n  IconTrash,\n  IconSettings,\n  IconLogout,\n  IconWorld,\n  IconWorldOff,\n  IconUser,\n  IconLoader2,\n} from \"@tabler/icons-react\";\nimport { signOut } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\n\nconst SettingsDialog = dynamic(\n  () => import(\"@/components/settings-dialog\").then((m) => m.SettingsDialog),\n  { ssr: false },\n);\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  onToggleGroupVisibility?: (id: string, isPublic: boolean) => void;\n  isTogglingGroupVisibility?: boolean;\n  userName: string;\n  userEmail: string;\n  userImage?: string | null;\n  username?: string | null;\n  profile?: ProfileData;\n  onExport?: () => void;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}\n\nexport function Header({\n  groups,\n  selectedGroup,\n  onSelectGroup,\n  onCreateGroup,\n  onDeleteGroup,\n  onToggleGroupVisibility,\n  isTogglingGroupVisibility,\n  userName,\n  userEmail,\n  userImage,\n  username,\n  profile,\n  readOnly = false,\n  showUserMenu = true,\n  logoSize = 24,\n}: HeaderProps) {\n  const router = useRouter();\n  const [newGroupName, setNewGroupName] = useState(\"\");\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [signOutOpen, setSignOutOpen] = useState(false);\n  const [visibilityDialogOpen, setVisibilityDialogOpen] = useState(false);\n  const [pendingVisibilityGroupId, setPendingVisibilityGroupId] = useState<\n    string | null\n  >(null);\n  const [pendingVisibilityTarget, setPendingVisibilityTarget] = useState<\n    boolean | null\n  >(null);\n  const [holdingGroupId, setHoldingGroupId] = useState<string | null>(null);\n  const [holdProgress, setHoldProgress] = useState(0);\n  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const holdStartRef = useRef<number>(0);\n  const initiatedToggleRef = useRef(false);\n\n  useEffect(() => {\n    if (!isTogglingGroupVisibility && initiatedToggleRef.current) {\n      initiatedToggleRef.current = false;\n      const timer = setTimeout(() => {\n        setVisibilityDialogOpen(false);\n        setPendingVisibilityGroupId(null);\n        setPendingVisibilityTarget(null);\n      }, 0);\n      return () => clearTimeout(timer);\n    }\n  }, [isTogglingGroupVisibility]);\n\n  const handleSignOut = async () => {\n    setSignOutOpen(false);\n    await signOut();\n    router.push(\"/login\");\n  };\n\n  const handleCreateGroup = () => {\n    if (newGroupName.trim()) {\n      onCreateGroup(newGroupName.trim());\n      setNewGroupName(\"\");\n      setDialogOpen(false);\n    }\n  };\n\n  const cancelHold = useCallback(() => {\n    if (holdTimerRef.current) {\n      clearTimeout(holdTimerRef.current);\n    }\n    setHoldingGroupId(null);\n    setHoldProgress(0);\n  }, []);\n\n  const startHold = useCallback(\n    (groupId: string) => {\n      if (readOnly) return;\n      if (groups.length <= 1) return;\n      setHoldingGroupId(groupId);\n      holdStartRef.current = Date.now();\n\n      const updateProgress = () => {\n        const elapsed = Date.now() - holdStartRef.current;\n        const progress = Math.min((elapsed / 2000) * 100, 100);\n        setHoldProgress(progress);\n\n        if (progress >= 100) {\n          onDeleteGroup?.(groupId);\n          cancelHold();\n        } else {\n          holdTimerRef.current = setTimeout(updateProgress, 16);\n        }\n      };\n\n      holdTimerRef.current = setTimeout(updateProgress, 16);\n    },\n    [groups.length, onDeleteGroup, cancelHold, readOnly],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (holdTimerRef.current) {\n        clearTimeout(holdTimerRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <header\n      className={cn(\n        \"flex items-center justify-between\",\n        readOnly ? \"px-4 py-2\" : \"px-6 py-3\",\n      )}\n    >\n      <div className=\"flex items-center gap-2\">\n        <BmrksLogo size={logoSize} />\n        <span className=\"text-muted-foreground\">/</span>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            className=\"rounded-xl\"\n            render={<Button variant=\"ghost\" className=\"gap-2 px-2\" />}\n          >\n            <span\n              className=\"h-2.5 w-2.5 rounded-full\"\n              style={{ backgroundColor: selectedGroup.color }}\n            />\n            <span>{selectedGroup.name}</span>\n            <IconSelector className=\"h-4 w-4 text-muted-foreground\" />\n          </DropdownMenuTrigger>\n          <DropdownMenuContent\n            align=\"start\"\n            className=\"w-48 space-y-1 rounded-xl\"\n          >\n            {groups.map((group) => (\n              <DropdownMenuItem\n                key={group.id}\n                onClick={() => onSelectGroup(group.id)}\n                className={cn(\n                  \"flex items-start justify-between rounded-lg px-2 py-1.5\",\n                  group.id === selectedGroup.id && \"bg-accent\",\n                )}\n              >\n                <div className=\"flex items-start gap-2\">\n                  <span\n                    className=\"mt-[5px] h-2.5 w-2.5 shrink-0 rounded-full\"\n                    style={{ backgroundColor: group.color }}\n                  />\n                  <span>{group.name}</span>\n                  {group.isPublic && (\n                    <IconWorld className=\"mt-1 h-3 w-3 shrink-0 text-muted-foreground\" />\n                  )}\n                </div>\n                {group.id === selectedGroup.id ? (\n                  <IconCheck className=\"mt-0.5 h-4 w-4 shrink-0\" />\n                ) : (\n                  <span className=\"mt-0.5 shrink-0 text-xs text-muted-foreground\">\n                    {group.bookmarkCount ?? 0}\n                  </span>\n                )}\n              </DropdownMenuItem>\n            ))}\n            <DropdownMenuItem\n              onClick={() => {\n                if (!readOnly) setDialogOpen(true);\n              }}\n              disabled={readOnly}\n              className=\"rounded-lg w-full px-2 py-1.5\"\n            >\n              <IconPlus className=\"h-4 w-4 mr-0\" />\n              Create Group\n            </DropdownMenuItem>\n            {!readOnly && onToggleGroupVisibility && (\n              <DropdownMenuItem\n                onClick={() => {\n                  setPendingVisibilityGroupId(selectedGroup.id);\n                  setPendingVisibilityTarget(!selectedGroup.isPublic);\n                  setVisibilityDialogOpen(true);\n                }}\n                className=\"rounded-lg px-2 py-1.5\"\n              >\n                {selectedGroup.isPublic ? (\n                  <>\n                    <IconWorldOff className=\"h-4 w-4\" />\n                    Make Private\n                  </>\n                ) : (\n                  <>\n                    <IconWorld className=\"h-4 w-4\" />\n                    Make Public\n                  </>\n                )}\n              </DropdownMenuItem>\n            )}\n            {!readOnly && groups.length > 1 && (\n              <DropdownMenuItem\n                onSelect={(e) => e.preventDefault()}\n                onMouseDown={() => startHold(selectedGroup.id)}\n                onMouseUp={cancelHold}\n                onMouseLeave={cancelHold}\n                onTouchStart={() => startHold(selectedGroup.id)}\n                onTouchEnd={cancelHold}\n                className=\"relative overflow-hidden text-destructive focus:text-destructive rounded-lg px-2 py-1.5\"\n              >\n                {holdingGroupId === selectedGroup.id && (\n                  <div\n                    className=\"absolute inset-0 bg-destructive/20 origin-left\"\n                    style={{ transform: `scaleX(${holdProgress / 100})` }}\n                  />\n                )}\n                <span className=\"relative z-10 flex items-center gap-2\">\n                  <IconTrash className=\"h-4 w-4 text-destructive\" />\n                  {holdingGroupId === selectedGroup.id\n                    ? \"Hold to delete...\"\n                    : \"Delete Group\"}\n                </span>\n              </DropdownMenuItem>\n            )}\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n          <DialogContent className=\"sm:max-w-sm\" showCloseButton={false}>\n            <Form\n              className=\"contents\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleCreateGroup();\n              }}\n            >\n              <DialogHeader>\n                <DialogTitle>Create Group</DialogTitle>\n                <DialogDescription>\n                  Create a new group to organize your bookmarks.\n                </DialogDescription>\n              </DialogHeader>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  placeholder=\"Enter group name\"\n                  value={newGroupName}\n                  onChange={(e) => setNewGroupName(e.target.value)}\n                  autoFocus\n                />\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button type=\"submit\" disabled={!newGroupName.trim()}>\n                  Create\n                </Button>\n              </DialogFooter>\n            </Form>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      {showUserMenu ? (\n        <>\n          <DropdownMenu>\n            <DropdownMenuTrigger\n              className=\"rounded-xl\"\n              render={\n                <Button\n                  variant=\"ghost\"\n                  className=\"w-44 justify-start gap-2 px-2 border-0\"\n                />\n              }\n            >\n              <UserAvatar name={userName} image={userImage} />\n              <span className=\"truncate\">{userName}</span>\n              <IconSelector className=\"ml-auto h-4 w-4 shrink-0 text-muted-foreground\" />\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\" className=\"rounded-2xl\">\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSettingsOpen(true)}\n                disabled={readOnly}\n              >\n                <IconSettings className=\"h-4 w-4\" />\n                Settings\n              </DropdownMenuItem>\n              {username && (\n                <DropdownMenuItem\n                  className=\"rounded-lg\"\n                  render={\n                    <a\n                      href={`/u/${username}`}\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                    />\n                  }\n                >\n                  <IconUser className=\"h-4 w-4\" />\n                  Public Profile\n                </DropdownMenuItem>\n              )}\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                render={\n                  <a href=\"/chrome\" target=\"_blank\" rel=\"noopener noreferrer\" />\n                }\n                disabled={readOnly}\n              >\n                <ChromeIcon />\n                Chrome Extension\n              </DropdownMenuItem>\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSignOutOpen(true)}\n                disabled={readOnly}\n              >\n                <IconLogout className=\"h-4 w-4\" />\n                Sign out\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n          <AlertDialog open={signOutOpen} onOpenChange={setSignOutOpen}>\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  Sign out?\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  You will need to sign in again to access your bookmarks.\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <AlertDialogCancel variant=\"ghost\">Cancel</AlertDialogCancel>\n                <AlertDialogAction\n                  variant=\"destructive\"\n                  onClick={handleSignOut}\n                >\n                  Sign out\n                </AlertDialogAction>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <AlertDialog\n            open={visibilityDialogOpen}\n            onOpenChange={(open) => {\n              if (isTogglingGroupVisibility) return;\n              setVisibilityDialogOpen(open);\n              if (!open) {\n                setPendingVisibilityGroupId(null);\n                setPendingVisibilityTarget(null);\n              }\n            }}\n          >\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  {pendingVisibilityTarget ? \"Make group public?\" : \"Make group private?\"}\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  {pendingVisibilityTarget\n                    ? \"All bookmarks in this group will become publicly visible on your profile.\"\n                    : \"All bookmarks in this group will no longer be publicly visible on your profile.\"}\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <Button\n                  variant=\"ghost\"\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    setVisibilityDialogOpen(false);\n                    setPendingVisibilityGroupId(null);\n                    setPendingVisibilityTarget(null);\n                  }}\n                >\n                  Cancel\n                </Button>\n                <Button\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    if (\n                      pendingVisibilityGroupId &&\n                      pendingVisibilityTarget !== null\n                    ) {\n                      onToggleGroupVisibility?.(\n                        pendingVisibilityGroupId,\n                        pendingVisibilityTarget,\n                      );\n                      initiatedToggleRef.current = true;\n                    }\n                  }}\n                >\n                  {isTogglingGroupVisibility && (\n                    <IconLoader2 className=\"h-4 w-4 animate-spin\" />\n                  )}\n                  {pendingVisibilityTarget ? \"Make Public\" : \"Make Private\"}\n                </Button>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <SettingsDialog\n            open={settingsOpen}\n            onOpenChange={setSettingsOpen}\n            user={{\n              name: userName,\n              email: userEmail,\n              image: userImage ?? null,\n            }}\n            profile={profile}\n          />\n        </>\n      ) : null}\n    </header>\n  );\n}\n\nfunction BmrksLogo({ size = 24 }: { size?: number }) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      aria-label=\"Logo\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12.432 17.949c.863 1.544 2.589 1.976 4.13 1.112c1.54 -.865 1.972 -2.594 1.048 -4.138c-.185 -.309 -.309 -.556 -.494 -.74c.247 .06 .555 .06 .925 .06c1.726 0 2.959 -1.234 2.959 -2.963c0 -1.73 -1.233 -2.965 -3.02 -2.965c-.37 0 -.617 0 -.925 .062c.185 -.185 .308 -.432 .493 -.74c.863 -1.545 .431 -3.274 -1.048 -4.138c-1.541 -.865 -3.205 -.433 -4.13 1.111c-.185 .309 -.308 .556 -.432 .803c-.123 -.247 -.246 -.494 -.431 -.803c-.802 -1.605 -2.528 -2.038 -4.007 -1.173c-1.541 .865 -1.973 2.594 -1.048 4.137c.185 .31 .308 .556 .493 .741c-.246 -.061 -.555 -.061 -.924 -.061c-1.788 0 -3.021 1.235 -3.021 2.964c0 1.729 1.233 2.964 3.02 2.964\" />\n      <path d=\"M4.073 21c4.286 -2.756 5.9 -5.254 7.927 -9\" />\n    </svg>\n  );\n}\n\nfunction UserAvatar({ name, image }: { name: string; image?: string | null }) {\n  if (image) {\n    return (\n      // eslint-disable-next-line @next/next/no-img-element\n      <img\n        src={image}\n        alt={name}\n        className=\"size-4.5 shrink-0 rounded-full object-cover\"\n      />\n    );\n  }\n\n  return (\n    <svg viewBox=\"0 0 32 32\" fill=\"none\" width=\"18\" height=\"18\">\n      <rect width=\"32\" height=\"32\" rx=\"16\" fill=\"#74B06F\" />\n      <text\n        x=\"50%\"\n        y=\"50%\"\n        dominantBaseline=\"central\"\n        textAnchor=\"middle\"\n        fill=\"white\"\n        fontSize=\"14\"\n        fontWeight=\"500\"\n      >\n        {name.charAt(0).toUpperCase()}\n      </text>\n    </svg>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}\n","structuredPatch":[{"oldStart":86,"oldLines":6,"newStart":86,"newLines":7,"lines":["   userImage,","   username,","   profile,","+  onExport,","   readOnly = false,","   showUserMenu = true,","   logoSize = 24,"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"07650d2a-c5f5-4207-9737-d9c30a8f1550"}
{"parentUuid":"91b968c6-fc72-4c3f-ac44-db8300b28d6e","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_015K7XNmqZ4rEscDEdCRh2HW","toolUseID":"toolu_015K7XNmqZ4rEscDEdCRh2HW","timestamp":"2026-02-10T17:50:46.015Z","uuid":"54d148bb-58ef-4ce7-a27c-c8e595a41c7d"}
{"parentUuid":"f831486f-f743-4244-86cc-7c850b637f55","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YcALHKgukAtNiCVyh7UjP8","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/header.tsx has been updated successfully."}]},"uuid":"cc63a103-5d12-4285-9e53-3849527ee9c8","timestamp":"2026-02-10T17:50:46.022Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/header.tsx","oldString":"            profile={profile}\n          />","newString":"            profile={profile}\n            onExport={onExport}\n          />","originalFile":"\"use client\";\n\nimport { useState, useRef, useEffect, useCallback } from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport dynamic from \"next/dynamic\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  AlertDialog,\n  AlertDialogAction,\n  AlertDialogCancel,\n  AlertDialogContent,\n  AlertDialogDescription,\n  AlertDialogFooter,\n  AlertDialogHeader,\n  AlertDialogTitle,\n} from \"@/components/ui/alert-dialog\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport {\n  IconSelector,\n  IconPlus,\n  IconCheck,\n  IconTrash,\n  IconSettings,\n  IconLogout,\n  IconWorld,\n  IconWorldOff,\n  IconUser,\n  IconLoader2,\n} from \"@tabler/icons-react\";\nimport { signOut } from \"@/lib/auth-client\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { cn } from \"@/lib/utils\";\nimport { type GroupItem } from \"@/lib/schema\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\n\nconst SettingsDialog = dynamic(\n  () => import(\"@/components/settings-dialog\").then((m) => m.SettingsDialog),\n  { ssr: false },\n);\n\ninterface HeaderProps {\n  groups: GroupItem[];\n  selectedGroup: GroupItem;\n  onSelectGroup: (id: string) => void;\n  onCreateGroup: (name: string) => void;\n  onDeleteGroup?: (id: string) => void;\n  onToggleGroupVisibility?: (id: string, isPublic: boolean) => void;\n  isTogglingGroupVisibility?: boolean;\n  userName: string;\n  userEmail: string;\n  userImage?: string | null;\n  username?: string | null;\n  profile?: ProfileData;\n  onExport?: () => void;\n  readOnly?: boolean;\n  showUserMenu?: boolean;\n  logoSize?: number;\n}\n\nexport function Header({\n  groups,\n  selectedGroup,\n  onSelectGroup,\n  onCreateGroup,\n  onDeleteGroup,\n  onToggleGroupVisibility,\n  isTogglingGroupVisibility,\n  userName,\n  userEmail,\n  userImage,\n  username,\n  profile,\n  onExport,\n  readOnly = false,\n  showUserMenu = true,\n  logoSize = 24,\n}: HeaderProps) {\n  const router = useRouter();\n  const [newGroupName, setNewGroupName] = useState(\"\");\n  const [dialogOpen, setDialogOpen] = useState(false);\n  const [settingsOpen, setSettingsOpen] = useState(false);\n  const [signOutOpen, setSignOutOpen] = useState(false);\n  const [visibilityDialogOpen, setVisibilityDialogOpen] = useState(false);\n  const [pendingVisibilityGroupId, setPendingVisibilityGroupId] = useState<\n    string | null\n  >(null);\n  const [pendingVisibilityTarget, setPendingVisibilityTarget] = useState<\n    boolean | null\n  >(null);\n  const [holdingGroupId, setHoldingGroupId] = useState<string | null>(null);\n  const [holdProgress, setHoldProgress] = useState(0);\n  const holdTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const holdStartRef = useRef<number>(0);\n  const initiatedToggleRef = useRef(false);\n\n  useEffect(() => {\n    if (!isTogglingGroupVisibility && initiatedToggleRef.current) {\n      initiatedToggleRef.current = false;\n      const timer = setTimeout(() => {\n        setVisibilityDialogOpen(false);\n        setPendingVisibilityGroupId(null);\n        setPendingVisibilityTarget(null);\n      }, 0);\n      return () => clearTimeout(timer);\n    }\n  }, [isTogglingGroupVisibility]);\n\n  const handleSignOut = async () => {\n    setSignOutOpen(false);\n    await signOut();\n    router.push(\"/login\");\n  };\n\n  const handleCreateGroup = () => {\n    if (newGroupName.trim()) {\n      onCreateGroup(newGroupName.trim());\n      setNewGroupName(\"\");\n      setDialogOpen(false);\n    }\n  };\n\n  const cancelHold = useCallback(() => {\n    if (holdTimerRef.current) {\n      clearTimeout(holdTimerRef.current);\n    }\n    setHoldingGroupId(null);\n    setHoldProgress(0);\n  }, []);\n\n  const startHold = useCallback(\n    (groupId: string) => {\n      if (readOnly) return;\n      if (groups.length <= 1) return;\n      setHoldingGroupId(groupId);\n      holdStartRef.current = Date.now();\n\n      const updateProgress = () => {\n        const elapsed = Date.now() - holdStartRef.current;\n        const progress = Math.min((elapsed / 2000) * 100, 100);\n        setHoldProgress(progress);\n\n        if (progress >= 100) {\n          onDeleteGroup?.(groupId);\n          cancelHold();\n        } else {\n          holdTimerRef.current = setTimeout(updateProgress, 16);\n        }\n      };\n\n      holdTimerRef.current = setTimeout(updateProgress, 16);\n    },\n    [groups.length, onDeleteGroup, cancelHold, readOnly],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (holdTimerRef.current) {\n        clearTimeout(holdTimerRef.current);\n      }\n    };\n  }, []);\n\n  return (\n    <header\n      className={cn(\n        \"flex items-center justify-between\",\n        readOnly ? \"px-4 py-2\" : \"px-6 py-3\",\n      )}\n    >\n      <div className=\"flex items-center gap-2\">\n        <BmrksLogo size={logoSize} />\n        <span className=\"text-muted-foreground\">/</span>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            className=\"rounded-xl\"\n            render={<Button variant=\"ghost\" className=\"gap-2 px-2\" />}\n          >\n            <span\n              className=\"h-2.5 w-2.5 rounded-full\"\n              style={{ backgroundColor: selectedGroup.color }}\n            />\n            <span>{selectedGroup.name}</span>\n            <IconSelector className=\"h-4 w-4 text-muted-foreground\" />\n          </DropdownMenuTrigger>\n          <DropdownMenuContent\n            align=\"start\"\n            className=\"w-48 space-y-1 rounded-xl\"\n          >\n            {groups.map((group) => (\n              <DropdownMenuItem\n                key={group.id}\n                onClick={() => onSelectGroup(group.id)}\n                className={cn(\n                  \"flex items-start justify-between rounded-lg px-2 py-1.5\",\n                  group.id === selectedGroup.id && \"bg-accent\",\n                )}\n              >\n                <div className=\"flex items-start gap-2\">\n                  <span\n                    className=\"mt-[5px] h-2.5 w-2.5 shrink-0 rounded-full\"\n                    style={{ backgroundColor: group.color }}\n                  />\n                  <span>{group.name}</span>\n                  {group.isPublic && (\n                    <IconWorld className=\"mt-1 h-3 w-3 shrink-0 text-muted-foreground\" />\n                  )}\n                </div>\n                {group.id === selectedGroup.id ? (\n                  <IconCheck className=\"mt-0.5 h-4 w-4 shrink-0\" />\n                ) : (\n                  <span className=\"mt-0.5 shrink-0 text-xs text-muted-foreground\">\n                    {group.bookmarkCount ?? 0}\n                  </span>\n                )}\n              </DropdownMenuItem>\n            ))}\n            <DropdownMenuItem\n              onClick={() => {\n                if (!readOnly) setDialogOpen(true);\n              }}\n              disabled={readOnly}\n              className=\"rounded-lg w-full px-2 py-1.5\"\n            >\n              <IconPlus className=\"h-4 w-4 mr-0\" />\n              Create Group\n            </DropdownMenuItem>\n            {!readOnly && onToggleGroupVisibility && (\n              <DropdownMenuItem\n                onClick={() => {\n                  setPendingVisibilityGroupId(selectedGroup.id);\n                  setPendingVisibilityTarget(!selectedGroup.isPublic);\n                  setVisibilityDialogOpen(true);\n                }}\n                className=\"rounded-lg px-2 py-1.5\"\n              >\n                {selectedGroup.isPublic ? (\n                  <>\n                    <IconWorldOff className=\"h-4 w-4\" />\n                    Make Private\n                  </>\n                ) : (\n                  <>\n                    <IconWorld className=\"h-4 w-4\" />\n                    Make Public\n                  </>\n                )}\n              </DropdownMenuItem>\n            )}\n            {!readOnly && groups.length > 1 && (\n              <DropdownMenuItem\n                onSelect={(e) => e.preventDefault()}\n                onMouseDown={() => startHold(selectedGroup.id)}\n                onMouseUp={cancelHold}\n                onMouseLeave={cancelHold}\n                onTouchStart={() => startHold(selectedGroup.id)}\n                onTouchEnd={cancelHold}\n                className=\"relative overflow-hidden text-destructive focus:text-destructive rounded-lg px-2 py-1.5\"\n              >\n                {holdingGroupId === selectedGroup.id && (\n                  <div\n                    className=\"absolute inset-0 bg-destructive/20 origin-left\"\n                    style={{ transform: `scaleX(${holdProgress / 100})` }}\n                  />\n                )}\n                <span className=\"relative z-10 flex items-center gap-2\">\n                  <IconTrash className=\"h-4 w-4 text-destructive\" />\n                  {holdingGroupId === selectedGroup.id\n                    ? \"Hold to delete...\"\n                    : \"Delete Group\"}\n                </span>\n              </DropdownMenuItem>\n            )}\n          </DropdownMenuContent>\n        </DropdownMenu>\n        <Dialog open={dialogOpen} onOpenChange={setDialogOpen}>\n          <DialogContent className=\"sm:max-w-sm\" showCloseButton={false}>\n            <Form\n              className=\"contents\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleCreateGroup();\n              }}\n            >\n              <DialogHeader>\n                <DialogTitle>Create Group</DialogTitle>\n                <DialogDescription>\n                  Create a new group to organize your bookmarks.\n                </DialogDescription>\n              </DialogHeader>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  placeholder=\"Enter group name\"\n                  value={newGroupName}\n                  onChange={(e) => setNewGroupName(e.target.value)}\n                  autoFocus\n                />\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button type=\"submit\" disabled={!newGroupName.trim()}>\n                  Create\n                </Button>\n              </DialogFooter>\n            </Form>\n          </DialogContent>\n        </Dialog>\n      </div>\n\n      {showUserMenu ? (\n        <>\n          <DropdownMenu>\n            <DropdownMenuTrigger\n              className=\"rounded-xl\"\n              render={\n                <Button\n                  variant=\"ghost\"\n                  className=\"w-44 justify-start gap-2 px-2 border-0\"\n                />\n              }\n            >\n              <UserAvatar name={userName} image={userImage} />\n              <span className=\"truncate\">{userName}</span>\n              <IconSelector className=\"ml-auto h-4 w-4 shrink-0 text-muted-foreground\" />\n            </DropdownMenuTrigger>\n            <DropdownMenuContent align=\"end\" className=\"rounded-2xl\">\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSettingsOpen(true)}\n                disabled={readOnly}\n              >\n                <IconSettings className=\"h-4 w-4\" />\n                Settings\n              </DropdownMenuItem>\n              {username && (\n                <DropdownMenuItem\n                  className=\"rounded-lg\"\n                  render={\n                    <a\n                      href={`/u/${username}`}\n                      target=\"_blank\"\n                      rel=\"noopener noreferrer\"\n                    />\n                  }\n                >\n                  <IconUser className=\"h-4 w-4\" />\n                  Public Profile\n                </DropdownMenuItem>\n              )}\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                render={\n                  <a href=\"/chrome\" target=\"_blank\" rel=\"noopener noreferrer\" />\n                }\n                disabled={readOnly}\n              >\n                <ChromeIcon />\n                Chrome Extension\n              </DropdownMenuItem>\n              <DropdownMenuItem\n                className=\"rounded-lg\"\n                onClick={() => setSignOutOpen(true)}\n                disabled={readOnly}\n              >\n                <IconLogout className=\"h-4 w-4\" />\n                Sign out\n              </DropdownMenuItem>\n            </DropdownMenuContent>\n          </DropdownMenu>\n          <AlertDialog open={signOutOpen} onOpenChange={setSignOutOpen}>\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  Sign out?\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  You will need to sign in again to access your bookmarks.\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <AlertDialogCancel variant=\"ghost\">Cancel</AlertDialogCancel>\n                <AlertDialogAction\n                  variant=\"destructive\"\n                  onClick={handleSignOut}\n                >\n                  Sign out\n                </AlertDialogAction>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <AlertDialog\n            open={visibilityDialogOpen}\n            onOpenChange={(open) => {\n              if (isTogglingGroupVisibility) return;\n              setVisibilityDialogOpen(open);\n              if (!open) {\n                setPendingVisibilityGroupId(null);\n                setPendingVisibilityTarget(null);\n              }\n            }}\n          >\n            <AlertDialogContent>\n              <AlertDialogHeader>\n                <AlertDialogTitle className=\"font-semibold text-xl\">\n                  {pendingVisibilityTarget ? \"Make group public?\" : \"Make group private?\"}\n                </AlertDialogTitle>\n                <AlertDialogDescription>\n                  {pendingVisibilityTarget\n                    ? \"All bookmarks in this group will become publicly visible on your profile.\"\n                    : \"All bookmarks in this group will no longer be publicly visible on your profile.\"}\n                </AlertDialogDescription>\n              </AlertDialogHeader>\n              <AlertDialogFooter>\n                <Button\n                  variant=\"ghost\"\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    setVisibilityDialogOpen(false);\n                    setPendingVisibilityGroupId(null);\n                    setPendingVisibilityTarget(null);\n                  }}\n                >\n                  Cancel\n                </Button>\n                <Button\n                  disabled={isTogglingGroupVisibility}\n                  onClick={() => {\n                    if (\n                      pendingVisibilityGroupId &&\n                      pendingVisibilityTarget !== null\n                    ) {\n                      onToggleGroupVisibility?.(\n                        pendingVisibilityGroupId,\n                        pendingVisibilityTarget,\n                      );\n                      initiatedToggleRef.current = true;\n                    }\n                  }}\n                >\n                  {isTogglingGroupVisibility && (\n                    <IconLoader2 className=\"h-4 w-4 animate-spin\" />\n                  )}\n                  {pendingVisibilityTarget ? \"Make Public\" : \"Make Private\"}\n                </Button>\n              </AlertDialogFooter>\n            </AlertDialogContent>\n          </AlertDialog>\n          <SettingsDialog\n            open={settingsOpen}\n            onOpenChange={setSettingsOpen}\n            user={{\n              name: userName,\n              email: userEmail,\n              image: userImage ?? null,\n            }}\n            profile={profile}\n          />\n        </>\n      ) : null}\n    </header>\n  );\n}\n\nfunction BmrksLogo({ size = 24 }: { size?: number }) {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width={size}\n      height={size}\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      aria-label=\"Logo\"\n    >\n      <path stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\" />\n      <path d=\"M12.432 17.949c.863 1.544 2.589 1.976 4.13 1.112c1.54 -.865 1.972 -2.594 1.048 -4.138c-.185 -.309 -.309 -.556 -.494 -.74c.247 .06 .555 .06 .925 .06c1.726 0 2.959 -1.234 2.959 -2.963c0 -1.73 -1.233 -2.965 -3.02 -2.965c-.37 0 -.617 0 -.925 .062c.185 -.185 .308 -.432 .493 -.74c.863 -1.545 .431 -3.274 -1.048 -4.138c-1.541 -.865 -3.205 -.433 -4.13 1.111c-.185 .309 -.308 .556 -.432 .803c-.123 -.247 -.246 -.494 -.431 -.803c-.802 -1.605 -2.528 -2.038 -4.007 -1.173c-1.541 .865 -1.973 2.594 -1.048 4.137c.185 .31 .308 .556 .493 .741c-.246 -.061 -.555 -.061 -.924 -.061c-1.788 0 -3.021 1.235 -3.021 2.964c0 1.729 1.233 2.964 3.02 2.964\" />\n      <path d=\"M4.073 21c4.286 -2.756 5.9 -5.254 7.927 -9\" />\n    </svg>\n  );\n}\n\nfunction UserAvatar({ name, image }: { name: string; image?: string | null }) {\n  if (image) {\n    return (\n      // eslint-disable-next-line @next/next/no-img-element\n      <img\n        src={image}\n        alt={name}\n        className=\"size-4.5 shrink-0 rounded-full object-cover\"\n      />\n    );\n  }\n\n  return (\n    <svg viewBox=\"0 0 32 32\" fill=\"none\" width=\"18\" height=\"18\">\n      <rect width=\"32\" height=\"32\" rx=\"16\" fill=\"#74B06F\" />\n      <text\n        x=\"50%\"\n        y=\"50%\"\n        dominantBaseline=\"central\"\n        textAnchor=\"middle\"\n        fill=\"white\"\n        fontSize=\"14\"\n        fontWeight=\"500\"\n      >\n        {name.charAt(0).toUpperCase()}\n      </text>\n    </svg>\n  );\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"16\"\n      height=\"16\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}\n","structuredPatch":[{"oldStart":472,"oldLines":6,"newStart":472,"newLines":7,"lines":["               image: userImage ?? null,","             }}","             profile={profile}","+            onExport={onExport}","           />","         </>","       ) : null}"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f831486f-f743-4244-86cc-7c850b637f55"}
{"parentUuid":"cc63a103-5d12-4285-9e53-3849527ee9c8","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01YcALHKgukAtNiCVyh7UjP8","toolUseID":"toolu_01YcALHKgukAtNiCVyh7UjP8","timestamp":"2026-02-10T17:50:46.022Z","uuid":"f5f84851-3ffd-44cc-aade-6d40a5487032"}
{"type":"file-history-snapshot","messageId":"d8d18afe-57eb-4d56-81f7-4099c6ded085","snapshot":{"messageId":"06123b67-0019-4aec-aa67-ba0dfdf62319","trackedFileBackups":{"components/dashboard-content.tsx":{"backupFileName":"d30ebca3ed1ec74d@v1","version":1,"backupTime":"2026-02-10T17:49:53.671Z"},"components/header.tsx":{"backupFileName":"1d89d7abd201ae59@v1","version":1,"backupTime":"2026-02-10T17:50:45.999Z"},"components/multi-select-toolbar.tsx":{"backupFileName":"03c604d0979a135a@v1","version":1,"backupTime":"2026-02-10T17:50:46.028Z"}},"timestamp":"2026-02-10T17:48:34.297Z"},"isSnapshotUpdate":true}
{"parentUuid":"d8d18afe-57eb-4d56-81f7-4099c6ded085","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011FZCgAvpHszp26qMqHMUhd","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx has been updated successfully."}]},"uuid":"9ca7b4c1-aea7-436b-9aab-c3647ed95c5d","timestamp":"2026-02-10T17:50:46.028Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","oldString":"import { Button } from \"@/components/ui/button\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";","newString":"import { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";","originalFile":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}\n","structuredPatch":[{"oldStart":3,"oldLines":11,"newStart":3,"newLines":20,"lines":[" import { motion } from \"motion/react\";"," import { Button } from \"@/components/ui/button\";"," import {","+  DropdownMenu,","+  DropdownMenuContent,","+  DropdownMenuItem,","+  DropdownMenuTrigger,","+} from \"@/components/ui/dropdown-menu\";","+import {","   IconListCheck,","   IconX,","   IconDragDrop,","   IconCopyCheckFilled,","   IconTrash,","+  IconFileExport,","+  IconFileTypeCsv,","+  IconJson,","   IconWorld,","   IconWorldOff,"," } from \"@tabler/icons-react\";"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d8d18afe-57eb-4d56-81f7-4099c6ded085"}
{"parentUuid":"9ca7b4c1-aea7-436b-9aab-c3647ed95c5d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_011FZCgAvpHszp26qMqHMUhd","toolUseID":"toolu_011FZCgAvpHszp26qMqHMUhd","timestamp":"2026-02-10T17:50:46.029Z","uuid":"e7d7f668-e178-48ba-9a9c-3ce5e21eb23a"}
{"parentUuid":"0dedd721-e20c-4a43-b728-2c39dc7e3528","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GYmKyEFo8t1kBiNbEfrSWz","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx has been updated successfully."}]},"uuid":"0e44d56f-ea0c-4471-9610-56e9c8b0221b","timestamp":"2026-02-10T17:50:46.053Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","oldString":"  onCopyUrls: () => void;\n  onDelete: () => void;","newString":"  onCopyUrls: () => void;\n  onExport: (format: \"csv\" | \"json\") => void;\n  onDelete: () => void;","originalFile":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}\n","structuredPatch":[{"oldStart":26,"oldLines":6,"newStart":26,"newLines":7,"lines":["   onSelectAll: () => void;","   onMove: () => void;","   onCopyUrls: () => void;","+  onExport: (format: \"csv\" | \"json\") => void;","   onDelete: () => void;","   onClose: () => void;","   hasUsername?: boolean;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0dedd721-e20c-4a43-b728-2c39dc7e3528"}
{"parentUuid":"0e44d56f-ea0c-4471-9610-56e9c8b0221b","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01GYmKyEFo8t1kBiNbEfrSWz","toolUseID":"toolu_01GYmKyEFo8t1kBiNbEfrSWz","timestamp":"2026-02-10T17:50:46.054Z","uuid":"2d907278-8c1f-4b2a-a94b-bb557a01b842"}
{"parentUuid":"0c08ab55-6a81-4d41-8ee1-6ed0ed806086","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0193icakncV9UQC183iZEw14","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx has been updated successfully."}]},"uuid":"e5e9b25a-c6cd-4ff2-9f8c-c913f10162d5","timestamp":"2026-02-10T17:50:46.089Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","oldString":"  onCopyUrls,\n  onDelete,","newString":"  onCopyUrls,\n  onExport,\n  onDelete,","originalFile":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onExport: (format: \"csv\" | \"json\") => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}\n","structuredPatch":[{"oldStart":39,"oldLines":6,"newStart":39,"newLines":7,"lines":["   onSelectAll,","   onMove,","   onCopyUrls,","+  onExport,","   onDelete,","   onClose,","   hasUsername,"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0c08ab55-6a81-4d41-8ee1-6ed0ed806086"}
{"parentUuid":"e5e9b25a-c6cd-4ff2-9f8c-c913f10162d5","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_0193icakncV9UQC183iZEw14","toolUseID":"toolu_0193icakncV9UQC183iZEw14","timestamp":"2026-02-10T17:50:46.091Z","uuid":"bd46674f-0a84-4544-85f1-854e2826caf6"}
{"parentUuid":"b7422d2b-e53a-4e7c-a447-4d9fe8031eb4","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PXq2m5vdNeHtHkRsh5MNVo","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx has been updated successfully."}]},"uuid":"7877be48-66de-4cd4-9ec3-7394dd6c1193","timestamp":"2026-02-10T17:50:46.135Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","oldString":"      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"","newString":"      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50 motion-reduce:transition-none motion-reduce:animate-none\"","originalFile":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onExport: (format: \"csv\" | \"json\") => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onExport,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}\n","structuredPatch":[{"oldStart":52,"oldLines":7,"newStart":52,"newLines":7,"lines":["       animate={{ y: 0, opacity: 1 }}","       exit={{ y: 100, opacity: 0 }}","       transition={{ duration: 0.2, ease: \"easeOut\" }}","-      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50\"","+      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50 motion-reduce:transition-none motion-reduce:animate-none\"","     >","       <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">","         <Button"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b7422d2b-e53a-4e7c-a447-4d9fe8031eb4"}
{"parentUuid":"7877be48-66de-4cd4-9ec3-7394dd6c1193","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01PXq2m5vdNeHtHkRsh5MNVo","toolUseID":"toolu_01PXq2m5vdNeHtHkRsh5MNVo","timestamp":"2026-02-10T17:50:46.136Z","uuid":"5043591d-5498-4e81-afc2-bf166732871a"}
{"parentUuid":"a5685285-6b67-4f2a-aac0-763329550b9e","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KtmrBtQFcW5Dcot2gzLUjd","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx has been updated successfully."}]},"uuid":"f4272ff6-308c-48a7-ac5b-f3010cafdb97","timestamp":"2026-02-10T17:50:46.178Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/multi-select-toolbar.tsx","oldString":"          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (","newString":"          Copy URLs\n        </Button>\n        <DropdownMenu>\n          <DropdownMenuTrigger\n            render={\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n              />\n            }\n          >\n            <IconFileExport className=\"h-4 w-4\" />\n            Export\n          </DropdownMenuTrigger>\n          <DropdownMenuContent align=\"center\" className=\"w-40\">\n            <DropdownMenuItem onClick={() => onExport(\"csv\")} className=\"whitespace-nowrap\">\n              <IconFileTypeCsv className=\"h-4 w-4\" />\n              Export as CSV\n            </DropdownMenuItem>\n            <DropdownMenuItem onClick={() => onExport(\"json\")} className=\"whitespace-nowrap\">\n              <IconJson className=\"h-4 w-4\" />\n              Export as JSON\n            </DropdownMenuItem>\n          </DropdownMenuContent>\n        </DropdownMenu>\n        {hasUsername && onMakePublic && (","originalFile":"\"use client\";\n\nimport { motion } from \"motion/react\";\nimport { Button } from \"@/components/ui/button\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@/components/ui/dropdown-menu\";\nimport {\n  IconListCheck,\n  IconX,\n  IconDragDrop,\n  IconCopyCheckFilled,\n  IconTrash,\n  IconFileExport,\n  IconFileTypeCsv,\n  IconJson,\n  IconWorld,\n  IconWorldOff,\n} from \"@tabler/icons-react\";\n\ninterface MultiSelectToolbarProps {\n  selectedCount: number;\n  onSelectAll: () => void;\n  onMove: () => void;\n  onCopyUrls: () => void;\n  onExport: (format: \"csv\" | \"json\") => void;\n  onDelete: () => void;\n  onClose: () => void;\n  hasUsername?: boolean;\n  onMakePublic?: () => void;\n  onMakePrivate?: () => void;\n}\n\nexport function MultiSelectToolbar({\n  selectedCount,\n  onSelectAll,\n  onMove,\n  onCopyUrls,\n  onExport,\n  onDelete,\n  onClose,\n  hasUsername,\n  onMakePublic,\n  onMakePrivate,\n}: MultiSelectToolbarProps) {\n  return (\n    <motion.div\n      initial={{ y: 100, opacity: 0 }}\n      animate={{ y: 0, opacity: 1 }}\n      exit={{ y: 100, opacity: 0 }}\n      transition={{ duration: 0.2, ease: \"easeOut\" }}\n      className=\"fixed bottom-8 left-1/2 -translate-x-1/2 z-50 motion-reduce:transition-none motion-reduce:animate-none\"\n    >\n      <div className=\"flex items-center rounded-lg bg-popover text-popover-foreground p-1 shadow-md ring-1 ring-foreground/10\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onSelectAll}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconListCheck className=\"h-4 w-4\" />\n          Select All\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5 -my-1\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMove}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconDragDrop className=\"h-4 w-4\" />\n          Move\n        </Button>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onCopyUrls}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n        >\n          <IconCopyCheckFilled className=\"h-4 w-4\" />\n          Copy URLs\n        </Button>\n        {hasUsername && onMakePublic && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePublic}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorld className=\"h-4 w-4\" />\n            Public\n          </Button>\n        )}\n        {hasUsername && onMakePrivate && (\n          <Button\n            variant=\"ghost\"\n            size=\"sm\"\n            onClick={onMakePrivate}\n            className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"\n          >\n            <IconWorldOff className=\"h-4 w-4\" />\n            Private\n          </Button>\n        )}\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onDelete}\n          className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] text-destructive hover:bg-destructive/10 hover:text-destructive\"\n        >\n          <IconTrash className=\"h-4 w-4\" />\n          Delete\n        </Button>\n        <div className=\"h-4 w-px bg-border mx-0.5\" />\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onClose}\n          className=\"rounded-md p-1 h-auto hover:bg-accent hover:text-accent-foreground\"\n          aria-label=\"Close multi-select toolbar\"\n        >\n          <IconX className=\"h-4 w-4\" />\n        </Button>\n      </div>\n    </motion.div>\n  );\n}\n","structuredPatch":[{"oldStart":83,"oldLines":6,"newStart":83,"newLines":30,"lines":["           <IconCopyCheckFilled className=\"h-4 w-4\" />","           Copy URLs","         </Button>","+        <DropdownMenu>","+          <DropdownMenuTrigger","+            render={","+              <Button","+                variant=\"ghost\"","+                size=\"sm\"","+                className=\"gap-1.5 rounded-md px-1.5 py-1 h-auto text-[13px] hover:bg-accent hover:text-accent-foreground\"","+              />","+            }","+          >","+            <IconFileExport className=\"h-4 w-4\" />","+            Export","+          </DropdownMenuTrigger>","+          <DropdownMenuContent align=\"center\" className=\"w-40\">","+            <DropdownMenuItem onClick={() => onExport(\"csv\")} className=\"whitespace-nowrap\">","+              <IconFileTypeCsv className=\"h-4 w-4\" />","+              Export as CSV","+            </DropdownMenuItem>","+            <DropdownMenuItem onClick={() => onExport(\"json\")} className=\"whitespace-nowrap\">","+              <IconJson className=\"h-4 w-4\" />","+              Export as JSON","+            </DropdownMenuItem>","+          </DropdownMenuContent>","+        </DropdownMenu>","         {hasUsername && onMakePublic && (","           <Button","             variant=\"ghost\""]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a5685285-6b67-4f2a-aac0-763329550b9e"}
{"parentUuid":"f4272ff6-308c-48a7-ac5b-f3010cafdb97","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01KtmrBtQFcW5Dcot2gzLUjd","toolUseID":"toolu_01KtmrBtQFcW5Dcot2gzLUjd","timestamp":"2026-02-10T17:50:46.178Z","uuid":"6aa453bb-7d86-452f-aa38-be3bccc35054"}
{"parentUuid":"6aa453bb-7d86-452f-aa38-be3bccc35054","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01HeDwrTZ6rQdauAZmm4J2oj","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me read the settings-dialog to find where to add the export button and the prop:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2243,"cache_read_input_tokens":122230,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2243},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp4hRytAJwniEkX1jBd","type":"assistant","uuid":"d045af81-99b0-4d22-935a-c8d919e01740","timestamp":"2026-02-10T17:50:50.745Z"}
{"parentUuid":"d045af81-99b0-4d22-935a-c8d919e01740","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01HeDwrTZ6rQdauAZmm4J2oj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TkSAaz4fFN2JgDyX8bprPs","name":"Read","input":{"file_path":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","offset":50,"limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2243,"cache_read_input_tokens":122230,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":2243},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp4hRytAJwniEkX1jBd","type":"assistant","uuid":"9e700cfa-1334-4a40-98b5-1c6044eb683d","timestamp":"2026-02-10T17:50:51.475Z"}
{"parentUuid":"9e700cfa-1334-4a40-98b5-1c6044eb683d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TkSAaz4fFN2JgDyX8bprPs","type":"tool_result","content":"    50→\n    51→const MAX_AVATAR_FILE_SIZE_BYTES = 2 * 1024 * 1024;\n    52→\n    53→interface SettingsDialogProps {\n    54→  open: boolean;\n    55→  onOpenChange: (open: boolean) => void;\n    56→  user: {\n    57→    name: string;\n    58→    email: string;\n    59→    image: string | null;\n    60→  };\n    61→  profile?: ProfileData;\n    62→}\n    63→\n    64→export function SettingsDialog({\n    65→  open,\n    66→  onOpenChange,\n    67→  user,\n    68→  profile,\n    69→}: SettingsDialogProps) {\n    70→  const router = useRouter();\n    71→  const [name, setName] = useState(user.name);\n    72→  const [avatarUrl, setAvatarUrl] = useState<string | null>(user.image);\n    73→  const [isSaving, setIsSaving] = useState(false);\n    74→  const [isUploading, setIsUploading] = useState(false);\n    75→  const fileInputRef = useRef<HTMLInputElement>(null);\n    76→  const initial = name.trim().charAt(0).toUpperCase() || \"?\";\n    77→\n    78→  useEffect(() => {\n    79→    if (!open) return;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3d1688c8-c24d-4bce-9959-bf838f07bcbf","timestamp":"2026-02-10T17:50:51.562Z","toolUseResult":{"type":"text","file":{"filePath":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","content":"\nconst MAX_AVATAR_FILE_SIZE_BYTES = 2 * 1024 * 1024;\n\ninterface SettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  user: {\n    name: string;\n    email: string;\n    image: string | null;\n  };\n  profile?: ProfileData;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n}: SettingsDialogProps) {\n  const router = useRouter();\n  const [name, setName] = useState(user.name);\n  const [avatarUrl, setAvatarUrl] = useState<string | null>(user.image);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const initial = name.trim().charAt(0).toUpperCase() || \"?\";\n\n  useEffect(() => {\n    if (!open) return;","numLines":30,"startLine":50,"totalLines":630}},"sourceToolAssistantUUID":"9e700cfa-1334-4a40-98b5-1c6044eb683d"}
{"parentUuid":"3d1688c8-c24d-4bce-9959-bf838f07bcbf","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01TkSAaz4fFN2JgDyX8bprPs","toolUseID":"toolu_01TkSAaz4fFN2JgDyX8bprPs","timestamp":"2026-02-10T17:50:51.563Z","uuid":"79e13e56-ca7a-4cc0-89f4-2b8955153ebf"}
{"parentUuid":"79e13e56-ca7a-4cc0-89f4-2b8955153ebf","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_017mSTegeUz6vor8HSydJ8r8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017LC43LAybV4QSk9NqLy5Kt","name":"Grep","input":{"pattern":"Chrome Extension","path":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","output_mode":"content","-n":true,"-A":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":606,"cache_read_input_tokens":124473,"output_tokens":142,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":606,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXzp57JRhfNLbGHhCadDf","type":"assistant","uuid":"4c2bae08-e19a-4e2f-ab32-3bf6a0ab6744","timestamp":"2026-02-10T17:50:56.473Z"}
{"parentUuid":"4c2bae08-e19a-4e2f-ab32-3bf6a0ab6744","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017LC43LAybV4QSk9NqLy5Kt","type":"tool_result","content":"246:                <FieldLabel>Chrome Extension</FieldLabel>\n247-                <a\n248-                  href=\"/chrome\"\n249-                  target=\"_blank\"\n250-                  rel=\"noopener noreferrer\"\n251-                  className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n252-                >\n253-                  <ChromeIcon />\n254:                  <span>Get the Chrome Extension</span>\n255-                </a>\n256-              </Field>\n257-              <DialogFooter>\n258-                <DialogClose render={<Button variant=\"ghost\" />}>\n259-                  Cancel\n260-                </DialogClose>\n261-                <Button\n262-                  type=\"submit\"\n263-                  disabled={isSaving || isUploading || !name.trim()}\n264-                >"}]},"uuid":"94ffdb96-8c16-4820-b354-b072cfb6a224","timestamp":"2026-02-10T17:50:57.181Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"246:                <FieldLabel>Chrome Extension</FieldLabel>\n247-                <a\n248-                  href=\"/chrome\"\n249-                  target=\"_blank\"\n250-                  rel=\"noopener noreferrer\"\n251-                  className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n252-                >\n253-                  <ChromeIcon />\n254:                  <span>Get the Chrome Extension</span>\n255-                </a>\n256-              </Field>\n257-              <DialogFooter>\n258-                <DialogClose render={<Button variant=\"ghost\" />}>\n259-                  Cancel\n260-                </DialogClose>\n261-                <Button\n262-                  type=\"submit\"\n263-                  disabled={isSaving || isUploading || !name.trim()}\n264-                >","numLines":19},"sourceToolAssistantUUID":"4c2bae08-e19a-4e2f-ab32-3bf6a0ab6744"}
{"parentUuid":"94ffdb96-8c16-4820-b354-b072cfb6a224","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_017LC43LAybV4QSk9NqLy5Kt","toolUseID":"toolu_017LC43LAybV4QSk9NqLy5Kt","timestamp":"2026-02-10T17:50:57.182Z","uuid":"82dc43cd-855c-483c-b6c3-04d2fc53ef68"}
{"parentUuid":"82dc43cd-855c-483c-b6c3-04d2fc53ef68","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01J5UFdmMoqGRhszRe98BJy1","type":"message","role":"assistant","content":[{"type":"text","text":"Now I can add the export prop and the Data field:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":397,"cache_read_input_tokens":125079,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":397},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp5WUTGeAoE5iDXDW5c","type":"assistant","uuid":"63cad8c7-9e9b-496c-a7d4-bcdbaec54aca","timestamp":"2026-02-10T17:51:00.711Z"}
{"parentUuid":"63cad8c7-9e9b-496c-a7d4-bcdbaec54aca","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01J5UFdmMoqGRhszRe98BJy1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017vwSdGdAN7SQpVt7yEHyUq","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","old_string":"  profile?: ProfileData;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n}: SettingsDialogProps) {","new_string":"  profile?: ProfileData;\n  onExport?: () => void;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n  onExport,\n}: SettingsDialogProps) {"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":397,"cache_read_input_tokens":125079,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":397},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp5WUTGeAoE5iDXDW5c","type":"assistant","uuid":"43e731cb-2f6b-4f35-9595-ff729a0dffc1","timestamp":"2026-02-10T17:51:02.351Z"}
{"parentUuid":"43e731cb-2f6b-4f35-9595-ff729a0dffc1","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01J5UFdmMoqGRhszRe98BJy1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MFEj94CdD5PeNoiotvbUx9","name":"Edit","input":{"replace_all":false,"file_path":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","old_string":"              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >","new_string":"              </Field>\n              {onExport && (\n                <Field>\n                  <FieldLabel>Data</FieldLabel>\n                  <Button\n                    type=\"button\"\n                    variant=\"outline\"\n                    onClick={onExport}\n                    className=\"w-fit\"\n                  >\n                    Export\n                  </Button>\n                </Field>\n              )}\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":397,"cache_read_input_tokens":125079,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":397},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp5WUTGeAoE5iDXDW5c","type":"assistant","uuid":"af566616-0be7-42d0-b65d-ce5f05f30163","timestamp":"2026-02-10T17:51:05.167Z"}
{"type":"file-history-snapshot","messageId":"43e731cb-2f6b-4f35-9595-ff729a0dffc1","snapshot":{"messageId":"06123b67-0019-4aec-aa67-ba0dfdf62319","trackedFileBackups":{"components/dashboard-content.tsx":{"backupFileName":"d30ebca3ed1ec74d@v1","version":1,"backupTime":"2026-02-10T17:49:53.671Z"},"components/header.tsx":{"backupFileName":"1d89d7abd201ae59@v1","version":1,"backupTime":"2026-02-10T17:50:45.999Z"},"components/multi-select-toolbar.tsx":{"backupFileName":"03c604d0979a135a@v1","version":1,"backupTime":"2026-02-10T17:50:46.028Z"},"components/settings-dialog.tsx":{"backupFileName":"02830e3ee14d001e@v1","version":1,"backupTime":"2026-02-10T17:51:05.203Z"}},"timestamp":"2026-02-10T17:48:34.297Z"},"isSnapshotUpdate":true}
{"parentUuid":"43e731cb-2f6b-4f35-9595-ff729a0dffc1","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017vwSdGdAN7SQpVt7yEHyUq","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/settings-dialog.tsx has been updated successfully."}]},"uuid":"66bac79d-c88a-42ce-9fe7-2d87c6e67828","timestamp":"2026-02-10T17:51:05.204Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","oldString":"  profile?: ProfileData;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n}: SettingsDialogProps) {","newString":"  profile?: ProfileData;\n  onExport?: () => void;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n  onExport,\n}: SettingsDialogProps) {","originalFile":"\"use client\";\n\nimport {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  type ChangeEvent,\n} from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { authClient } from \"@/lib/auth-client\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { Avatar, AvatarImage, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n  IconCheck,\n  IconX,\n  IconLoader2,\n  IconCopy,\n  IconExternalLink,\n} from \"@tabler/icons-react\";\nimport { ImagePlusIcon } from \"lucide-react\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { usernameSchema, updateProfileSchema } from \"@/lib/schema\";\n\nconst ACCEPTED_AVATAR_TYPES = new Set([\n  \"image/png\",\n  \"image/jpeg\",\n  \"image/webp\",\n  \"image/gif\",\n]);\n\nconst MAX_AVATAR_FILE_SIZE_BYTES = 2 * 1024 * 1024;\n\ninterface SettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  user: {\n    name: string;\n    email: string;\n    image: string | null;\n  };\n  profile?: ProfileData;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n}: SettingsDialogProps) {\n  const router = useRouter();\n  const [name, setName] = useState(user.name);\n  const [avatarUrl, setAvatarUrl] = useState<string | null>(user.image);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const initial = name.trim().charAt(0).toUpperCase() || \"?\";\n\n  useEffect(() => {\n    if (!open) return;\n    setName(user.name);\n    setAvatarUrl(user.image);\n  }, [open, user.name, user.image]);\n\n  const handleAvatarUpload = async (file: File) => {\n    if (!ACCEPTED_AVATAR_TYPES.has(file.type)) {\n      toast.error(\"Only PNG, JPEG, WebP, and GIF files are supported\");\n      return;\n    }\n\n    if (file.size > MAX_AVATAR_FILE_SIZE_BYTES) {\n      toast.error(\"Avatar must be 2MB or smaller\");\n      return;\n    }\n\n    setIsUploading(true);\n    try {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n\n      const response = await fetch(\"/api/avatar\", {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) throw await responseError(response, \"Failed to upload avatar\");\n\n      const data = (await response.json()) as { url?: string };\n      if (!data.url) throw new Error(\"Invalid upload response\");\n\n      setAvatarUrl(data.url);\n      toast.success(\"Avatar updated\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to upload avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleAvatarChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    await handleAvatarUpload(file);\n    event.target.value = \"\";\n  };\n\n  const handleAvatarRemove = async () => {\n    setIsUploading(true);\n    try {\n      const response = await fetch(\"/api/avatar\", { method: \"DELETE\" });\n\n      if (!response.ok) throw await responseError(response, \"Failed to remove avatar\");\n\n      setAvatarUrl(null);\n      toast.success(\"Avatar removed\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to remove avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleSaveName = async () => {\n    if (name.trim() === user.name) {\n      onOpenChange(false);\n      return;\n    }\n\n    setIsSaving(true);\n    const { error } = await authClient.updateUser({ name: name.trim() });\n    setIsSaving(false);\n\n    if (error) {\n      toast.error(\"Failed to update name\");\n      return;\n    }\n\n    toast.success(\"Name updated\");\n    onOpenChange(false);\n    router.refresh();\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md\" showCloseButton={false}>\n        <DialogHeader>\n          <DialogTitle>Settings</DialogTitle>\n          <DialogDescription>Manage your account settings.</DialogDescription>\n        </DialogHeader>\n        <Tabs defaultValue=\"general\">\n          <TabsList>\n            <TabsTrigger value=\"general\">General</TabsTrigger>\n            <TabsTrigger value=\"profile\">Public Profile</TabsTrigger>\n          </TabsList>\n          <TabsContent value=\"general\">\n            <Form\n              className=\"space-y-4 pt-2\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleSaveName();\n              }}\n            >\n              <Field>\n                <FieldLabel>Profile Picture</FieldLabel>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"group relative\">\n                    <Avatar\n                      size=\"lg\"\n                      className=\"overflow-hidden *:data-[slot=avatar-image]:transition-[filter] *:data-[slot=avatar-fallback]:transition-[filter] sm:group-hover:*:data-[slot=avatar-image]:blur-sm sm:group-hover:*:data-[slot=avatar-fallback]:blur-sm\"\n                    >\n                      <AvatarImage\n                        src={avatarUrl ?? undefined}\n                        alt={name || user.name}\n                      />\n                      <AvatarFallback>{initial}</AvatarFallback>\n                    </Avatar>\n                    <button\n                      type=\"button\"\n                      disabled={isUploading}\n                      className=\"absolute inset-0 flex items-center justify-center rounded-full bg-black/45 hover:bg-black/55 text-white opacity-100 transition-opacity sm:opacity-0 sm:group-hover:opacity-100 disabled:opacity-100 cursor-pointer outline-none\"\n                      onClick={\n                        avatarUrl\n                          ? handleAvatarRemove\n                          : () => fileInputRef.current?.click()\n                      }\n                    >\n                      <AvatarOverlayIcon\n                        isUploading={isUploading}\n                        hasAvatar={!!avatarUrl}\n                      />\n                    </button>\n                  </div>\n                  <p className=\"text-xs text-muted-foreground\">\n                    Upload a photo\n                  </p>\n                  <input\n                    ref={fileInputRef}\n                    type=\"file\"\n                    className=\"hidden\"\n                    accept=\"image/png,image/jpeg,image/webp,image/gif\"\n                    onChange={handleAvatarChange}\n                  />\n                </div>\n              </Field>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  value={name}\n                  onChange={(e) => setName(e.target.value)}\n                  placeholder=\"duncan\"\n                  type=\"text\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Email</FieldLabel>\n                <Input\n                  value={user.email}\n                  disabled\n                  type=\"email\"\n                  className=\"text-muted-foreground\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Chrome Extension</FieldLabel>\n                <a\n                  href=\"/chrome\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n                >\n                  <ChromeIcon />\n                  <span>Get the Chrome Extension</span>\n                </a>\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >\n                  {isSaving ? \"Saving...\" : \"Save\"}\n                </Button>\n              </DialogFooter>\n            </Form>\n          </TabsContent>\n          <TabsContent value=\"profile\">\n            {profile && <ProfileTab profile={profile} onOpenChange={onOpenChange} />}\n          </TabsContent>\n        </Tabs>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\ninterface ProfileTabProps {\n  profile: ProfileData;\n  onOpenChange: (open: boolean) => void;\n}\n\nfunction ProfileTab({ profile, onOpenChange }: ProfileTabProps) {\n  const router = useRouter();\n\n  const [username, setUsername] = useState(profile.username ?? \"\");\n  const [bio, setBio] = useState(profile.bio ?? \"\");\n  const [github, setGithub] = useState(profile.github ?? \"\");\n  const [twitter, setTwitter] = useState(profile.twitter ?? \"\");\n  const [website, setWebsite] = useState(\n    profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\",\n  );\n  const [isProfilePublic, setIsProfilePublic] = useState(\n    profile.isProfilePublic,\n  );\n  const [dirtyFields, setDirtyFields] = useState<Set<string>>(new Set());\n  const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({});\n\n  const markDirty = (field: string) => {\n    setDirtyFields((prev) => new Set(prev).add(field));\n    setFieldErrors((prev) => {\n      const next = { ...prev };\n      delete next[field];\n      return next;\n    });\n  };\n\n  const debouncedUsername = useDebounce(username, 400);\n  const usernameParseResult = usernameSchema.safeParse(debouncedUsername);\n  const isUsernameValid =\n    debouncedUsername.length > 0 && usernameParseResult.success;\n\n  const availabilityQuery = useQuery({\n    ...orpc.profile.checkUsername.queryOptions({\n      input: { username: debouncedUsername },\n    }),\n    enabled: isUsernameValid,\n    staleTime: 10_000,\n  });\n\n  const usernameStatus = getStatus(\n    username,\n    debouncedUsername,\n    usernameParseResult,\n    availabilityQuery,\n  );\n\n  const updateMutation = useMutation({\n    mutationFn: (data: Parameters<typeof client.profile.update>[0]) =>\n      client.profile.update(data),\n    onSuccess: () => {\n      toast.success(\"Profile updated\");\n      onOpenChange(false);\n      router.refresh();\n    },\n    onError: (err) => {\n      toast.error(err.message || \"Failed to update profile\");\n    },\n  });\n\n  const handleSubmit = () => {\n    if (username && usernameStatus !== \"available\") return;\n\n    const originalWebsite = profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\";\n    const hasChanges =\n      username !== (profile.username ?? \"\") ||\n      bio !== (profile.bio ?? \"\") ||\n      github !== (profile.github ?? \"\") ||\n      twitter !== (profile.twitter ?? \"\") ||\n      website !== originalWebsite ||\n      isProfilePublic !== profile.isProfilePublic;\n\n    if (!hasChanges) {\n      onOpenChange(false);\n      return;\n    }\n\n    const payload = {\n      username: username || null,\n      bio: bio || null,\n      github: github || null,\n      twitter: twitter || null,\n      website: website || null,\n      isProfilePublic,\n    };\n\n    const result = updateProfileSchema.safeParse(payload);\n\n    if (!result.success) {\n      const errors: Record<string, string> = {};\n      for (const issue of result.error.issues) {\n        const field = issue.path[0]?.toString();\n        if (field && !errors[field]) {\n          errors[field] = issue.message;\n        }\n      }\n      setFieldErrors(errors);\n      return;\n    }\n\n    setFieldErrors({});\n    updateMutation.mutate(result.data);\n  };\n\n  const handleCopyLink = useCallback(() => {\n    if (username) {\n      navigator.clipboard.writeText(`${window.location.origin}/u/${username}`);\n      toast.success(\"Link copied\");\n    }\n  }, [username]);\n\n  return (\n    <Form\n      className=\"space-y-4 pt-2\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        handleSubmit();\n      }}\n    >\n      <Field>\n        <div className=\"flex items-center justify-between\">\n          <FieldLabel>Public Profile</FieldLabel>\n          <Switch\n            checked={isProfilePublic}\n            onCheckedChange={setIsProfilePublic}\n            size=\"sm\"\n          />\n        </div>\n      </Field>\n      <Field>\n        <FieldLabel>Username</FieldLabel>\n        <div className=\"relative\">\n          <Input\n            value={username}\n            onChange={(e) => {\n              markDirty(\"username\");\n              const newValue = e.target.value\n                .toLowerCase()\n                .replace(/[^a-z0-9-]/g, \"\");\n              if (newValue && !username && !isProfilePublic) {\n                setIsProfilePublic(true);\n              }\n              setUsername(newValue);\n            }}\n            placeholder=\"duncan\"\n            type=\"text\"\n            className=\"pr-8\"\n          />\n          <div className=\"absolute right-2 top-1/2 -translate-y-1/2\">\n            <UsernameStatusIcon status={usernameStatus} />\n          </div>\n        </div>\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"invalid\" && (\n            <p className=\"text-xs text-destructive mt-1\">\n              {usernameParseResult.error?.issues[0]?.message}\n            </p>\n          )}\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"taken\" && (\n            <p className=\"text-xs text-destructive mt-1\">Username is taken</p>\n          )}\n      </Field>\n      <Field>\n        <FieldLabel>Bio</FieldLabel>\n        <Textarea\n          value={bio}\n          onChange={(e) => {\n            markDirty(\"bio\");\n            setBio(e.target.value);\n          }}\n          placeholder=\"Building cool things on the web\"\n          rows={2}\n          maxLength={160}\n          className=\"resize-none\"\n        />\n        {fieldErrors.bio && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.bio}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>GitHub</FieldLabel>\n        <Input\n          value={github}\n          onChange={(e) => {\n            markDirty(\"github\");\n            setGithub(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.github && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.github}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>X (Twitter)</FieldLabel>\n        <Input\n          value={twitter}\n          onChange={(e) => {\n            markDirty(\"twitter\");\n            setTwitter(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.twitter && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.twitter}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>Website</FieldLabel>\n        <div className=\"flex\">\n          <span className=\"inline-flex items-center rounded-l-md border border-r-0 border-input bg-muted px-2 text-sm text-muted-foreground\">\n            https://\n          </span>\n          <Input\n            value={website}\n            onChange={(e) => {\n              markDirty(\"website\");\n              setWebsite(e.target.value.replace(/^https?:\\/\\//, \"\"));\n            }}\n            placeholder=\"ephraimduncan.com\"\n            type=\"text\"\n            className=\"rounded-l-none px-2\"\n          />\n        </div>\n        {fieldErrors.website && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.website}</p>\n        )}\n      </Field>\n      {username && usernameStatus === \"available\" && (\n        <div className=\"flex items-center gap-2\">\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={handleCopyLink}\n          >\n            <IconCopy className=\"h-3.5 w-3.5\" />\n            Copy Profile Link\n          </Button>\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={() => window.open(`/u/${username}`, \"_blank\")}\n          >\n            <IconExternalLink className=\"h-3.5 w-3.5\" />\n            Preview Profile\n          </Button>\n        </div>\n      )}\n      <DialogFooter>\n        <DialogClose render={<Button variant=\"ghost\" />}>Cancel</DialogClose>\n        <Button\n          type=\"submit\"\n          disabled={\n            updateMutation.isPending ||\n            (!!username && usernameStatus !== \"available\")\n          }\n        >\n          {updateMutation.isPending ? \"Saving...\" : \"Save\"}\n        </Button>\n      </DialogFooter>\n    </Form>\n  );\n}\n\nasync function responseError(\n  response: Response,\n  fallback: string,\n): Promise<Error> {\n  const data = (await response.json().catch(() => null)) as {\n    message?: string;\n  } | null;\n  return new Error(data?.message ?? fallback);\n}\n\nfunction AvatarOverlayIcon({\n  isUploading,\n  hasAvatar,\n}: {\n  isUploading: boolean;\n  hasAvatar: boolean;\n}) {\n  if (isUploading) return <IconLoader2 className=\"size-4 animate-spin\" />;\n  if (hasAvatar) return <IconX className=\"size-4\" />;\n  return <ImagePlusIcon className=\"size-4\" />;\n}\n\ntype UsernameStatus = \"idle\" | \"checking\" | \"available\" | \"taken\" | \"invalid\";\n\nfunction getStatus(\n  username: string,\n  debouncedUsername: string,\n  parseResult: ReturnType<typeof usernameSchema.safeParse>,\n  availabilityQuery: { isPending: boolean; data?: unknown },\n): UsernameStatus {\n  if (!username) return \"idle\";\n  if (!parseResult.success) return \"invalid\";\n  if (username !== debouncedUsername) return \"checking\";\n  if (availabilityQuery.isPending) return \"checking\";\n  const data = availabilityQuery.data as { available?: boolean } | undefined;\n  if (data?.available) return \"available\";\n  return \"taken\";\n}\n\nfunction UsernameStatusIcon({ status }: { status: UsernameStatus }) {\n  switch (status) {\n    case \"checking\":\n      return (\n        <IconLoader2 className=\"h-4 w-4 animate-spin text-muted-foreground\" />\n      );\n    case \"available\":\n      return <IconCheck className=\"h-4 w-4 text-green-600\" />;\n    case \"taken\":\n      return <IconX className=\"h-4 w-4 text-destructive\" />;\n    default:\n      return null;\n  }\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"20\"\n      height=\"20\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}\n","structuredPatch":[{"oldStart":59,"oldLines":6,"newStart":59,"newLines":7,"lines":["     image: string | null;","   };","   profile?: ProfileData;","+  onExport?: () => void;"," }"," "," export function SettingsDialog({"]},{"oldStart":66,"oldLines":6,"newStart":67,"newLines":7,"lines":["   onOpenChange,","   user,","   profile,","+  onExport,"," }: SettingsDialogProps) {","   const router = useRouter();","   const [name, setName] = useState(user.name);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"43e731cb-2f6b-4f35-9595-ff729a0dffc1"}
{"parentUuid":"66bac79d-c88a-42ce-9fe7-2d87c6e67828","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_017vwSdGdAN7SQpVt7yEHyUq","toolUseID":"toolu_017vwSdGdAN7SQpVt7yEHyUq","timestamp":"2026-02-10T17:51:05.205Z","uuid":"d98836b4-279c-4df2-b977-22eaec114874"}
{"parentUuid":"af566616-0be7-42d0-b65d-ce5f05f30163","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MFEj94CdD5PeNoiotvbUx9","type":"tool_result","content":"The file /Users/duncan/dev/bmrks/components/settings-dialog.tsx has been updated successfully."}]},"uuid":"8a33cc75-dfa9-493e-b582-17d0e1718c88","timestamp":"2026-02-10T17:51:05.230Z","toolUseResult":{"filePath":"/Users/duncan/dev/bmrks/components/settings-dialog.tsx","oldString":"              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >","newString":"              </Field>\n              {onExport && (\n                <Field>\n                  <FieldLabel>Data</FieldLabel>\n                  <Button\n                    type=\"button\"\n                    variant=\"outline\"\n                    onClick={onExport}\n                    className=\"w-fit\"\n                  >\n                    Export\n                  </Button>\n                </Field>\n              )}\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >","originalFile":"\"use client\";\n\nimport {\n  useState,\n  useCallback,\n  useRef,\n  useEffect,\n  type ChangeEvent,\n} from \"react\";\nimport { useRouter } from \"next/navigation\";\nimport { toast } from \"sonner\";\nimport { useQuery, useMutation } from \"@tanstack/react-query\";\nimport { authClient } from \"@/lib/auth-client\";\nimport { client, orpc } from \"@/lib/orpc\";\nimport type { ProfileData } from \"@/components/dashboard-content\";\nimport {\n  Dialog,\n  DialogClose,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from \"@/components/ui/dialog\";\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Textarea } from \"@/components/ui/textarea\";\nimport { Form } from \"@/components/ui/form\";\nimport { Field, FieldLabel } from \"@/components/ui/field\";\nimport { Avatar, AvatarImage, AvatarFallback } from \"@/components/ui/avatar\";\nimport { Switch } from \"@/components/ui/switch\";\nimport {\n  IconCheck,\n  IconX,\n  IconLoader2,\n  IconCopy,\n  IconExternalLink,\n} from \"@tabler/icons-react\";\nimport { ImagePlusIcon } from \"lucide-react\";\nimport { useDebounce } from \"@/hooks/use-debounce\";\nimport { usernameSchema, updateProfileSchema } from \"@/lib/schema\";\n\nconst ACCEPTED_AVATAR_TYPES = new Set([\n  \"image/png\",\n  \"image/jpeg\",\n  \"image/webp\",\n  \"image/gif\",\n]);\n\nconst MAX_AVATAR_FILE_SIZE_BYTES = 2 * 1024 * 1024;\n\ninterface SettingsDialogProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  user: {\n    name: string;\n    email: string;\n    image: string | null;\n  };\n  profile?: ProfileData;\n  onExport?: () => void;\n}\n\nexport function SettingsDialog({\n  open,\n  onOpenChange,\n  user,\n  profile,\n  onExport,\n}: SettingsDialogProps) {\n  const router = useRouter();\n  const [name, setName] = useState(user.name);\n  const [avatarUrl, setAvatarUrl] = useState<string | null>(user.image);\n  const [isSaving, setIsSaving] = useState(false);\n  const [isUploading, setIsUploading] = useState(false);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n  const initial = name.trim().charAt(0).toUpperCase() || \"?\";\n\n  useEffect(() => {\n    if (!open) return;\n    setName(user.name);\n    setAvatarUrl(user.image);\n  }, [open, user.name, user.image]);\n\n  const handleAvatarUpload = async (file: File) => {\n    if (!ACCEPTED_AVATAR_TYPES.has(file.type)) {\n      toast.error(\"Only PNG, JPEG, WebP, and GIF files are supported\");\n      return;\n    }\n\n    if (file.size > MAX_AVATAR_FILE_SIZE_BYTES) {\n      toast.error(\"Avatar must be 2MB or smaller\");\n      return;\n    }\n\n    setIsUploading(true);\n    try {\n      const formData = new FormData();\n      formData.append(\"file\", file);\n\n      const response = await fetch(\"/api/avatar\", {\n        method: \"POST\",\n        body: formData,\n      });\n\n      if (!response.ok) throw await responseError(response, \"Failed to upload avatar\");\n\n      const data = (await response.json()) as { url?: string };\n      if (!data.url) throw new Error(\"Invalid upload response\");\n\n      setAvatarUrl(data.url);\n      toast.success(\"Avatar updated\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to upload avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleAvatarChange = async (event: ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    await handleAvatarUpload(file);\n    event.target.value = \"\";\n  };\n\n  const handleAvatarRemove = async () => {\n    setIsUploading(true);\n    try {\n      const response = await fetch(\"/api/avatar\", { method: \"DELETE\" });\n\n      if (!response.ok) throw await responseError(response, \"Failed to remove avatar\");\n\n      setAvatarUrl(null);\n      toast.success(\"Avatar removed\");\n      router.refresh();\n    } catch (error) {\n      toast.error(error instanceof Error ? error.message : \"Failed to remove avatar\");\n    } finally {\n      setIsUploading(false);\n    }\n  };\n\n  const handleSaveName = async () => {\n    if (name.trim() === user.name) {\n      onOpenChange(false);\n      return;\n    }\n\n    setIsSaving(true);\n    const { error } = await authClient.updateUser({ name: name.trim() });\n    setIsSaving(false);\n\n    if (error) {\n      toast.error(\"Failed to update name\");\n      return;\n    }\n\n    toast.success(\"Name updated\");\n    onOpenChange(false);\n    router.refresh();\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"sm:max-w-md\" showCloseButton={false}>\n        <DialogHeader>\n          <DialogTitle>Settings</DialogTitle>\n          <DialogDescription>Manage your account settings.</DialogDescription>\n        </DialogHeader>\n        <Tabs defaultValue=\"general\">\n          <TabsList>\n            <TabsTrigger value=\"general\">General</TabsTrigger>\n            <TabsTrigger value=\"profile\">Public Profile</TabsTrigger>\n          </TabsList>\n          <TabsContent value=\"general\">\n            <Form\n              className=\"space-y-4 pt-2\"\n              onSubmit={(e) => {\n                e.preventDefault();\n                handleSaveName();\n              }}\n            >\n              <Field>\n                <FieldLabel>Profile Picture</FieldLabel>\n                <div className=\"flex items-center gap-3\">\n                  <div className=\"group relative\">\n                    <Avatar\n                      size=\"lg\"\n                      className=\"overflow-hidden *:data-[slot=avatar-image]:transition-[filter] *:data-[slot=avatar-fallback]:transition-[filter] sm:group-hover:*:data-[slot=avatar-image]:blur-sm sm:group-hover:*:data-[slot=avatar-fallback]:blur-sm\"\n                    >\n                      <AvatarImage\n                        src={avatarUrl ?? undefined}\n                        alt={name || user.name}\n                      />\n                      <AvatarFallback>{initial}</AvatarFallback>\n                    </Avatar>\n                    <button\n                      type=\"button\"\n                      disabled={isUploading}\n                      className=\"absolute inset-0 flex items-center justify-center rounded-full bg-black/45 hover:bg-black/55 text-white opacity-100 transition-opacity sm:opacity-0 sm:group-hover:opacity-100 disabled:opacity-100 cursor-pointer outline-none\"\n                      onClick={\n                        avatarUrl\n                          ? handleAvatarRemove\n                          : () => fileInputRef.current?.click()\n                      }\n                    >\n                      <AvatarOverlayIcon\n                        isUploading={isUploading}\n                        hasAvatar={!!avatarUrl}\n                      />\n                    </button>\n                  </div>\n                  <p className=\"text-xs text-muted-foreground\">\n                    Upload a photo\n                  </p>\n                  <input\n                    ref={fileInputRef}\n                    type=\"file\"\n                    className=\"hidden\"\n                    accept=\"image/png,image/jpeg,image/webp,image/gif\"\n                    onChange={handleAvatarChange}\n                  />\n                </div>\n              </Field>\n              <Field>\n                <FieldLabel>Name</FieldLabel>\n                <Input\n                  value={name}\n                  onChange={(e) => setName(e.target.value)}\n                  placeholder=\"duncan\"\n                  type=\"text\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Email</FieldLabel>\n                <Input\n                  value={user.email}\n                  disabled\n                  type=\"email\"\n                  className=\"text-muted-foreground\"\n                />\n              </Field>\n              <Field>\n                <FieldLabel>Chrome Extension</FieldLabel>\n                <a\n                  href=\"/chrome\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                  className=\"flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground transition-colors\"\n                >\n                  <ChromeIcon />\n                  <span>Get the Chrome Extension</span>\n                </a>\n              </Field>\n              <DialogFooter>\n                <DialogClose render={<Button variant=\"ghost\" />}>\n                  Cancel\n                </DialogClose>\n                <Button\n                  type=\"submit\"\n                  disabled={isSaving || isUploading || !name.trim()}\n                >\n                  {isSaving ? \"Saving...\" : \"Save\"}\n                </Button>\n              </DialogFooter>\n            </Form>\n          </TabsContent>\n          <TabsContent value=\"profile\">\n            {profile && <ProfileTab profile={profile} onOpenChange={onOpenChange} />}\n          </TabsContent>\n        </Tabs>\n      </DialogContent>\n    </Dialog>\n  );\n}\n\ninterface ProfileTabProps {\n  profile: ProfileData;\n  onOpenChange: (open: boolean) => void;\n}\n\nfunction ProfileTab({ profile, onOpenChange }: ProfileTabProps) {\n  const router = useRouter();\n\n  const [username, setUsername] = useState(profile.username ?? \"\");\n  const [bio, setBio] = useState(profile.bio ?? \"\");\n  const [github, setGithub] = useState(profile.github ?? \"\");\n  const [twitter, setTwitter] = useState(profile.twitter ?? \"\");\n  const [website, setWebsite] = useState(\n    profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\",\n  );\n  const [isProfilePublic, setIsProfilePublic] = useState(\n    profile.isProfilePublic,\n  );\n  const [dirtyFields, setDirtyFields] = useState<Set<string>>(new Set());\n  const [fieldErrors, setFieldErrors] = useState<Record<string, string>>({});\n\n  const markDirty = (field: string) => {\n    setDirtyFields((prev) => new Set(prev).add(field));\n    setFieldErrors((prev) => {\n      const next = { ...prev };\n      delete next[field];\n      return next;\n    });\n  };\n\n  const debouncedUsername = useDebounce(username, 400);\n  const usernameParseResult = usernameSchema.safeParse(debouncedUsername);\n  const isUsernameValid =\n    debouncedUsername.length > 0 && usernameParseResult.success;\n\n  const availabilityQuery = useQuery({\n    ...orpc.profile.checkUsername.queryOptions({\n      input: { username: debouncedUsername },\n    }),\n    enabled: isUsernameValid,\n    staleTime: 10_000,\n  });\n\n  const usernameStatus = getStatus(\n    username,\n    debouncedUsername,\n    usernameParseResult,\n    availabilityQuery,\n  );\n\n  const updateMutation = useMutation({\n    mutationFn: (data: Parameters<typeof client.profile.update>[0]) =>\n      client.profile.update(data),\n    onSuccess: () => {\n      toast.success(\"Profile updated\");\n      onOpenChange(false);\n      router.refresh();\n    },\n    onError: (err) => {\n      toast.error(err.message || \"Failed to update profile\");\n    },\n  });\n\n  const handleSubmit = () => {\n    if (username && usernameStatus !== \"available\") return;\n\n    const originalWebsite = profile.website?.replace(/^https?:\\/\\//, \"\") ?? \"\";\n    const hasChanges =\n      username !== (profile.username ?? \"\") ||\n      bio !== (profile.bio ?? \"\") ||\n      github !== (profile.github ?? \"\") ||\n      twitter !== (profile.twitter ?? \"\") ||\n      website !== originalWebsite ||\n      isProfilePublic !== profile.isProfilePublic;\n\n    if (!hasChanges) {\n      onOpenChange(false);\n      return;\n    }\n\n    const payload = {\n      username: username || null,\n      bio: bio || null,\n      github: github || null,\n      twitter: twitter || null,\n      website: website || null,\n      isProfilePublic,\n    };\n\n    const result = updateProfileSchema.safeParse(payload);\n\n    if (!result.success) {\n      const errors: Record<string, string> = {};\n      for (const issue of result.error.issues) {\n        const field = issue.path[0]?.toString();\n        if (field && !errors[field]) {\n          errors[field] = issue.message;\n        }\n      }\n      setFieldErrors(errors);\n      return;\n    }\n\n    setFieldErrors({});\n    updateMutation.mutate(result.data);\n  };\n\n  const handleCopyLink = useCallback(() => {\n    if (username) {\n      navigator.clipboard.writeText(`${window.location.origin}/u/${username}`);\n      toast.success(\"Link copied\");\n    }\n  }, [username]);\n\n  return (\n    <Form\n      className=\"space-y-4 pt-2\"\n      onSubmit={(e) => {\n        e.preventDefault();\n        handleSubmit();\n      }}\n    >\n      <Field>\n        <div className=\"flex items-center justify-between\">\n          <FieldLabel>Public Profile</FieldLabel>\n          <Switch\n            checked={isProfilePublic}\n            onCheckedChange={setIsProfilePublic}\n            size=\"sm\"\n          />\n        </div>\n      </Field>\n      <Field>\n        <FieldLabel>Username</FieldLabel>\n        <div className=\"relative\">\n          <Input\n            value={username}\n            onChange={(e) => {\n              markDirty(\"username\");\n              const newValue = e.target.value\n                .toLowerCase()\n                .replace(/[^a-z0-9-]/g, \"\");\n              if (newValue && !username && !isProfilePublic) {\n                setIsProfilePublic(true);\n              }\n              setUsername(newValue);\n            }}\n            placeholder=\"duncan\"\n            type=\"text\"\n            className=\"pr-8\"\n          />\n          <div className=\"absolute right-2 top-1/2 -translate-y-1/2\">\n            <UsernameStatusIcon status={usernameStatus} />\n          </div>\n        </div>\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"invalid\" && (\n            <p className=\"text-xs text-destructive mt-1\">\n              {usernameParseResult.error?.issues[0]?.message}\n            </p>\n          )}\n        {dirtyFields.has(\"username\") &&\n          username &&\n          usernameStatus === \"taken\" && (\n            <p className=\"text-xs text-destructive mt-1\">Username is taken</p>\n          )}\n      </Field>\n      <Field>\n        <FieldLabel>Bio</FieldLabel>\n        <Textarea\n          value={bio}\n          onChange={(e) => {\n            markDirty(\"bio\");\n            setBio(e.target.value);\n          }}\n          placeholder=\"Building cool things on the web\"\n          rows={2}\n          maxLength={160}\n          className=\"resize-none\"\n        />\n        {fieldErrors.bio && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.bio}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>GitHub</FieldLabel>\n        <Input\n          value={github}\n          onChange={(e) => {\n            markDirty(\"github\");\n            setGithub(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.github && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.github}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>X (Twitter)</FieldLabel>\n        <Input\n          value={twitter}\n          onChange={(e) => {\n            markDirty(\"twitter\");\n            setTwitter(e.target.value);\n          }}\n          placeholder=\"ephraimduncan\"\n          type=\"text\"\n        />\n        {fieldErrors.twitter && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.twitter}</p>\n        )}\n      </Field>\n      <Field>\n        <FieldLabel>Website</FieldLabel>\n        <div className=\"flex\">\n          <span className=\"inline-flex items-center rounded-l-md border border-r-0 border-input bg-muted px-2 text-sm text-muted-foreground\">\n            https://\n          </span>\n          <Input\n            value={website}\n            onChange={(e) => {\n              markDirty(\"website\");\n              setWebsite(e.target.value.replace(/^https?:\\/\\//, \"\"));\n            }}\n            placeholder=\"ephraimduncan.com\"\n            type=\"text\"\n            className=\"rounded-l-none px-2\"\n          />\n        </div>\n        {fieldErrors.website && (\n          <p className=\"text-xs text-destructive mt-1\">{fieldErrors.website}</p>\n        )}\n      </Field>\n      {username && usernameStatus === \"available\" && (\n        <div className=\"flex items-center gap-2\">\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={handleCopyLink}\n          >\n            <IconCopy className=\"h-3.5 w-3.5\" />\n            Copy Profile Link\n          </Button>\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"gap-1.5\"\n            onClick={() => window.open(`/u/${username}`, \"_blank\")}\n          >\n            <IconExternalLink className=\"h-3.5 w-3.5\" />\n            Preview Profile\n          </Button>\n        </div>\n      )}\n      <DialogFooter>\n        <DialogClose render={<Button variant=\"ghost\" />}>Cancel</DialogClose>\n        <Button\n          type=\"submit\"\n          disabled={\n            updateMutation.isPending ||\n            (!!username && usernameStatus !== \"available\")\n          }\n        >\n          {updateMutation.isPending ? \"Saving...\" : \"Save\"}\n        </Button>\n      </DialogFooter>\n    </Form>\n  );\n}\n\nasync function responseError(\n  response: Response,\n  fallback: string,\n): Promise<Error> {\n  const data = (await response.json().catch(() => null)) as {\n    message?: string;\n  } | null;\n  return new Error(data?.message ?? fallback);\n}\n\nfunction AvatarOverlayIcon({\n  isUploading,\n  hasAvatar,\n}: {\n  isUploading: boolean;\n  hasAvatar: boolean;\n}) {\n  if (isUploading) return <IconLoader2 className=\"size-4 animate-spin\" />;\n  if (hasAvatar) return <IconX className=\"size-4\" />;\n  return <ImagePlusIcon className=\"size-4\" />;\n}\n\ntype UsernameStatus = \"idle\" | \"checking\" | \"available\" | \"taken\" | \"invalid\";\n\nfunction getStatus(\n  username: string,\n  debouncedUsername: string,\n  parseResult: ReturnType<typeof usernameSchema.safeParse>,\n  availabilityQuery: { isPending: boolean; data?: unknown },\n): UsernameStatus {\n  if (!username) return \"idle\";\n  if (!parseResult.success) return \"invalid\";\n  if (username !== debouncedUsername) return \"checking\";\n  if (availabilityQuery.isPending) return \"checking\";\n  const data = availabilityQuery.data as { available?: boolean } | undefined;\n  if (data?.available) return \"available\";\n  return \"taken\";\n}\n\nfunction UsernameStatusIcon({ status }: { status: UsernameStatus }) {\n  switch (status) {\n    case \"checking\":\n      return (\n        <IconLoader2 className=\"h-4 w-4 animate-spin text-muted-foreground\" />\n      );\n    case \"available\":\n      return <IconCheck className=\"h-4 w-4 text-green-600\" />;\n    case \"taken\":\n      return <IconX className=\"h-4 w-4 text-destructive\" />;\n    default:\n      return null;\n  }\n}\n\nfunction ChromeIcon() {\n  return (\n    <svg\n      xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"20\"\n      height=\"20\"\n      viewBox=\"0 0 24 24\"\n      fill=\"none\"\n      stroke=\"currentColor\"\n      strokeWidth=\"2\"\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n    >\n      <circle cx=\"12\" cy=\"12\" r=\"10\" />\n      <circle cx=\"12\" cy=\"12\" r=\"4\" />\n      <line x1=\"21.17\" y1=\"8\" x2=\"12\" y2=\"8\" />\n      <line x1=\"3.95\" y1=\"6.06\" x2=\"8.54\" y2=\"14\" />\n      <line x1=\"10.88\" y1=\"21.94\" x2=\"15.46\" y2=\"14\" />\n    </svg>\n  );\n}\n","structuredPatch":[{"oldStart":256,"oldLines":6,"newStart":256,"newLines":19,"lines":["                   <span>Get the Chrome Extension</span>","                 </a>","               </Field>","+              {onExport && (","+                <Field>","+                  <FieldLabel>Data</FieldLabel>","+                  <Button","+                    type=\"button\"","+                    variant=\"outline\"","+                    onClick={onExport}","+                    className=\"w-fit\"","+                  >","+                    Export","+                  </Button>","+                </Field>","+              )}","               <DialogFooter>","                 <DialogClose render={<Button variant=\"ghost\" />}>","                   Cancel"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"af566616-0be7-42d0-b65d-ce5f05f30163"}
{"parentUuid":"8a33cc75-dfa9-493e-b582-17d0e1718c88","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01MFEj94CdD5PeNoiotvbUx9","toolUseID":"toolu_01MFEj94CdD5PeNoiotvbUx9","timestamp":"2026-02-10T17:51:05.231Z","uuid":"a8042555-492f-4bf2-85ad-6d660141d180"}
{"parentUuid":"a8042555-492f-4bf2-85ad-6d660141d180","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01U6gJE5vfoah4v17bnxNFfv","type":"message","role":"assistant","content":[{"type":"text","text":"All edits are done. Now let me stage the resolved files and verify with a type check:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":712,"cache_read_input_tokens":125476,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":712},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp67doKVp3Z4BnDju4K","type":"assistant","uuid":"33f3480c-e983-4f1f-a6d7-29b2528e6800","timestamp":"2026-02-10T17:51:09.065Z"}
{"parentUuid":"33f3480c-e983-4f1f-a6d7-29b2528e6800","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01U6gJE5vfoah4v17bnxNFfv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Unzz59KHTnKrRBszLcU3kT","name":"Bash","input":{"command":"git add .claude/settings.local.json components/dashboard-content.tsx components/header.tsx components/multi-select-toolbar.tsx components/settings-dialog.tsx","description":"Stage all resolved conflict files"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":712,"cache_read_input_tokens":125476,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":712},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp67doKVp3Z4BnDju4K","type":"assistant","uuid":"5d1becfb-6d18-4a1b-88e9-7dfe2ec73773","timestamp":"2026-02-10T17:51:10.317Z"}
{"parentUuid":"5d1becfb-6d18-4a1b-88e9-7dfe2ec73773","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Unzz59KHTnKrRBszLcU3kT","type":"tool_result","content":"","is_error":false}]},"uuid":"6ae2a199-166a-4b0b-bc2f-6dd549e8bd6e","timestamp":"2026-02-10T17:51:10.526Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"5d1becfb-6d18-4a1b-88e9-7dfe2ec73773"}
{"parentUuid":"6ae2a199-166a-4b0b-bc2f-6dd549e8bd6e","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01FMZfqxNGkbai3zvBVkrQwi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TA2XgEzmPMiPqKH9YrbDjx","name":"Bash","input":{"command":"bunx tsc --noEmit 2>&1","description":"Type check the merged code","timeout":120000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":171,"cache_read_input_tokens":126188,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":171},"output_tokens":25,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp6UZdqzidLJZ1Dw2ba","type":"assistant","uuid":"a0950966-7042-4681-bd81-ff341b72e2a7","timestamp":"2026-02-10T17:51:14.589Z"}
{"parentUuid":"a0950966-7042-4681-bd81-ff341b72e2a7","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":2,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_01TA2XgEzmPMiPqKH9YrbDjx","uuid":"961f1a05-1792-442b-a157-95803ed740c7","timestamp":"2026-02-10T17:51:16.647Z"}
{"parentUuid":"961f1a05-1792-442b-a157-95803ed740c7","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"","fullOutput":"","elapsedTimeSeconds":3,"totalLines":0,"timeoutMs":120000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_01TA2XgEzmPMiPqKH9YrbDjx","uuid":"4b1e0ba1-bbda-4396-97e4-01147605454d","timestamp":"2026-02-10T17:51:17.649Z"}
{"parentUuid":"a0950966-7042-4681-bd81-ff341b72e2a7","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TA2XgEzmPMiPqKH9YrbDjx","type":"tool_result","content":"","is_error":false}]},"uuid":"453ebeb5-e971-458f-9b4a-d8ccb14da52b","timestamp":"2026-02-10T17:51:18.135Z","toolUseResult":{"stdout":"","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"a0950966-7042-4681-bd81-ff341b72e2a7"}
{"parentUuid":"453ebeb5-e971-458f-9b4a-d8ccb14da52b","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01Th4oSfeB3eT7NT7A6gbEc1","type":"message","role":"assistant","content":[{"type":"text","text":"Type check passes cleanly. Let me also verify the new export files came through from the merge:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":142,"cache_read_input_tokens":126359,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":142},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp73Sp3xzGqiL4LkKHe","type":"assistant","uuid":"38184823-fc85-4140-b2e2-86b7409c1334","timestamp":"2026-02-10T17:51:23.218Z"}
{"parentUuid":"38184823-fc85-4140-b2e2-86b7409c1334","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01Th4oSfeB3eT7NT7A6gbEc1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019ZZHupN8d8utFSEHgvFUcn","name":"Bash","input":{"command":"ls -la components/export-dialog.tsx lib/export.ts 2>&1","description":"Verify export files exist from merge"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":142,"cache_read_input_tokens":126359,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":142},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp73Sp3xzGqiL4LkKHe","type":"assistant","uuid":"39673619-d113-4c43-a99d-4fae0757ec16","timestamp":"2026-02-10T17:51:24.292Z"}
{"parentUuid":"39673619-d113-4c43-a99d-4fae0757ec16","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01Th4oSfeB3eT7NT7A6gbEc1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014vzGDTGBxEQAj2eQXZSr7G","name":"Bash","input":{"command":"git status --short 2>&1","description":"Check merge status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":142,"cache_read_input_tokens":126359,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":142},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp73Sp3xzGqiL4LkKHe","type":"assistant","uuid":"f7548f12-78ef-4e0f-98fd-2311016e4189","timestamp":"2026-02-10T17:51:24.847Z"}
{"parentUuid":"f7548f12-78ef-4e0f-98fd-2311016e4189","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014vzGDTGBxEQAj2eQXZSr7G","type":"tool_result","content":"M  .claude/settings.local.json\nA  .entire/.gitignore\nA  .entire/settings.json\nM  .gitignore\nA  app/admin/page.tsx\nA  app/admin/signup-chart.tsx\nA  app/api/avatar/route.ts\nM  app/api/extension/bookmark/route.ts\nA  app/api/og/route.tsx\nM  app/dashboard/page.tsx\nM  app/globals.css\nM  app/layout.tsx\nM  app/login/page.tsx\nM  app/signup/page.tsx\nA  app/u/[username]/feed-response.ts\nA  app/u/[username]/feed.atom/route.ts\nA  app/u/[username]/feed.xml/route.ts\nA  app/u/[username]/page.tsx\nA  app/u/[username]/public-profile-content.tsx\nA  assets/geist-sans-semibold.ttf\nM  bun.lock\nM  components/bookmark-input.tsx\nM  components/bookmark-list.tsx\nM  components/bulk-move-dialog.tsx\nM  components/dashboard-content.tsx\nA  components/dashboard-demo-lazy.tsx\nA  components/dashboard-demo.tsx\nA  components/favicon-image.tsx\nM  components/header.tsx\nA  components/landing-icons.tsx\nM  components/landing.tsx\nM  components/login-form.tsx\nM  components/multi-select-toolbar.tsx\nM  components/oauth-button.tsx\nM  components/settings-dialog.tsx\nM  components/signup-form.tsx\nM  components/ui/input.tsx\nM  hooks/use-focus-refetch.ts\nM  lib/auth-client.ts\nM  lib/auth.ts\nA  lib/email.ts\nA  lib/emails/reset-password.ts\nA  lib/emails/verify-email.ts\nA  lib/emails/welcome.ts\nA  lib/feed.ts\nM  lib/query-provider.tsx\nM  lib/schema.ts\nM  lib/url-metadata.ts\nM  lib/utils.ts\nM  next.config.ts\nM  package.json\nA  prisma/migrations/20260205154641_public_profile/migration.sql\nA  prisma/migrations/20260206015931_add_created_at_indexes/migration.sql\nM  prisma/schema.prisma\nA  REDACTED.webp\nM  readme.md\nM  server/procedures/bookmarks.ts\nA  server/procedures/profile.ts\nA  server/procedures/public.ts\nA  server/queries/public-profile.ts\nM  server/router.ts","is_error":false}]},"uuid":"460aa280-e76f-478f-bec4-c638995f35f8","timestamp":"2026-02-10T17:51:25.051Z","toolUseResult":{"stdout":"M  .claude/settings.local.json\nA  .entire/.gitignore\nA  .entire/settings.json\nM  .gitignore\nA  app/admin/page.tsx\nA  app/admin/signup-chart.tsx\nA  app/api/avatar/route.ts\nM  app/api/extension/bookmark/route.ts\nA  app/api/og/route.tsx\nM  app/dashboard/page.tsx\nM  app/globals.css\nM  app/layout.tsx\nM  app/login/page.tsx\nM  app/signup/page.tsx\nA  app/u/[username]/feed-response.ts\nA  app/u/[username]/feed.atom/route.ts\nA  app/u/[username]/feed.xml/route.ts\nA  app/u/[username]/page.tsx\nA  app/u/[username]/public-profile-content.tsx\nA  assets/geist-sans-semibold.ttf\nM  bun.lock\nM  components/bookmark-input.tsx\nM  components/bookmark-list.tsx\nM  components/bulk-move-dialog.tsx\nM  components/dashboard-content.tsx\nA  components/dashboard-demo-lazy.tsx\nA  components/dashboard-demo.tsx\nA  components/favicon-image.tsx\nM  components/header.tsx\nA  components/landing-icons.tsx\nM  components/landing.tsx\nM  components/login-form.tsx\nM  components/multi-select-toolbar.tsx\nM  components/oauth-button.tsx\nM  components/settings-dialog.tsx\nM  components/signup-form.tsx\nM  components/ui/input.tsx\nM  hooks/use-focus-refetch.ts\nM  lib/auth-client.ts\nM  lib/auth.ts\nA  lib/email.ts\nA  lib/emails/reset-password.ts\nA  lib/emails/verify-email.ts\nA  lib/emails/welcome.ts\nA  lib/feed.ts\nM  lib/query-provider.tsx\nM  lib/schema.ts\nM  lib/url-metadata.ts\nM  lib/utils.ts\nM  next.config.ts\nM  package.json\nA  prisma/migrations/20260205154641_public_profile/migration.sql\nA  prisma/migrations/20260206015931_add_created_at_indexes/migration.sql\nM  prisma/schema.prisma\nA  REDACTED.webp\nM  readme.md\nM  server/procedures/bookmarks.ts\nA  server/procedures/profile.ts\nA  server/procedures/public.ts\nA  server/queries/public-profile.ts\nM  server/router.ts","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"f7548f12-78ef-4e0f-98fd-2311016e4189"}
{"parentUuid":"39673619-d113-4c43-a99d-4fae0757ec16","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019ZZHupN8d8utFSEHgvFUcn","type":"tool_result","content":".rw-r--r--@ 9.0k duncan 10 Feb 17:42 components/export-dialog.tsx\n.rw-r--r--@ 2.1k duncan 10 Feb 17:42 lib/export.ts","is_error":false}]},"uuid":"93d5b642-e0a0-42a0-8a0a-65ef2973ff6e","timestamp":"2026-02-10T17:51:25.071Z","toolUseResult":{"stdout":".rw-r--r--@ 9.0k duncan 10 Feb 17:42 components/export-dialog.tsx\n.rw-r--r--@ 2.1k duncan 10 Feb 17:42 lib/export.ts","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"39673619-d113-4c43-a99d-4fae0757ec16"}
{"parentUuid":"93d5b642-e0a0-42a0-8a0a-65ef2973ff6e","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01JaVoNXmpoqHYthAXeSK3AM","type":"message","role":"assistant","content":[{"type":"text","text":"All files are staged and the merge is in progress with all conflicts resolved. Let me now run the full build to make sure everything compiles:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":727,"cache_creation_input_tokens":407,"cache_read_input_tokens":126501,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":407},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp7ZW5127EtEahE52wM","type":"assistant","uuid":"39b4604f-c688-4d5a-bc97-bebc0ddbc5fe","timestamp":"2026-02-10T17:51:28.687Z"}
{"parentUuid":"39b4604f-c688-4d5a-bc97-bebc0ddbc5fe","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01JaVoNXmpoqHYthAXeSK3AM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013DQeaBXRFs64256zcKgGWm","name":"Bash","input":{"command":"bunx next build 2>&1","description":"Full Next.js build to verify merge","timeout":180000}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":727,"cache_creation_input_tokens":407,"cache_read_input_tokens":126501,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":407},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp7ZW5127EtEahE52wM","type":"assistant","uuid":"33c65393-e963-468b-8585-6527be60337f","timestamp":"2026-02-10T17:51:29.661Z"}
{"parentUuid":"33c65393-e963-468b-8585-6527be60337f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":2,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-0","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"0fe31599-50d6-4239-861c-d68eb77a04db","timestamp":"2026-02-10T17:51:31.698Z"}
{"parentUuid":"0fe31599-50d6-4239-861c-d68eb77a04db","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":3,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-1","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"6f124fef-a394-4808-b268-788b305d8f27","timestamp":"2026-02-10T17:51:32.701Z"}
{"parentUuid":"6f124fef-a394-4808-b268-788b305d8f27","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":4,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-2","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"69e9a261-bc5b-4769-a352-81768e348e94","timestamp":"2026-02-10T17:51:33.703Z"}
{"parentUuid":"69e9a261-bc5b-4769-a352-81768e348e94","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":5,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-3","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"1cc758d6-60c6-4d6c-a0c4-b114add41192","timestamp":"2026-02-10T17:51:34.713Z"}
{"parentUuid":"1cc758d6-60c6-4d6c-a0c4-b114add41192","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":6,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-4","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"9160193a-a65f-4277-b3e4-e47264c3c72e","timestamp":"2026-02-10T17:51:35.716Z"}
{"parentUuid":"9160193a-a65f-4277-b3e4-e47264c3c72e","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":7,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-5","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"3777b765-41c6-493b-8817-f29581eda620","timestamp":"2026-02-10T17:51:36.717Z"}
{"parentUuid":"3777b765-41c6-493b-8817-f29581eda620","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":8,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-6","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"9ebd7ffb-c6e7-4e21-832b-bb3824a1ce41","timestamp":"2026-02-10T17:51:37.718Z"}
{"parentUuid":"9ebd7ffb-c6e7-4e21-832b-bb3824a1ce41","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...","elapsedTimeSeconds":9,"totalLines":5,"timeoutMs":180000},"toolUseID":"bash-progress-7","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"1044f681-6c7b-4dab-9f08-71aa4cd8bf7c","timestamp":"2026-02-10T17:51:38.721Z"}
{"parentUuid":"1044f681-6c7b-4dab-9f08-71aa4cd8bf7c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","elapsedTimeSeconds":10,"totalLines":7,"timeoutMs":180000},"toolUseID":"bash-progress-8","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"eee4f266-66dd-41ec-b7e1-7f3d4016bd01","timestamp":"2026-02-10T17:51:39.722Z"}
{"parentUuid":"eee4f266-66dd-41ec-b7e1-7f3d4016bd01","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","elapsedTimeSeconds":11,"totalLines":7,"timeoutMs":180000},"toolUseID":"bash-progress-9","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"b1aba18d-5cf6-4343-82e0-d6053b95131a","timestamp":"2026-02-10T17:51:40.722Z"}
{"parentUuid":"b1aba18d-5cf6-4343-82e0-d6053b95131a","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","elapsedTimeSeconds":12,"totalLines":7,"timeoutMs":180000},"toolUseID":"bash-progress-10","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"a36675e1-ee2e-4be2-bf00-cb2fc105b42f","timestamp":"2026-02-10T17:51:41.728Z"}
{"parentUuid":"a36675e1-ee2e-4be2-bf00-cb2fc105b42f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","elapsedTimeSeconds":13,"totalLines":7,"timeoutMs":180000},"toolUseID":"bash-progress-11","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"9dee5d7a-019e-42db-80a2-4c60021a4c8a","timestamp":"2026-02-10T17:51:42.733Z"}
{"parentUuid":"9dee5d7a-019e-42db-80a2-4c60021a4c8a","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","elapsedTimeSeconds":14,"totalLines":7,"timeoutMs":180000},"toolUseID":"bash-progress-12","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"46be5336-b93f-4a58-b9da-aa929f246ded","timestamp":"2026-02-10T17:51:43.736Z"}
{"parentUuid":"46be5336-b93f-4a58-b9da-aa929f246ded","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","elapsedTimeSeconds":15,"totalLines":7,"timeoutMs":180000},"toolUseID":"bash-progress-13","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"2adb79c8-5cfd-43e3-a08d-c134a38ecfc5","timestamp":"2026-02-10T17:51:44.737Z"}
{"parentUuid":"2adb79c8-5cfd-43e3-a08d-c134a38ecfc5","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...","elapsedTimeSeconds":16,"totalLines":7,"timeoutMs":180000},"toolUseID":"bash-progress-14","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"8030ab49-9cba-460b-ac4b-462f61c36de8","timestamp":"2026-02-10T17:51:45.739Z"}
{"parentUuid":"8030ab49-9cba-460b-ac4b-462f61c36de8","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...\n  Collecting page data using 9 workers ...","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...\n  Collecting page data using 9 workers ...","elapsedTimeSeconds":17,"totalLines":8,"timeoutMs":180000},"toolUseID":"bash-progress-15","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"59b389ce-bf4a-450d-b9ac-51b9bae9568f","timestamp":"2026-02-10T17:51:46.749Z"}
{"parentUuid":"59b389ce-bf4a-450d-b9ac-51b9bae9568f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"bash_progress","output":"✓ Compiled successfully in 8.4s\n  Running TypeScript ...\n  Collecting page data using 9 workers ...\n  Generating static pages using 9 workers (0/15) ...\n  Generating static pages using 9 workers (3/15) \r","fullOutput":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...\n  Collecting page data using 9 workers ...\n  Generating static pages using 9 workers (0/15) ...\n  Generating static pages using 9 workers (3/15) \r","elapsedTimeSeconds":18,"totalLines":10,"timeoutMs":180000},"toolUseID":"bash-progress-16","parentToolUseID":"toolu_013DQeaBXRFs64256zcKgGWm","uuid":"0c08f200-9cb2-4725-9a7b-a3810d296c69","timestamp":"2026-02-10T17:51:47.750Z"}
{"parentUuid":"33c65393-e963-468b-8585-6527be60337f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013DQeaBXRFs64256zcKgGWm","type":"tool_result","content":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...\n  Collecting page data using 9 workers ...\n  Generating static pages using 9 workers (0/15) ...\n  Generating static pages using 9 workers (3/15) \r\n  Generating static pages using 9 workers (7/15) \r\n  Generating static pages using 9 workers (11/15) \r\n✓ Generating static pages using 9 workers (15/15) in 355.0ms\n  Finalizing page optimization ...\n\nRoute (app)                  Revalidate  Expire\n┌ ○ /                               15m      1y\n├ ○ /_not-found\n├ ◐ /admin\n├ ƒ /api/auth/[...all]\n├ ƒ /api/avatar\n├ ƒ /api/extension/bookmark\n├ ƒ /api/og\n├ ○ /changelog\n├ ◐ /dashboard\n├ ○ /icon.svg\n├ ◐ /login\n├ ○ /privacy\n├ ƒ /rpc/[[...rest]]\n├ ◐ /signup\n├ ○ /terms\n├ ◐ /u/[username]\n│ └ /u/[username]\n├ ƒ /u/[username]/feed.atom\n└ ƒ /u/[username]/feed.xml\n\n\nƒ Proxy (Middleware)\n\n○  (Static)             prerendered as static content\n◐  (Partial Prerender)  prerendered as static HTML with dynamic server-streamed content\nƒ  (Dynamic)            server-rendered on demand","is_error":false}]},"uuid":"329a439a-7512-4282-9700-aa0670e80648","timestamp":"2026-02-10T17:51:48.583Z","toolUseResult":{"stdout":"▲ Next.js 16.1.1 (Turbopack, Cache Components)\n- Environments: .env\n- Experiments (use with caution):\n  · optimizePackageImports\n\n  Creating an optimized production build ...\n✓ Compiled successfully in 8.4s\n  Running TypeScript ...\n  Collecting page data using 9 workers ...\n  Generating static pages using 9 workers (0/15) ...\n  Generating static pages using 9 workers (3/15) \r\n  Generating static pages using 9 workers (7/15) \r\n  Generating static pages using 9 workers (11/15) \r\n✓ Generating static pages using 9 workers (15/15) in 355.0ms\n  Finalizing page optimization ...\n\nRoute (app)                  Revalidate  Expire\n┌ ○ /                               15m      1y\n├ ○ /_not-found\n├ ◐ /admin\n├ ƒ /api/auth/[...all]\n├ ƒ /api/avatar\n├ ƒ /api/extension/bookmark\n├ ƒ /api/og\n├ ○ /changelog\n├ ◐ /dashboard\n├ ○ /icon.svg\n├ ◐ /login\n├ ○ /privacy\n├ ƒ /rpc/[[...rest]]\n├ ◐ /signup\n├ ○ /terms\n├ ◐ /u/[username]\n│ └ /u/[username]\n├ ƒ /u/[username]/feed.atom\n└ ƒ /u/[username]/feed.xml\n\n\nƒ Proxy (Middleware)\n\n○  (Static)             prerendered as static content\n◐  (Partial Prerender)  prerendered as static HTML with dynamic server-streamed content\nƒ  (Dynamic)            server-rendered on demand","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"33c65393-e963-468b-8585-6527be60337f"}
{"parentUuid":"329a439a-7512-4282-9700-aa0670e80648","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_019pnBnWeAd2rcF3Q7BGRwX1","type":"message","role":"assistant","content":[{"type":"text","text":"Build passes cleanly. Now let me commit the merge:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1383,"cache_read_input_tokens":126908,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":1383},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp9KH7oLivi5r19CtFf","type":"assistant","uuid":"85e7883a-45af-420f-9377-5618a2ab5c4f","timestamp":"2026-02-10T17:51:52.375Z"}
{"parentUuid":"85e7883a-45af-420f-9377-5618a2ab5c4f","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_019pnBnWeAd2rcF3Q7BGRwX1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XmVoENik4iQWZVVDVTf7Zw","name":"Bash","input":{"command":"git commit -m \"$(cat <<'EOF'\nmerge main into feat/export\n\nResolve conflicts by using main's architecture as base and grafting\nexport features (ExportDialog, handleQuickExport, export dropdown in\nmulti-select toolbar, Data export field in settings) into the updated\ncomponents.\nEOF\n)\"","description":"Commit the merge"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1383,"cache_read_input_tokens":126908,"output_tokens":155,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":1383,"ephemeral_5m_input_tokens":0}}},"requestId":"req_011CXzp9KH7oLivi5r19CtFf","type":"assistant","uuid":"ef0a6df2-35bf-477d-bfb2-35d0de456d3d","timestamp":"2026-02-10T17:51:55.478Z"}
{"parentUuid":"ef0a6df2-35bf-477d-bfb2-35d0de456d3d","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XmVoENik4iQWZVVDVTf7Zw","type":"tool_result","content":"[feat/export a19c3b0] merge main into feat/export","is_error":false}]},"uuid":"bdad0433-d47f-4c33-a00f-61063a4b2ac6","timestamp":"2026-02-10T17:51:56.142Z","toolUseResult":{"stdout":"[feat/export a19c3b0] merge main into feat/export","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"ef0a6df2-35bf-477d-bfb2-35d0de456d3d"}
{"parentUuid":"bdad0433-d47f-4c33-a00f-61063a4b2ac6","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XU5qMfpWo9hthdDPUXFdCT","type":"message","role":"assistant","content":[{"type":"text","text":"The merge is complete. Let me verify the final state:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":213,"cache_read_input_tokens":128291,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":213},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp9tvgNG3Y7U3myMFNq","type":"assistant","uuid":"cb81b1c7-ad07-4953-8637-230a051efb5c","timestamp":"2026-02-10T17:51:59.902Z"}
{"parentUuid":"cb81b1c7-ad07-4953-8637-230a051efb5c","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01XU5qMfpWo9hthdDPUXFdCT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017iAiQWN966aoUEWyA2ypu3","name":"Bash","input":{"command":"git log --oneline -5","description":"Show recent commits on feat/export"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":213,"cache_read_input_tokens":128291,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":213},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzp9tvgNG3Y7U3myMFNq","type":"assistant","uuid":"819c9188-0532-4ea2-a367-3c56ef18b360","timestamp":"2026-02-10T17:52:00.580Z"}
{"parentUuid":"819c9188-0532-4ea2-a367-3c56ef18b360","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017iAiQWN966aoUEWyA2ypu3","type":"tool_result","content":"a19c3b0 merge main into feat/export\nfcbafce entire init\n907dc4e feat: add RSS/Atom feeds for public profiles (#49)\nd7e3661 feat: improve arXiv metadata (#54)\nbb0e6e1 Use slugified group param (#52)","is_error":false}]},"uuid":"dc6fe48c-cce7-4178-a8e2-fa0aabc4e4e2","timestamp":"2026-02-10T17:52:00.728Z","toolUseResult":{"stdout":"a19c3b0 merge main into feat/export\nfcbafce entire init\n907dc4e feat: add RSS/Atom feeds for public profiles (#49)\nd7e3661 feat: improve arXiv metadata (#54)\nbb0e6e1 Use slugified group param (#52)","stderr":"","interrupted":false,"isImage":false},"sourceToolAssistantUUID":"819c9188-0532-4ea2-a367-3c56ef18b360"}
{"parentUuid":"dc6fe48c-cce7-4178-a8e2-fa0aabc4e4e2","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","message":{"model":"claude-opus-4-6","id":"msg_01N9BHpq2Y471pWWinFguw5T","type":"message","role":"assistant","content":[{"type":"text","text":"`★ Insight ─────────────────────────────────────`\n**Merge conflict resolution strategy**: When merging a feature branch into a heavily-diverged mainline, the key decision is which side's architecture to use as the base. Here, main had fundamentally restructured things (nuqs URL state, `orpc` query key helpers like `groupListKey()` and `bookmarkListKey()`, dynamic imports, profile/visibility features), so starting from main's version and surgically grafting the export features in was far simpler than the reverse.\n\n**Adapting to query patterns**: The feat/export branch used raw `queryKey: [\"bookmarks\", \"all\"]` for its `allBookmarksQuery`. When merging, this needed to be adapted to main's `orpc.bookmark.list.queryOptions()` pattern to stay consistent with the codebase conventions and ensure proper cache invalidation.\n\n**Dynamic imports for dialogs**: Main established a pattern of using `next/dynamic` with `{ ssr: false }` for dialog components (BulkMoveDialog, BulkDeleteDialog, SettingsDialog). The ExportDialog was added following this same pattern to keep bundle splitting consistent.\n`─────────────────────────────────────────────────`\n\n## Summary\n\nSuccessfully merged `main` into `feat/export`. Here's what was resolved:\n\n| File | Resolution |\n|---|---|\n| `.claude/settings.local.json` | Took main's version (superset) |\n| `components/dashboard-content.tsx` | Main's base + export state, `allBookmarksQuery` (adapted to `orpc` pattern), export callbacks, `ExportDialog` render |\n| `components/header.tsx` | Main's base + `onExport` prop passed through to `SettingsDialog` |\n| `components/multi-select-toolbar.tsx` | Main's base + export dropdown (between Copy URLs and visibility buttons) + `motion-reduce` classes |\n| `components/settings-dialog.tsx` | Main's base + `onExport` prop + Data/Export field in General tab |\n\nTwo new files (`components/export-dialog.tsx`, `lib/export.ts`) came through cleanly with no conflicts.\n\n**Verification**: ✅ `tsc --noEmit` passes, ✅ `next build` compiles successfully with all 15 routes generated."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":208,"cache_read_input_tokens":128504,"cache_creation":{"ephemeral_5m_input_tokens":0,"ephemeral_1h_input_tokens":208},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"}},"requestId":"req_011CXzpACpT3ZZcTsKyG4WCE","type":"assistant","uuid":"da0c2bbc-69d8-4dda-96f6-151abe36e5ec","timestamp":"2026-02-10T17:52:17.570Z"}
{"parentUuid":"da0c2bbc-69d8-4dda-96f6-151abe36e5ec","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"036921fe-4b9b-4335-a4e5-a130709fdfc1","toolUseID":"036921fe-4b9b-4335-a4e5-a130709fdfc1","timestamp":"2026-02-10T17:52:17.599Z","uuid":"8a5a0847-7beb-43df-8046-b68299d94aab"}
{"parentUuid":"8a5a0847-7beb-43df-8046-b68299d94aab","isSidechain":false,"userType":"external","cwd":"/Users/duncan/dev/bmrks","sessionId":"92dab704-6d3e-474c-b6dd-087558f6465d","version":"2.1.37","gitBranch":"feat/export","slug":"elegant-discovering-dove","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"${CLAUDE_PLUGIN_ROOT}/hooks/stop-hook.sh"},"parentToolUseID":"036921fe-4b9b-4335-a4e5-a130709fdfc1","toolUseID":"036921fe-4b9b-4335-a4e5-a130709fdfc1","timestamp":"2026-02-10T17:52:17.599Z","uuid":"aea3e425-1517-472c-9d81-3b2c1c846233"}
